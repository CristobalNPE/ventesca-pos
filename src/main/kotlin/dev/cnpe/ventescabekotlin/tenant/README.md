# Multi-Tenancy Implementation (Database per Tenant)

This document explains the multi-tenancy architecture implemented in the Ventesca backend, following the **Database per Tenant** strategy using Spring Boot, JPA/Hibernate, and Kotlin.

## Overview

Each "business" registered in Ventesca is treated as a separate tenant and gets its own dedicated PostgreSQL database instance (e.g., `ventesca_tenantA_db`, `ventesca_tenantB_db`). This provides strong data isolation between tenants. A central "master" database stores shared information, including tenant metadata (business details, tenant IDs) and potentially cross-tenant data (like supported currencies).

## Core Components

1.  **Master Database (`ventesca_master_db`)**
    *   Stores shared data and tenant metadata.
    *   Key Tables: `businesses`, `business_users`, `supported_currencies`.
    *   Managed by `MasterJpaConfig` and `masterDataSource`.

2.  **Tenant Databases (`ventesca_{tenantId}_db`)**
    *   Each tenant has a separate database with the same schema structure.
    *   Holds tenant-specific data: `brands`, `categories`, `products`, `suppliers`, `inventory_items`, etc.
    *   Schema managed by Liquibase using `tenant-changelog-master.xml`.
    *   Managed by `TenantJpaConfig` and the routing datasource mechanism.

3.  **Tenant Identifier (`tenant/vo/TenantIdentifier.kt`)**
    *   A type-safe Kotlin `value class` wrapping the unique `String` ID generated for each tenant (e.g., `businessname_a1b2c3d4`).
    *   Stored in the `businesses` table in the master DB.
    *   Generated by `TenantIdentifier.generateFrom(businessName)`.

4.  **Tenant Context (`tenant/TenantContext.kt`)**
    *   A singleton `object` holding the current tenant's ID (`String?`) in an `InheritableThreadLocal`.
    *   This makes the current tenant ID accessible throughout the execution of a single request thread (and any child threads it spawns).
    *   Methods: `setCurrentTenant(id: String?)`, `getCurrentTenant(): String?`, `clear()`.
    *   It's crucial to `clear()` the context at the end of each request/operation (handled by `TenantAuthenticationFilter`).

5.  **Tenant Data Source Management (`tenant/TenantDataSource.kt`)**
    *   A Spring `@Component` responsible for creating and caching `DataSource` (HikariCP connection pool) instances for each tenant database *on demand*.
    *   Uses `TenantDataSourceProperties` (bound to `app.datasource.tenant.*` properties) for configuration (URL template, credentials, pool settings).
    *   Provides `getDataSource(tenantId)`, `addTenant(tenantId)`, `removeTenant(tenantId)`.

6.  **DataSource Configuration (`tenant/config/DataSourceConfig.kt`)**
    *   Defines the primary Spring `@Bean`s for `DataSource`.
    *   `masterDataSource`: A `DataSource` bean pointing directly to the master database, configured via `MasterDataSourceProperties` (`app.datasource.master.*`).
    *   `tenantRoutingDataSource`: The `@Primary` `DataSource` bean injected into most of the application. This is an instance of `DynamicTenantAwareRoutingSource`.

7.  **Routing DataSource (`tenant/DynamicTenantAwareRoutingSource.kt`)**
    *   Extends Spring's `AbstractRoutingDataSource`.
    *   Its `determineTargetDataSource()` method is called whenever a connection is requested from it.
    *   It checks `TenantContext.getCurrentTenant()`:
        *   If a tenant ID is set, it calls `TenantDataSource.getDataSource(tenantId)` to get the connection pool for that specific tenant's database.
        *   If no tenant ID is set (e.g., during startup, background tasks, or accessing master data), it returns the connection pool for the configured `defaultTargetDataSource` (which is set to the `masterDataSource` bean in `DataSourceConfig`).

8.  **Hibernate Integration:**
    *   **Tenant ID Resolver (`tenant/TenantSchemaResolver.kt`)**:
        *   Implements Hibernate's `CurrentTenantIdentifierResolver<String>`.
        *   Its `resolveCurrentTenantIdentifier()` method calls `TenantContext.getCurrentTenant()` and returns the ID (or `"default"`) to Hibernate, telling it which tenant's context is active.
    *   **Connection Provider (`tenant/MultiTenantDbConnectionProvider.kt`)**:
        *   Implements Hibernate's `MultiTenantConnectionProvider<String>`.
        *   When Hibernate needs a connection for a specific tenant ID (provided by the resolver), the `getConnection(tenantIdentifier)` method is called.
        *   This implementation uses the injected `TenantDataSource` service to get the `DataSource` for the *specific* `tenantIdentifier` and returns a connection from that pool.
        *   The `getAnyConnection()` method returns a connection from the injected `masterDataSource` pool.

9.  **JPA Configuration (`config/jpa/`):**
    *   **`BaseJpaConfig.kt`:** Common helpers for creating Hibernate adapters and properties.
    *   **`MasterJpaConfig.kt`:** Configures the `EntityManagerFactory` (`masterEntityManagerFactory`) and `TransactionManager` (`masterTransactionManager`) specifically for the master database. Scans only for master entities (`Business`, `Currency`) and repositories.
    *   **`TenantJpaConfig.kt`:** Configures the `@Primary` `EntityManagerFactory` (`entityManagerFactory`) and `TransactionManager` (`transactionManager`) used by default for tenant data.
        *   Uses the `tenantRoutingDataSource`.
        *   Configured with the `TenantSchemaResolver` and `MultiTenantDbConnectionProvider`.
        *   Sets Hibernate's multi-tenancy strategy to `DATABASE`.
        *   Scans for tenant-specific entities (Brand, Category, Product, etc.) and repositories, *excluding* master entities/repositories.

10. **Request Flow & Context Setting (`security/TenantAuthenticationFilter.kt`)**
    *   This Spring Security filter runs *after* user authentication (`BearerTokenAuthenticationFilter`).
    *   It extracts the authenticated user's identifier (e.g., email from JWT).
    *   It queries the `BusinessDataPort` (which uses the master DataSource implicitly via the routing source defaulting to master when no tenant is set) to find the `tenantId` associated with the user.
    *   If a `tenantId` is found, it calls `TenantContext.setCurrentTenant(tenantId)`.
    *   If no `tenantId` is found for an authenticated user, it throws `TenantNotFoundException` (resulting in a 403 Forbidden response).
    *   A `finally` block ensures `TenantContext.clear()` is called after the rest of the filter chain executes.

11. **Schema Management (`tenant/TenantManagementService.kt` - *To Be Migrated*)**
    *   Handles creating new tenant databases (`CREATE DATABASE ...`).
    *   Handles running Liquibase migrations (`tenant-changelog-master.xml`) against specific tenant databases after creation or during updates.
    *   Depends on `TenantDataSource` and the `masterDataSource`.

## Key Decisions & Reminders

*   **Strategy:** Database per Tenant.
*   **Tenant ID:** Type-safe `value class TenantIdentifier(val value: String)`. Generated based on business name + UUID suffix.
*   **Context Propagation:** `InheritableThreadLocal` in `TenantContext`, set by `TenantAuthenticationFilter`, cleared in `finally` block.
*   **DataSource Routing:** Handled by `DynamicTenantAwareRoutingSource` delegating to `TenantDataSource` for tenant pools and using a configured default (master pool) when no tenant context is set.
*   **Hibernate Integration:** Uses standard Hibernate multi-tenancy interfaces (`CurrentTenantIdentifierResolver`, `MultiTenantConnectionProvider`) linked to `TenantContext` and `TenantDataSource`.
*   **Configuration:** Separate JPA configurations (`MasterJpaConfig`, `TenantJpaConfig`) manage distinct persistence units. `@ConfigurationProperties` used for cleaner property binding.
*   **Error Handling:** Tenant resolution failures result in `TenantNotFoundException` (403). Tenant creation failures result in `TenantCreationException` (500). Both are handled by `GlobalExceptionHandler`.
*   **Testing:** Integration tests need to manage test tenant creation, run tenant migrations, and set `TenantContext` appropriately. (Using Testcontainers with programmatic DB/schema setup is recommended).

---