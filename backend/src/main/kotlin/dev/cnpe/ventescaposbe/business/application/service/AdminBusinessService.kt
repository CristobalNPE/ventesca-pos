package dev.cnpe.ventescaposbe.business.application.service

import dev.cnpe.ventescaposbe.business.application.dto.request.AdminCreateBusinessRequest
import dev.cnpe.ventescaposbe.business.application.dto.response.BusinessDetailedResponse
import dev.cnpe.ventescaposbe.business.application.exception.BusinessErrorCode.ACTIVATION_FAILED
import dev.cnpe.ventescaposbe.business.application.exception.BusinessErrorCode.USER_ALREADY_LINKED
import dev.cnpe.ventescaposbe.business.application.mapper.BusinessMapper
import dev.cnpe.ventescaposbe.business.domain.enums.BusinessStatus
import dev.cnpe.ventescaposbe.business.domain.model.Business
import dev.cnpe.ventescaposbe.business.domain.model.BusinessBranch
import dev.cnpe.ventescaposbe.business.domain.model.BusinessUser
import dev.cnpe.ventescaposbe.business.event.BusinessActivatedEvent
import dev.cnpe.ventescaposbe.business.infrastructure.persistence.BusinessRepository
import dev.cnpe.ventescaposbe.business.infrastructure.persistence.BusinessUserRepository
import dev.cnpe.ventescaposbe.currency.infrastructure.persistence.CurrencyRepository
import dev.cnpe.ventescaposbe.security.context.UserContext
import dev.cnpe.ventescaposbe.security.ports.IdentityProviderPort
import dev.cnpe.ventescaposbe.security.ports.dto.NewUserData
import dev.cnpe.ventescaposbe.shared.application.exception.DomainException
import dev.cnpe.ventescaposbe.shared.application.exception.GeneralErrorCode.INSUFFICIENT_CONTEXT
import dev.cnpe.ventescaposbe.shared.application.exception.GeneralErrorCode.INVALID_DATA
import dev.cnpe.ventescaposbe.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescaposbe.shared.application.exception.createResourceNotFoundException
import dev.cnpe.ventescaposbe.shared.domain.vo.Address
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.context.ApplicationEventPublisher
import org.springframework.context.MessageSource
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.data.repository.findByIdOrNull
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Propagation
import org.springframework.transaction.annotation.Transactional
import org.springframework.transaction.support.TransactionTemplate

private val log = KotlinLogging.logger {}

@Service
class AdminBusinessService(
    private val idpPort: IdentityProviderPort,
    private val businessFactory: BusinessFactory,
    private val businessRepository: BusinessRepository,
    private val businessUserRepository: BusinessUserRepository,
    private val businessMapper: BusinessMapper,

    @Qualifier("masterTransactionTemplate")
    private val masterTransactionTemplate: TransactionTemplate,
    private val eventPublisher: ApplicationEventPublisher,
    private val messageSource: MessageSource,
    private val currencyRepository: CurrencyRepository,
    private val userContext: UserContext
) {

    companion object {
        private const val ROLE_BUSINESS_ADMIN = "BUSINESS_ADMIN"
        private const val TENANT_ID_ATTRIBUTE = "tenant_id"
    }

    /**
     * Registers a new business and its initial administrator user.
     * Orchestrated by a Superuser. Involves IdP interaction, tenant DB creation,
     * and master DB record creation.
     *
     * @param request DTO containing all necessary initial data.
     * @return Detailed DTO of the newly created and configured business.
     * @throws DomainException if validation fails (e.g., duplicate email/business name).
     * @throws IdpUserCreationException if user creation in IdP fails.
     * @throws TenantCreationException if tenant DB creation or migration fails.
     */
    @Transactional(propagation = Propagation.NEVER)
    fun registerNewBusinessAndAdmin(request: AdminCreateBusinessRequest): BusinessDetailedResponse {
        log.warn { "⚠️ Initiating NEW BUSINESS registration by Superuser for: ${request.businessName} (Admin Email: ${request.adminUserEmail})" }

        masterTransactionTemplate.execute {
            validateAdminCreateRequest(request)
        }

        val newAdminUserData = NewUserData(
            email = request.adminUserEmail,
            firstName = request.adminUserFirstName,
            lastName = request.adminUserLastName,
            initialPassword = request.adminUserInitialPassword // or Autogenerated?
        )


        val idpAttributes = mapOf<String,String>()

        val idpUser = idpPort.createUser(newAdminUserData, setOf(ROLE_BUSINESS_ADMIN), idpAttributes)
        log.info { "IdP User created successfully: ${idpUser.email} (ID: ${idpUser.id})" }

        val (tenantId, businessShell) = businessFactory
            .createNewBusinessShell(idpUser.id, request.businessName)
        log.info { "Tenant infrastructure created: ${tenantId.value}" }

        val savedBusiness = masterTransactionTemplate.execute {
            businessShell.details = businessFactory.buildBusinessDetails(request)
            businessShell.contactInfo = businessFactory.buildBusinessContactInfo(request)
            businessShell.configuration = businessFactory.buildBusinessConfig(request)

            val mainBranchAddress = Address.buildAddress(
                street = request.mainBranchStreet,
                city = request.mainBranchCity,
                country = request.mainBranchCountry,
                zipCode = request.mainBranchZipCode
            ) ?: Address.empty()

            val branchName = request.mainBranchName.takeUnless { it.isNullOrBlank() }
                ?: messageSource.getMessage(
                    "default.branch.main.name",
                    null,
                    "Main Store",
                    LocaleContextHolder.getLocale()
                )

            val mainBranch = BusinessBranch(
                business = businessShell,
                branchName = branchName!!,
                address = mainBranchAddress,
                branchContactNumber = request.contactPhone,
                isMainBranch = true,
                branchManagerId = idpUser.id
            )

            businessShell.addBranch(mainBranch)
            val saved = businessRepository.save(businessShell)
            log.info { "Business entity saved to master DB. ID: ${saved.id}, Tenant: ${saved.tenantId.value}" }

            val displayName = "${idpUser.firstName ?: ""} ${idpUser.lastName ?: ""}".trim()
                .ifEmpty { idpUser.username ?: idpUser.email }
            val rolesSet = setOf(ROLE_BUSINESS_ADMIN)

            val businessUserLink = BusinessUser.createLink(
                idpUserId = idpUser.id,
                userEmail = request.adminUserEmail,
                displayName = displayName,
                roles = rolesSet,
            )
            businessUserLink.business = saved
            businessUserRepository.save(businessUserLink)
            log.info { "BusinessUser link saved for IdP User ${idpUser.id} to Business ${saved.id}" }
            saved
        } ?: throw IllegalStateException("Failed to save business entity within transaction.")

        log.info { "✅ Successfully registered business '${savedBusiness.details.businessName}' (ID: ${savedBusiness.id}, Tenant: ${savedBusiness.tenantId.value})" }

        return businessMapper.toDetailedDto(savedBusiness)
    }


    /**
     * Activates a business, changing its status to ACTIVE.
     * Typically performed by a Superuser after verifying setup completion.
     * Requires the Business entity to be in a PENDING state and meet all prerequisites.
     *
     * @param businessId The ID of the business to activate.
     * @return A detailed DTO of the activated business.
     * @throws DomainException if the business cannot be found or activation prerequisites are not met.
     */
    fun activateBusiness(businessId: Long): BusinessDetailedResponse {

        val activatedBusiness = masterTransactionTemplate.execute {
            val business = businessRepository.findByIdOrNull(businessId)
                ?: throw createResourceNotFoundException("Business", businessId)

            log.info { "Attempting to activate business: ${business.details.businessName} (ID: ${business.id})" }
            validateCanActivate(business)

            business.updateStatus(BusinessStatus.ACTIVE, "Activated by Superuser")
            val activated = businessRepository.save(business)

            eventPublisher.publishEvent(BusinessActivatedEvent(business.id!!, business.details.businessName))
            log.info { "✅ Business activated: ${business.details.businessName} (ID: ${business.id})" }
            activated
        } ?: throw IllegalStateException("Failed to activate business ID $businessId within transaction.")

        return businessMapper.toDetailedDto(activatedBusiness)
    }


    // needs to run within a master transaction
    private fun validateAdminCreateRequest(request: AdminCreateBusinessRequest) {
        log.debug { "Validating AdminCreateBusinessRequest..." }

        // Check 1: Does business name already exist?
        if (businessRepository.existsByDetails_BusinessName(request.businessName)) {
            throw createDuplicatedResourceException("businessName", request.businessName)
        }

        // Check 2: Does admin user email already exist in IdP?
        idpPort.findUserByEmail(request.adminUserEmail)?.let { existingUser ->
            log.warn { "Admin user email ${request.adminUserEmail} already exists in IdP (ID: ${existingUser.id}). Cannot create new business with this admin." }
            throw createDuplicatedResourceException("adminUserEmail", request.adminUserEmail)
        }

        // Check 3: Does admin user email already linked to another business?
        if (businessUserRepository.findByUserEmail(request.adminUserEmail) != null) {
            throw DomainException(
                USER_ALREADY_LINKED,
                mapOf("field" to "adminUserEmail", "value" to request.adminUserEmail),
            )
        }

        // Check 4: Currency Code Validation
        if (!currencyRepository.existsByCodeAndIsActiveTrue(request.currencyCode)) {
            throw DomainException(
                INVALID_DATA,
                mapOf("field" to "currencyCode", "value" to request.currencyCode)
            )
        }
        log.debug { "AdminCreateBusinessRequest validation passed." }
    }

    private fun validateCanActivate(business: Business) {
        val reasons = mutableListOf<String>()

        if (business.statusInfo?.status != BusinessStatus.PENDING) {
            reasons.add("Business is not in PENDING state (Current: ${business.statusInfo?.status})")
        }
        if (business.adminId.isBlank()) reasons.add("Administrator ID not defined")
        if (!business.hasValidDetails()) reasons.add("Business details are incomplete")
        if (!business.hasValidContactInfo()) reasons.add("Business contact info is incomplete")
        if (!business.hasValidConfiguration()) reasons.add("Business configuration is incomplete")
        if (!business.hasMainBranch()) reasons.add("Main branch has not been defined")

        if (reasons.isNotEmpty()) {
            throw DomainException(
                errorCode = ACTIVATION_FAILED,
                details = mapOf("businessId" to business.id!!, "reasons" to reasons),
            )
        }
        log.debug { "Business ${business.id} passed activation validation." }
    }
}