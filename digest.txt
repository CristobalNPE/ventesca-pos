Directory structure:
└── kotlin/
    └── dev/
        └── cnpe/
            └── ventescabekotlin/
                ├── VentescaBeKotlinApplication.kt
                ├── brands/
                │   ├── application/
                │   │   ├── api/
                │   │   │   └── BrandInfoPort.kt
                │   │   ├── dto/
                │   │   │   ├── request/
                │   │   │   │   ├── CreateBrandRequest.kt
                │   │   │   │   └── UpdateBrandRequest.kt
                │   │   │   └── response/
                │   │   │       ├── BrandDetailedResponse.kt
                │   │   │       └── BrandSummaryResponse.kt
                │   │   ├── events/
                │   │   │   └── BrandDeleteAttemptedEvent.kt
                │   │   ├── exception/
                │   │   │   └── BrandOperationNotAllowedReason.kt
                │   │   ├── mapper/
                │   │   │   └── BrandMapper.kt
                │   │   └── service/
                │   │       └── BrandService.kt
                │   ├── domain/
                │   │   ├── factory/
                │   │   │   └── BrandFactory.kt
                │   │   └── model/
                │   │       └── Brand.kt
                │   └── infrastructure/
                │       ├── BrandRepository.kt
                │       └── web/
                │           └── BrandController.kt
                ├── business/
                │   ├── application/
                │   │   ├── api/
                │   │   │   └── BusinessDataPort.kt
                │   │   ├── dto/
                │   │   │   ├── request/
                │   │   │   │   ├── AdminCreateBusinessRequest.kt
                │   │   │   │   ├── CreateBusinessBranchRequest.kt
                │   │   │   │   ├── CreateBusinessUserRequest.kt
                │   │   │   │   ├── UpdateBusinessBasicsRequest.kt
                │   │   │   │   ├── UpdateBusinessConfigurationRequest.kt
                │   │   │   │   └── UpdateBusinessContactInfoRequest.kt
                │   │   │   └── response/
                │   │   │       ├── BusinessBranchInfo.kt
                │   │   │       ├── BusinessDetailedResponse.kt
                │   │   │       ├── BusinessStatusResponse.kt
                │   │   │       └── BusinessUserInfo.kt
                │   │   ├── exception/
                │   │   │   ├── BusinessErrorCode.kt
                │   │   │   └── BusinessOperationNotAllowedReason.kt
                │   │   ├── mapper/
                │   │   │   └── BusinessMapper.kt
                │   │   └── service/
                │   │       ├── AdminBusinessService.kt
                │   │       ├── BusinessDataService.kt
                │   │       ├── BusinessFactory.kt
                │   │       ├── BusinessManagementService.kt
                │   │       └── UserManagementService.kt
                │   ├── config/
                │   │   └── BusinessLimitProperties.kt
                │   ├── domain/
                │   │   ├── enums/
                │   │   │   ├── BusinessStatus.kt
                │   │   │   └── PaymentMethod.kt
                │   │   ├── model/
                │   │   │   ├── Business.kt
                │   │   │   ├── BusinessBranch.kt
                │   │   │   └── BusinessUser.kt
                │   │   └── vo/
                │   │       ├── BusinessConfiguration.kt
                │   │       ├── BusinessContactInfo.kt
                │   │       ├── BusinessDetails.kt
                │   │       └── BusinessStatusInfo.kt
                │   ├── dto/
                │   │   └── BusinessPaymentData.kt
                │   ├── event/
                │   │   └── BusinessActivatedEvent.kt
                │   └── infrastructure/
                │       ├── persistence/
                │       │   ├── BusinessRepository.kt
                │       │   └── BusinessUserRepository.kt
                │       └── web/
                │           ├── AdminBusinessController.kt
                │           └── UserManagementController.kt
                ├── catalog/
                │   ├── api/
                │   │   └── ProductInfoPort.kt
                │   ├── application/
                │   │   ├── dto/
                │   │   │   ├── common/
                │   │   │   │   ├── ProductDetails.kt
                │   │   │   │   ├── ProductPricingData.kt
                │   │   │   │   ├── ProductRelationsData.kt
                │   │   │   │   └── ProductStockData.kt
                │   │   │   ├── request/
                │   │   │   │   ├── CreateProductDraftRequest.kt
                │   │   │   │   ├── CreateProductRequest.kt
                │   │   │   │   ├── UpdateProductBasicsRequest.kt
                │   │   │   │   ├── UpdateProductRelationsRequest.kt
                │   │   │   │   ├── UpdateProductSellingPriceRequest.kt
                │   │   │   │   ├── UpdateProductStatusRequest.kt
                │   │   │   │   └── UpdateProductSupplierCostRequest.kt
                │   │   │   └── response/
                │   │   │       ├── ProductCreatedResponse.kt
                │   │   │       ├── ProductDetailedResponse.kt
                │   │   │       ├── ProductPriceInfoResponse.kt
                │   │   │       └── ProductSummaryResponse.kt
                │   │   ├── factory/
                │   │   │   └── ProductFactory.kt
                │   │   ├── mapper/
                │   │   │   └── ProductMapper.kt
                │   │   ├── service/
                │   │   │   ├── ProductInfoAdapter.kt
                │   │   │   ├── ProductService.kt
                │   │   │   ├── ProductUpdateService.kt
                │   │   │   └── SkuGenerator.kt
                │   │   ├── util/
                │   │   │   └── ProductUtils.kt
                │   │   └── validation/
                │   │       └── ProductRelationValidator.kt
                │   ├── domain/
                │   │   ├── enums/
                │   │   │   ├── PriceChangeReason.kt
                │   │   │   └── ProductStatus.kt
                │   │   └── model/
                │   │       ├── Product.kt
                │   │       └── ProductPrice.kt
                │   ├── event/
                │   │   └── ProductCreatedEvent.kt
                │   └── infrastructure/
                │       └── persistence/
                │           ├── ProductPriceRepository.kt
                │           └── ProductRepository.kt
                ├── categories/
                │   ├── application/
                │   │   ├── api/
                │   │   │   └── CategoryInfoPort.kt
                │   │   ├── dto/
                │   │   │   ├── request/
                │   │   │   │   ├── CreateCategoryRequest.kt
                │   │   │   │   └── UpdateCategoryRequest.kt
                │   │   │   └── response/
                │   │   │       ├── CategoryCreatedResponse.kt
                │   │   │       ├── CategoryDetailedResponse.kt
                │   │   │       ├── CategorySummaryResponse.kt
                │   │   │       └── CategoryWithChildrenResponse.kt
                │   │   ├── events/
                │   │   │   ├── CategoryRelocatedEvent.kt
                │   │   │   └── DefaultCategoryCreatedEvent.kt
                │   │   ├── exception/
                │   │   │   └── CategoryOperationNotAllowedReason.kt
                │   │   ├── mapper/
                │   │   │   └── CategoryMapper.kt
                │   │   └── service/
                │   │       └── CategoryService.kt
                │   ├── domain/
                │   │   ├── factory/
                │   │   │   └── CategoryFactory.kt
                │   │   └── model/
                │   │       └── Category.kt
                │   └── infrastructure/
                │       ├── CategoryRepository.kt
                │       └── web/
                │           └── CategoryController.kt
                ├── config/
                │   ├── MessageSourceConfig.kt
                │   ├── PersistenceAuditConfig.kt
                │   ├── SecurityConfig.kt
                │   └── jpa/
                │       ├── BaseJpaConfig.kt
                │       ├── MasterJpaConfig.kt
                │       └── TenantJpaConfig.kt
                ├── currency/
                │   ├── config/
                │   │   └── CurrencyInitializer.kt
                │   ├── domain/
                │   │   └── model/
                │   │       └── Currency.kt
                │   ├── exception/
                │   │   └── CurrencyNotFoundException.kt
                │   ├── infrastructure/
                │   │   └── persistence/
                │   │       └── CurrencyRepository.kt
                │   ├── service/
                │   │   └── MoneyFactory.kt
                │   └── vo/
                │       └── Money.kt
                ├── inventory/
                │   ├── application/
                │   │   ├── api/
                │   │   │   ├── InventoryInfoPort.kt
                │   │   │   └── dto/
                │   │   │       ├── BranchInventoryDetails.kt
                │   │   │       └── ProductInventorySummary.kt
                │   │   ├── dto/
                │   │   │   ├── request/
                │   │   │   │   └── UpdateStockRequest.kt
                │   │   │   └── response/
                │   │   └── service/
                │   │       ├── InventoryInfoService.kt
                │   │       └── InventoryManagementService.kt
                │   ├── domain/
                │   │   ├── entity/
                │   │   │   ├── InventoryItem.kt
                │   │   │   └── StockModification.kt
                │   │   ├── enums/
                │   │   │   ├── StockModificationReason.kt
                │   │   │   ├── StockModificationType.kt
                │   │   │   └── StockUnitType.kt
                │   │   └── vo/
                │   │       └── Stock.kt
                │   ├── event/
                │   │   └── StockUpdatedEvent.kt
                │   └── infrastructure/
                │       ├── persistence/
                │       │   └── InventoryItemRepository.kt
                │       └── web/
                │           └── InventoryController.kt
                ├── security/
                │   ├── TenantAuthenticationFilter.kt
                │   ├── adapters/
                │   │   └── KeycloakIdentityProviderAdapter.kt
                │   ├── config/
                │   │   └── KeycloakAdminProperties.kt
                │   ├── context/
                │   │   ├── RequestUserContext.kt
                │   │   └── UserContext.kt
                │   ├── exception/
                │   │   ├── IdpAccessException.kt
                │   │   ├── IdpRoleAssignmentException.kt
                │   │   ├── IdpUserCreationException.kt
                │   │   └── IdpUserNotFoundException.kt
                │   ├── filters/
                │   │   └── UserContextPopulationFilter.kt
                │   └── ports/
                │       ├── IdentityProviderPort.kt
                │       └── dto/
                │           ├── NewUserData.kt
                │           └── UserIdentity.kt
                ├── shared/
                │   ├── application/
                │   │   ├── dto/
                │   │   │   ├── ApiResult.kt
                │   │   │   ├── EnumInfoResponse.kt
                │   │   │   ├── EnumValueInfo.kt
                │   │   │   ├── ErrorResponse.kt
                │   │   │   ├── PageResponse.kt
                │   │   │   └── ResourceAuditData.kt
                │   │   ├── exception/
                │   │   │   ├── DomainException.kt
                │   │   │   ├── DomainExceptionUtils.kt
                │   │   │   ├── ErrorCode.kt
                │   │   │   ├── GeneralErrorCode.kt
                │   │   │   └── OperationNotAllowedReason.kt
                │   │   ├── service/
                │   │   │   ├── CodeGeneratorService.kt
                │   │   │   └── EnumTranslationService.kt
                │   │   └── validation/
                │   │       ├── NotBlankIfPresent.kt
                │   │       └── NotBlankIfPresentValidator.kt
                │   ├── domain/
                │   │   ├── enums/
                │   │   │   └── DomainEnum.kt
                │   │   ├── model/
                │   │   │   └── BaseEntity.kt
                │   │   └── vo/
                │   │       ├── Address.kt
                │   │       ├── ContactInfo.kt
                │   │       ├── GeneratedCode.kt
                │   │       ├── Image.kt
                │   │       └── PersonalInfo.kt
                │   └── infrastructure/
                │       └── web/
                │           ├── EnumInfoController.kt
                │           ├── advice/
                │           │   ├── ExceptionHandlerUtils.kt
                │           │   └── GlobalExceptionHandler.kt
                │           └── filters/
                │               └── MDCLoggingFilter.kt
                ├── suppliers/
                │   ├── application/
                │   │   ├── api/
                │   │   │   └── SupplierInfoPort.kt
                │   │   ├── dto/
                │   │   │   ├── request/
                │   │   │   │   ├── CreateSupplierRequest.kt
                │   │   │   │   ├── UpdateSupplierRequest.kt
                │   │   │   │   └── UpdateSupplierStatusRequest.kt
                │   │   │   └── response/
                │   │   │       ├── SupplierDetailedResponse.kt
                │   │   │       └── SupplierSummaryResponse.kt
                │   │   ├── events/
                │   │   │   └── SupplierDeleteAttemptedEvent.kt
                │   │   ├── exception/
                │   │   │   └── SupplierOperationNotAllowedReason.kt
                │   │   ├── mapper/
                │   │   │   └── SupplierMapper.kt
                │   │   └── service/
                │   │       ├── SupplierInfoAdapter.kt
                │   │       └── SupplierService.kt
                │   ├── domain/
                │   │   ├── Supplier.kt
                │   │   └── factory/
                │   │       └── SupplierFactory.kt
                │   └── infrastructure/
                │       ├── persistence/
                │       │   └── SupplierRepository.kt
                │       └── web/
                │           └── SupplierController.kt
                └── tenant/
                    ├── README.md
                    ├── DynamicTenantAwareRoutingSource.kt
                    ├── MultiTenantDbConnectionProvider.kt
                    ├── TenantContext.kt
                    ├── TenantDataSource.kt
                    ├── TenantSchemaResolver.kt
                    ├── config/
                    │   ├── DataSourceConfig.kt
                    │   ├── MasterDataSourceProperties.kt
                    │   ├── TenantDataSourceProperties.kt
                    │   └── TenantSchemaInitializer.kt
                    ├── dto/
                    │   └── TenantOperationResult.kt
                    ├── exception/
                    │   ├── TenantCreationException.kt
                    │   ├── TenantErrorCode.kt
                    │   └── TenantNotFoundException.kt
                    ├── infrastructure/
                    │   └── web/
                    │       └── TenantAdminController.kt
                    ├── service/
                    │   └── TenantManagementService.kt
                    └── vo/
                        └── TenantIdentifier.kt

================================================
File: dev/cnpe/ventescabekotlin/VentescaBeKotlinApplication.kt
================================================
package dev.cnpe.ventescabekotlin

import dev.cnpe.ventescabekotlin.business.config.BusinessLimitProperties
import dev.cnpe.ventescabekotlin.security.config.KeycloakAdminProperties
import dev.cnpe.ventescabekotlin.tenant.config.MasterDataSourceProperties
import dev.cnpe.ventescabekotlin.tenant.config.TenantDataSourceProperties
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.runApplication

@SpringBootApplication
@EnableConfigurationProperties(
    TenantDataSourceProperties::class,
    MasterDataSourceProperties::class,
    KeycloakAdminProperties::class,
    BusinessLimitProperties::class
)
class VentescaBeKotlinApplication

fun main(args: Array<String>) {
    runApplication<VentescaBeKotlinApplication>(*args)
}


================================================
File: dev/cnpe/ventescabekotlin/brands/application/api/BrandInfoPort.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.api

/**
 * Port defining operations for retrieving basic Brand information needed by other modules.
 */
interface BrandInfoPort {

    /**
     * Retrieves the unique code of a brand by its ID.
     *
     * @param brandId The ID of the brand.
     * @return The brand code string.
     * @throws DomainException (e.g., RESOURCE_NOT_FOUND) if the brand ID is invalid.
     */
    fun getBrandCodeById(brandId: Long): String

    /**
     * Retrieves the unique identifier of the default brand configured for the tenant.
     *
     * @return The ID of the default brand.
     * @throws DomainException (e.g., RESOURCE_NOT_FOUND) if no default brand is configured or found.
     */
    fun getDefaultBrandId(): Long
}

================================================
File: dev/cnpe/ventescabekotlin/brands/application/dto/request/CreateBrandRequest.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import org.hibernate.validator.constraints.Length

@Schema(description = "Request to create a new brand.")
data class CreateBrandRequest(

    @field:NotBlank(message = "Name must not be blank.")
    @field:Length(min = 2, max = 20, message = "Name must be between 2 and 20 characters.")
    @Schema(description = "Brand name.", example = "Sony")
    val name: String
)


================================================
File: dev/cnpe/ventescabekotlin/brands/application/dto/request/UpdateBrandRequest.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import org.hibernate.validator.constraints.Length

@Schema(description = "Request to update a brand.")
data class UpdateBrandRequest(

//    @field:NotBlankIfPresent // We don't have this annotation migrated yet.
    @field:Length(min = 2, max = 20, message = "Name must be between 2 and 20 characters.")
    @Schema(description = "Brand name.", example = "Sony")
    val name: String
)

================================================
File: dev/cnpe/ventescabekotlin/brands/application/dto/response/BrandDetailedResponse.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.dto.response

import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Detailed information for a brand.")
data class BrandDetailedResponse(

    @Schema(description = "Brand ID.", requiredMode = Schema.RequiredMode.REQUIRED)
    val id: Long,

    @Schema(description = "Brand name.", requiredMode = Schema.RequiredMode.REQUIRED, example = "Sony")
    val name: String,

    @Schema(description = "Brand code.", requiredMode = Schema.RequiredMode.REQUIRED, example = "SNY")
    val code:String,

    @Schema(description = "Audit information.", requiredMode = Schema.RequiredMode.REQUIRED)
    val isDefault: Boolean,

    @Schema(description = "Audit information.", requiredMode = Schema.RequiredMode.REQUIRED)
    val auditData: ResourceAuditData
)


================================================
File: dev/cnpe/ventescabekotlin/brands/application/dto/response/BrandSummaryResponse.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import java.time.OffsetDateTime

@Schema(description = "Basic summary information for a brand, suitable for lists.")
data class BrandSummaryResponse(

    @Schema(description = "Brand ID.", requiredMode = Schema.RequiredMode.REQUIRED)
    val id: Long,

    @Schema(description = "Brand name.", requiredMode = Schema.RequiredMode.REQUIRED, example = "Sony")
    val name: String,

    @Schema(description = "Brand code.", requiredMode = Schema.RequiredMode.REQUIRED, example = "SNY")
    val code: String,

    @Schema(description = "Indicates if the brand is the default brand.", requiredMode = Schema.RequiredMode.REQUIRED)
    val isDefault: Boolean,

    @Schema(description = "Timestamp of creation.", requiredMode = Schema.RequiredMode.REQUIRED, format = "date-time")
    val createdAt: OffsetDateTime
)


================================================
File: dev/cnpe/ventescabekotlin/brands/application/events/BrandDeleteAttemptedEvent.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.events

data class BrandDeleteAttemptedEvent(
    val brandId: Long
)


================================================
File: dev/cnpe/ventescabekotlin/brands/application/exception/BrandOperationNotAllowedReason.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.OperationNotAllowedReason

enum class BrandOperationNotAllowedReason: OperationNotAllowedReason {
    IS_DEFAULT_BRAND
}

================================================
File: dev/cnpe/ventescabekotlin/brands/application/mapper/BrandMapper.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.mapper

import dev.cnpe.ventescabekotlin.brands.application.dto.response.BrandDetailedResponse
import dev.cnpe.ventescabekotlin.brands.application.dto.response.BrandSummaryResponse
import dev.cnpe.ventescabekotlin.brands.domain.model.Brand
import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import org.springframework.stereotype.Component

@Component
class BrandMapper {


    fun toSummary(brand: Brand): BrandSummaryResponse {
        return BrandSummaryResponse(
            id = brand.id!!,
            name = brand.name,
            code = brand.code.codeValue,
            isDefault = brand.isDefault,
            createdAt = brand.createdAt
        )
    }


    fun toDetailed(brand: Brand): BrandDetailedResponse {
        return BrandDetailedResponse(
            id = brand.id!!,
            name = brand.name,
            code = brand.code.codeValue,
            isDefault = brand.isDefault,
            auditData = ResourceAuditData.fromBaseEntity(brand)
        )

    }

}

================================================
File: dev/cnpe/ventescabekotlin/brands/application/service/BrandService.kt
================================================
package dev.cnpe.ventescabekotlin.brands.application.service

import dev.cnpe.ventescabekotlin.brands.application.dto.request.CreateBrandRequest
import dev.cnpe.ventescabekotlin.brands.application.dto.request.UpdateBrandRequest
import dev.cnpe.ventescabekotlin.brands.application.dto.response.BrandDetailedResponse
import dev.cnpe.ventescabekotlin.brands.application.dto.response.BrandSummaryResponse
import dev.cnpe.ventescabekotlin.brands.application.events.BrandDeleteAttemptedEvent
import dev.cnpe.ventescabekotlin.brands.application.exception.BrandOperationNotAllowedReason.IS_DEFAULT_BRAND
import dev.cnpe.ventescabekotlin.brands.application.mapper.BrandMapper
import dev.cnpe.ventescabekotlin.brands.domain.factory.BrandFactory
import dev.cnpe.ventescabekotlin.brands.domain.model.Brand
import dev.cnpe.ventescabekotlin.brands.infrastructure.BrandRepository
import dev.cnpe.ventescabekotlin.business.event.BusinessActivatedEvent
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescabekotlin.shared.application.exception.createOperationNotAllowedException
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import dev.cnpe.ventescabekotlin.shared.application.service.CodeGeneratorService
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.ApplicationEventPublisher
import org.springframework.data.repository.findByIdOrNull
import org.springframework.modulith.events.ApplicationModuleListener
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
@Transactional
class BrandService(
    private val brandRepository: BrandRepository,
    private val brandMapper: BrandMapper,
    private val brandFactory: BrandFactory,
    private val eventPublisher: ApplicationEventPublisher,
    private val codeGeneratorService: CodeGeneratorService
) {

    // *******************************
    // 🔰 Brand Management
    // *******************************

    /**
     * Registers a new brand based on the provided request, validates the data,
     * and persists the brand into the repository. Converts the newly created
     * brand entity into a summary response.
     *
     * @param brandRequest The request containing the brand details to create, including a mandatory name.
     * @return A summary response object containing details of the newly created brand.
     * @throws DomainException If a brand with the same name already exists.
     */
    fun registerBrand(brandRequest: CreateBrandRequest): BrandSummaryResponse {
        log.debug { "Attempting to register brand: ${brandRequest.name}" }
        validateBrandRequest(brandRequest)

        val newBrand = brandFactory.create(brandRequest.name)
        val savedBrand = brandRepository.save(newBrand)
        log.info { "Registered brand: ${savedBrand.name} (ID: ${savedBrand.id})" }

        return brandMapper.toSummary(savedBrand)
    }

    /**
     * Retrieves detailed information about a brand based on its unique identifier.
     *
     * @param id The ID of the brand to retrieve details for.
     * @return A detailed response object containing information about the specified brand.
     * @throws DomainException If the brand with the given ID does not exist.
     */
    @Transactional(readOnly = true)
    fun getBrandDetails(id: Long): BrandDetailedResponse {
        val brand = findBrandByIdOrThrow(id)
        return brandMapper.toDetailed(brand)
    }

    /**
     * Updates an existing brand based on the provided brand ID and update request data.
     *
     * @param id The ID of the brand to update.
     * @param brandRequest The request containing the updated brand details.
     * @return A detailed response object containing information about the updated brand.
     * @throws DomainException If the update request fails validation or if a brand with the requested name already exists.
     */
    fun updateBrand(id: Long, brandRequest: UpdateBrandRequest): BrandDetailedResponse {
        log.debug { "Attempting to update brand for ID: $id with data: $brandRequest" }
        val brand = findBrandByIdOrThrow(id)

        updateBrandFromRequest(brand, brandRequest)

        val updatedBrand = brandRepository.save(brand)
        log.info { "Updated brand: ${updatedBrand.name} (ID: ${updatedBrand.id})" }

        return brandMapper.toDetailed(updatedBrand)
    }

    /**
     * Retrieves a list of all brands and maps them to summary response objects.
     *
     * @return A list of BrandSummaryResponse objects representing all brands.
     */
    @Transactional(readOnly = true)
    fun getAllBrands(): List<BrandSummaryResponse> {
        log.debug { "Fetching all brands" }
        return brandRepository.findAll().map { brandMapper.toSummary(it) }
    }

    /**
     * Deletes a brand identified by the provided ID.
     * If the brand is marked as a default brand, an exception is thrown.
     * Also, emits an event indicating an attempt to delete the brand.
     *
     * @param id The unique identifier of the brand to be deleted.
     * @throws DomainException If the brand is a default brand or does not exist.
     */
    fun deleteBrand(id: Long) {
        log.debug { "Attempting to delete brand for ID: $id" }
        val brand = findBrandByIdOrThrow(id)

        if (brand.isDefault) {
            throw createOperationNotAllowedException(
                reason = IS_DEFAULT_BRAND,
                entityId = brand.id!!,
                additionalDetails = mapOf("brandName" to brand.name)
            )
        }
        // TODO: Add check for product dependencies using ProductInfoPort when migrated
        log.warn { "Deleting brand: ${brand.name} (ID: ${brand.id})" }
        eventPublisher.publishEvent(BrandDeleteAttemptedEvent(brand.id!!))
        brandRepository.delete(brand)
        log.info { "Deleted brand: ${brand.name} (ID: ${brand.id})" }
    }

    /**
     * Handles the activation of a business by reacting to the BusinessActivatedEvent.
     * If no brands exist, a default brand is created and persisted in the repository.
     * The default brand is named after the business with a suffix "(Marca Propia)" and a unique code is generated for it.
     *
     * @param event The BusinessActivatedEvent containing information about the activated business such as business ID and name.
     */
    @ApplicationModuleListener
    fun onBusinessActivated(event: BusinessActivatedEvent) {
        log.debug { "Received BusinessActivatedEvent for: ${event.businessId}" }

        if (brandRepository.count() > 0) {
            log.info { "Brand already exists, skipping default brand creation." }
            return
        }

        val defaultBrand = brandFactory.createDefault(event.businessName)
        defaultBrand.name = "${event.businessName} (Marca Propia)"
        defaultBrand.updateCodeValue(codeGeneratorService.generateCode(defaultBrand.name))

        val saved = brandRepository.save(defaultBrand)
        log.info { "Created default brand: ${saved.name} (ID: ${saved.id})" }
    }

    // *******************************
    // 🔰 Private Helpers
    // *******************************

    private fun updateBrandFromRequest(brand: Brand, brandRequest: UpdateBrandRequest) {
        brandRequest.name.let { newName ->
            if (brand.name != newName && brandRepository.existsByName(newName)) {
                throw createDuplicatedResourceException("name", brandRequest.name)
            }
            brand.name = newName
            brand.updateCodeValue(codeGeneratorService.generateCode(newName))
            log.trace { "Updated brand ID ${brand.id} name to '$newName' and regenerated code" }
        }
    }

    private fun validateBrandRequest(brandRequest: CreateBrandRequest) {
        if (brandRepository.existsByName(brandRequest.name)) {
            throw createDuplicatedResourceException("name", brandRequest.name)
        }
    }

    private fun findBrandByIdOrThrow(id: Long): Brand {
        log.debug { "Fetching brand details for ID: $id" }
        val brand = brandRepository.findByIdOrNull(id)
            ?: throw createResourceNotFoundException("Brand", id)

        return brand
    }
}

================================================
File: dev/cnpe/ventescabekotlin/brands/domain/factory/BrandFactory.kt
================================================
package dev.cnpe.ventescabekotlin.brands.domain.factory

import dev.cnpe.ventescabekotlin.brands.domain.model.Brand
import dev.cnpe.ventescabekotlin.shared.application.service.CodeGeneratorService
import dev.cnpe.ventescabekotlin.shared.domain.vo.GeneratedCode
import org.apache.commons.lang3.StringUtils
import org.springframework.stereotype.Component

@Component
class BrandFactory(private val codeGeneratorService: CodeGeneratorService) {

    fun create(name: String): Brand {
        val (sanitizedName, generatedCode) = prepareNameAndCode(name)

        return Brand(
            name = sanitizedName,
            code = generatedCode
        )
    }

    fun createDefault(name: String): Brand {
        val (sanitizedName, generatedCode) = prepareNameAndCode(name)

        return Brand(
            name = sanitizedName,
            code = generatedCode,
            isDefault = true
        )
    }

    private fun prepareNameAndCode(name: String): Pair<String, GeneratedCode> {
        val sanitized = StringUtils.capitalize(name).trim()
        val codeValue = codeGeneratorService.generateCode(sanitized)
        val generatedCode = GeneratedCode(codeValue)

        return Pair(sanitized, generatedCode)
    }
}

================================================
File: dev/cnpe/ventescabekotlin/brands/domain/model/Brand.kt
================================================
package dev.cnpe.ventescabekotlin.brands.domain.model

import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import dev.cnpe.ventescabekotlin.shared.domain.vo.GeneratedCode
import jakarta.persistence.Column
import jakarta.persistence.Embedded
import jakarta.persistence.Entity
import jakarta.persistence.Table

@Entity
@Table(name = "brands")
class Brand(

    @Column(name = "name", nullable = false)
    var name: String,

    @Embedded
    var code: GeneratedCode,

    @Column(name = "is_default", nullable = false)
    var isDefault: Boolean = false,

    id: Long? = null,
    version: Int = 0

) : BaseEntity(id, version) {

    fun updateCodeValue(newCodeValue: String) {
        this.code = GeneratedCode(newCodeValue)
    }
}

================================================
File: dev/cnpe/ventescabekotlin/brands/infrastructure/BrandRepository.kt
================================================
package dev.cnpe.ventescabekotlin.brands.infrastructure

import dev.cnpe.ventescabekotlin.brands.domain.model.Brand
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query

interface BrandRepository : JpaRepository<Brand, Long> {

    fun existsByName(name: String): Boolean

    @Query(
        """
        select b.code.codeValue
        from Brand b
        where b.id = :brandId
        """
    )
    fun getBrandCodeById(brandId: Long): String?

    fun getBrandByIsDefaultTrue(): Brand?
}

================================================
File: dev/cnpe/ventescabekotlin/brands/infrastructure/web/BrandController.kt
================================================
package dev.cnpe.ventescabekotlin.brands.infrastructure.web

import dev.cnpe.ventescabekotlin.brands.application.dto.request.CreateBrandRequest
import dev.cnpe.ventescabekotlin.brands.application.dto.response.BrandSummaryResponse
import dev.cnpe.ventescabekotlin.brands.application.service.BrandService
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.net.URI

@RestController
@RequestMapping("/brands")
@Tag(name = "Brands", description = "Manage brands in the business.")
class BrandController(
    private val brandService: BrandService
) {

    @PostMapping
    @Operation(summary = "Register a new brand", description = "Creates a new brand in the business.")
    @ApiResponse(
        responseCode = "201",
        description = "Brand created successfully",
        content = [Content(
            mediaType = "application/json",
            schema = Schema(implementation = BrandSummaryResponse::class)
        )]
    )
    @ApiResponse(
        responseCode = "409",
        description = "Invalid input (e.g., duplicate name)"
    )
    fun registerBrand(@RequestBody @Valid brandRequest: CreateBrandRequest): ResponseEntity<BrandSummaryResponse> {
        val createdBrand = brandService.registerBrand(brandRequest)
        return ResponseEntity
            .created(URI.create("/brands/${createdBrand.id}"))
            .body(createdBrand)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/business/application/api/BusinessDataPort.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.api

import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.business.dto.BusinessPaymentData

/**
 * Port defining operations to retrieve essential business data,
 * often needed by other modules or infrastructure components like filters.
 */
interface BusinessDataPort {

    /**
     * Finds the tenant identifier associated with a given user id from the IDP
     * Returns null if the user is not found or not associated with a tenant.
     * Typically, queries the master database.
     */
    fun getTenantIdForUser(idpUserId: String): String?

    /**
     * Gets the current operational status of the business associated with the
     * current security/tenant context.
     * Requires tenant context to be set.
     */
    fun getCurrentBusinessStatus(): BusinessStatus

    /**
     * Gets the ID of the main branch for the business associated with the
     * current security/tenant context.
     * Requires tenant context to be set.
     */
    fun getBusinessMainBranchId(): Long

    /**
     * Gets payment-related data (currency, tax) for the business associated
     * with the current security/tenant context.
     * Requires tenant context to be set.
     */
    fun getBusinessPaymentData(): BusinessPaymentData

    /**
     * Gets the IDs of all branches for the business associated with the
     * current security/tenant context.
     * Requires tenant context to be set.
     */
    fun getBusinessBranchIds(): Set<Long>

}

================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/request/AdminCreateBusinessRequest.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.request

import dev.cnpe.ventescabekotlin.business.domain.enums.PaymentMethod
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.*
import java.math.BigDecimal


@Schema(description = "Data provided by a Superuser to register a new Business and its initial Admin user.")
data class AdminCreateBusinessRequest(

    // --- Details for NEW Business Admin User ---
    @field:NotBlank
    @field:Email
    @Schema(
        description = "Email address for the initial Business Admin user (must be unique in IdP).",
        example = "admin@newstore.com",
        required = true
    )
    val adminUserEmail: String,

    @Schema(description = "Optional initial password for the Business Admin user.", example = "TempPass123!")
    val adminUserInitialPassword: String? = null,

    @Schema(description = "First name for the Business Admin user.", example = "Store")
    val adminUserFirstName: String? = null,

    @Schema(description = "Last name for the Business Admin user.", example = "Owner")
    val adminUserLastName: String? = null,

    @Schema(
        description = "Optional username for the Business Admin user (if different from email).",
        example = "store_owner_admin"
    )
    val adminUserUsername: String? = null,

    // --- Business Details ---
    @field:NotBlank
    @field:Size(min = 2, max = 50)
    @Schema(description = "The official name of the new business.", example = "New Corner Store", required = true)
    val businessName: String,

    @field:Size(max = 500)
    @Schema(
        description = "Optional short brand message or slogan for the business.",
        example = "Your friendly neighborhood store"
    )
    val brandMessage: String?,

    // --- Business Configuration ---
    @field:NotBlank
    @field:Pattern(regexp = "^[A-Z]{3}$", message = "Must be a 3-letter uppercase ISO 4217 code")
    @Schema(description = "Default currency code (ISO 4217) for the business.", example = "USD", required = true)
    val currencyCode: String, // TODO: Validate against Currency table?

    @field:NotNull
    @field:DecimalMin(value = "0.0", inclusive = true)
    @field:DecimalMax(value = "100.0", inclusive = true)
    @field:Digits(integer = 3, fraction = 2)
    @Schema(description = "Default tax percentage (0-100).", example = "7.5", required = true)
    val taxPercentage: BigDecimal,

    @field:NotNull
    @field:Size(min = 1, message = "At least one payment method is required")
    @Schema(
        description = "Set of initially accepted payment methods.",
        example = "[\"CASH\", \"CREDIT_CARD\"]",
        required = true
    )
    val acceptedPaymentMethods: Set<PaymentMethod>, // Set of Enums

    // --- Business Contact Info ---
    @field:Size(min = 7, max = 25)
    @Schema(description = "Optional primary contact phone number for the business.", example = "+1-555-867-5309")
    val contactPhone: String?,

    @field:Email
    @Schema(
        description = "Optional primary contact email for the business (can differ from admin email).",
        example = "info@newcornerstore.com"
    )
    val contactEmail: String?,

    @field:org.hibernate.validator.constraints.URL // Use specific annotation if needed
    @Schema(description = "Optional official website URL for the business.", example = "https://newcornerstore.com")
    val contactWebsite: String?,

    // --- Initial Main Branch Details ---
    @Schema(description = "Optional name for the main branch (defaults if blank).", example = "Main Store Location")
    val mainBranchName: String? = null,

    @Schema(description = "Street address for the main branch.", example = "123 Market St")
    val mainBranchStreet: String?,

    @Schema(description = "City for the main branch.", example = "Metropolis")
    val mainBranchCity: String?,

    @Schema(description = "ZIP/Postal code for the main branch.", example = "12345")
    val mainBranchZipCode: String?,

    @Schema(description = "Country for the main branch.", example = "USA")
    val mainBranchCountry: String?
)

================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/request/CreateBusinessBranchRequest.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.request

//TODO: We need to add validation and Schemas to this dto
data class CreateBusinessBranchRequest(
    val managerId: String?,
    val branchName: String?,
    val addressStreet: String?,
    val addressCity: String?,
    val addressZipCode: String?,
    val addressCountry: String?,
    val contactNumber: String?
)

================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/request/CreateBusinessUserRequest.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.request

import dev.cnpe.ventescabekotlin.security.ports.dto.NewUserData
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.Valid

@Schema(description = "Request to create a new business user.")
data class CreateBusinessUserRequest(

    @Schema(description = "User data for the new user.")
    @field:Valid
    val userData: NewUserData,

    @Schema(description = "Roles to be assigned to the new user.")
    val roles: Set<String> = setOf("SELLER")

)


================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/request/UpdateBusinessBasicsRequest.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.request

//TODO: We need to add validation and Schemas to this dto
data class UpdateBusinessBasicsRequest(
    val businessName: String?,
    val brandMessage: String?
)



================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/request/UpdateBusinessConfigurationRequest.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.request

import dev.cnpe.ventescabekotlin.business.domain.enums.PaymentMethod
import java.math.BigDecimal

//TODO: We need to add validation and Schemas to this dto
data class UpdateBusinessConfigurationRequest(
    val currencyCode: String?,
    val taxPercentage: BigDecimal?,
    val acceptedPaymentMethods: Set<PaymentMethod>?
)

================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/request/UpdateBusinessContactInfoRequest.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.request

//TODO: We need to add validation and Schemas to this dto

data class UpdateBusinessContactInfoRequest(
    val phone: String?,
    val email: String?,
    val website: String?
)

================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/response/BusinessBranchInfo.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.response

import dev.cnpe.ventescabekotlin.shared.domain.vo.Address
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Information about a specific business branch.")
data class BusinessBranchInfo(
    @Schema(
        description = "Name of the branch.",
        example = "Downtown Office",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val branchName: String,

    @Schema(description = "Address of the branch.", requiredMode = Schema.RequiredMode.REQUIRED)
    val address: Address,

    @Schema(
        description = "Primary contact number for the branch.",
        example = "+1-555-123-4567",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val contactNumber: String?,

    @Schema(
        description = "Indicates if this is the main/headquarters branch.",
        example = "true",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isMainBranch: Boolean

    // TODO: Add manager info if needed
)

================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/response/BusinessDetailedResponse.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.response

import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessConfiguration
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessContactInfo
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessDetails
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessStatusInfo
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents detailed information about a business.")
data class BusinessDetailedResponse(

    @Schema(description = "Unique identifier for the business.")
    val id: Long,

    @Schema(description = "Core identifying details.")
    val details: BusinessDetails,

    @Schema(description = "Main contact information.")
    val contactInfo: BusinessContactInfo?,

    @Schema(description = "Business configuration settings.")
    val configuration: BusinessConfiguration?,

    @Schema(description = "Current operational status of the business.")
    val status: BusinessStatusInfo?,

    @Schema(description = "List of branches associated with the business.")
    val branches: Set<BusinessBranchInfo>
)


================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/response/BusinessStatusResponse.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.response

import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Response detailing the current setup/operational status of the business.")
data class BusinessStatusResponse(

    @Schema(
        description = "Current operational status.",
        example = "PENDING",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val status: BusinessStatus,

    @Schema(
        description = "Indicates if the core business entity needs to be created (e.g., first-time setup).",
        example = "false",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val needsCreation: Boolean,

    @Schema(
        description = "Indicates if the initial mandatory setup steps are complete.",
        example = "true",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isSetupComplete: Boolean
)


================================================
File: dev/cnpe/ventescabekotlin/business/application/dto/response/BusinessUserInfo.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "User information for a business.")
data class BusinessUserInfo(

    @Schema(description = "Unique identifier for the user.")
    val idpUserId: String,

    @Schema(description = "Email address for the user.")
    val email: String?,

    @Schema(description = "Display name for the user. Combination of names or username")
    val displayName: String?,

    @Schema(description = "Roles assigned to the user.")
    val roles: Set<String>
)


================================================
File: dev/cnpe/ventescabekotlin/business/application/exception/BusinessErrorCode.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.ErrorCode
import org.springframework.http.HttpStatus
import org.springframework.http.HttpStatus.CONFLICT

enum class BusinessErrorCode(override val status: HttpStatus) : ErrorCode {
    ACTIVATION_FAILED(CONFLICT),
    USER_ALREADY_LINKED(CONFLICT)
}

================================================
File: dev/cnpe/ventescabekotlin/business/application/exception/BusinessOperationNotAllowedReason.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.OperationNotAllowedReason
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Reasons why a business operation is not allowed.")
enum class BusinessOperationNotAllowedReason : OperationNotAllowedReason {

    @Schema(description = "User performing the action is not authorized to manage users for this business.")
    NOT_AUTHORIZED_TO_MANAGE_USERS,

    @Schema(description = "Cannot assign the requested roles (e.g., assigning ADMIN role).")
    CANNOT_ASSIGN_ROLES,

    @Schema(description = "Cannot add more users to the business, as the maximum number of users has been reached.")
    USER_LIMIT_REACHED
}

================================================
File: dev/cnpe/ventescabekotlin/business/application/mapper/BusinessMapper.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.mapper

import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessBranchInfo
import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessDetailedResponse
import dev.cnpe.ventescabekotlin.business.domain.model.Business
import dev.cnpe.ventescabekotlin.business.domain.model.BusinessBranch
import org.springframework.stereotype.Component

@Component
class BusinessMapper {

    /**
     * Maps a Business entity to its detailed DTO representation.
     */
    fun toDetailedDto(business: Business): BusinessDetailedResponse {
        val branchInfos = business.branches.map { branch ->
            mapBranchToInfoDto(branch)
        }.toSet()

        return BusinessDetailedResponse(
            id = business.id!!,
            details = business.details,
            contactInfo = business.contactInfo,
            configuration = business.configuration,
            status = business.statusInfo
                ?: throw IllegalStateException("Business ${business.id} has null statusInfo"), // Status should exist
            branches = branchInfos
        )
    }


    /**
     * Helper to map a BusinessBranch entity to a BusinessBranchInfo DTO.
     */
    fun mapBranchToInfoDto(branch: BusinessBranch): BusinessBranchInfo {
        return BusinessBranchInfo(
            branchName = branch.branchName,
            address = branch.address
                ?: TODO("Handle null address in branch mapping if possible"), // Handle null address
            contactNumber = branch.branchContactNumber,
            isMainBranch = branch.isMainBranch
            // Add manager info if needed in DTO
        )
    }

}

================================================
File: dev/cnpe/ventescabekotlin/business/application/service/AdminBusinessService.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.service

import dev.cnpe.ventescabekotlin.business.application.dto.request.AdminCreateBusinessRequest
import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessDetailedResponse
import dev.cnpe.ventescabekotlin.business.application.exception.BusinessErrorCode.ACTIVATION_FAILED
import dev.cnpe.ventescabekotlin.business.application.exception.BusinessErrorCode.USER_ALREADY_LINKED
import dev.cnpe.ventescabekotlin.business.application.mapper.BusinessMapper
import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.business.domain.model.Business
import dev.cnpe.ventescabekotlin.business.domain.model.BusinessBranch
import dev.cnpe.ventescabekotlin.business.domain.model.BusinessUser
import dev.cnpe.ventescabekotlin.business.event.BusinessActivatedEvent
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessRepository
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessUserRepository
import dev.cnpe.ventescabekotlin.currency.infrastructure.persistence.CurrencyRepository
import dev.cnpe.ventescabekotlin.security.ports.IdentityProviderPort
import dev.cnpe.ventescabekotlin.security.ports.dto.NewUserData
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.INVALID_DATA
import dev.cnpe.ventescabekotlin.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import dev.cnpe.ventescabekotlin.shared.domain.vo.Address
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.context.ApplicationEventPublisher
import org.springframework.context.MessageSource
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.data.repository.findByIdOrNull
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Propagation
import org.springframework.transaction.annotation.Transactional
import org.springframework.transaction.support.TransactionTemplate

private val log = KotlinLogging.logger {}

@Service
class AdminBusinessService(
    private val idpPort: IdentityProviderPort,
    private val businessFactory: BusinessFactory,
    private val businessRepository: BusinessRepository,
    private val businessUserRepository: BusinessUserRepository,
    private val businessMapper: BusinessMapper,

    @Qualifier("masterTransactionTemplate")
    private val masterTransactionTemplate: TransactionTemplate,
    private val eventPublisher: ApplicationEventPublisher,
    private val messageSource: MessageSource,
    private val currencyRepository: CurrencyRepository
) {

    companion object {
        private const val ROLE_BUSINESS_ADMIN = "BUSINESS_ADMIN"
    }

    /**
     * Registers a new business and its initial administrator user.
     * Orchestrated by a Superuser. Involves IdP interaction, tenant DB creation,
     * and master DB record creation.
     *
     * @param request DTO containing all necessary initial data.
     * @return Detailed DTO of the newly created and configured business.
     * @throws DomainException if validation fails (e.g., duplicate email/business name).
     * @throws IdpUserCreationException if user creation in IdP fails.
     * @throws TenantCreationException if tenant DB creation or migration fails.
     */
    @Transactional(propagation = Propagation.NEVER)
    fun registerNewBusinessAndAdmin(request: AdminCreateBusinessRequest): BusinessDetailedResponse {
        log.warn { "⚠️ Initiating NEW BUSINESS registration by Superuser for: ${request.businessName} (Admin Email: ${request.adminUserEmail})" }

        masterTransactionTemplate.execute {
            validateAdminCreateRequest(request)
        }

        val newAdminUserData = NewUserData(
            email = request.adminUserEmail,
            firstName = null,
            lastName = null,
            initialPassword = "changeme" // Autogenerated?
        )

        val idpAttributes = mapOf<String, String>()
        val idpUser = idpPort.createUser(newAdminUserData, setOf(ROLE_BUSINESS_ADMIN), idpAttributes)
        log.info { "IdP User created successfully: ${idpUser.email} (ID: ${idpUser.id})" }

        val (tenantId, businessShell) = businessFactory
            .createNewBusinessShell(idpUser.id, request.businessName)
        log.info { "Tenant infrastructure created: ${tenantId.value}" }

        val savedBusiness = masterTransactionTemplate.execute {
            businessShell.details = businessFactory.buildBusinessDetails(request)
            businessShell.contactInfo = businessFactory.buildBusinessContactInfo(request)
            businessShell.configuration = businessFactory.buildBusinessConfig(request)

            val mainBranchAddress = Address.buildAddress(
                street = request.mainBranchStreet,
                city = request.mainBranchCity,
                country = request.mainBranchCountry,
                zipCode = request.mainBranchZipCode
            ) ?: Address.empty()

            val branchName = request.mainBranchName.takeUnless { it.isNullOrBlank() }
                ?: messageSource.getMessage(
                    "default.branch.main.name",
                    null,
                    "Main Store",
                    LocaleContextHolder.getLocale()
                )

            val mainBranch = BusinessBranch(
                business = businessShell,
                branchName = branchName!!,
                address = mainBranchAddress,
                branchContactNumber = request.contactPhone,
                isMainBranch = true,
                branchManagerId = idpUser.id
            )

            businessShell.addBranch(mainBranch)
            val saved = businessRepository.save(businessShell)
            log.info { "Business entity saved to master DB. ID: ${saved.id}, Tenant: ${saved.tenantId.value}" }

            val displayName = "${idpUser.firstName ?: ""} ${idpUser.lastName ?: ""}".trim()
                .ifEmpty { idpUser.username ?: idpUser.email }
            val rolesSet = setOf(ROLE_BUSINESS_ADMIN)

            val businessUserLink = BusinessUser.createLink(
                idpUserId = idpUser.id,
                userEmail = request.adminUserEmail,
                displayName = displayName,
                roles = rolesSet,
            )
            businessUserLink.business = saved
            businessUserRepository.save(businessUserLink)
            log.info { "BusinessUser link saved for IdP User ${idpUser.id} to Business ${saved.id}" }
            saved
        } ?: throw IllegalStateException("Failed to save business entity within transaction.")

        log.info { "✅ Successfully registered business '${savedBusiness.details.businessName}' (ID: ${savedBusiness.id}, Tenant: ${savedBusiness.tenantId.value})" }

        return businessMapper.toDetailedDto(savedBusiness)
    }


    /**
     * Activates a business, changing its status to ACTIVE.
     * Typically performed by a Superuser after verifying setup completion.
     * Requires the Business entity to be in a PENDING state and meet all prerequisites.
     *
     * @param businessId The ID of the business to activate.
     * @return A detailed DTO of the activated business.
     * @throws DomainException if the business cannot be found or activation prerequisites are not met.
     */
    fun activateBusiness(businessId: Long): BusinessDetailedResponse {

        val activatedBusiness = masterTransactionTemplate.execute {
            val business = businessRepository.findByIdOrNull(businessId)
                ?: throw createResourceNotFoundException("Business", businessId)

            log.info { "Attempting to activate business: ${business.details.businessName} (ID: ${business.id})" }
            validateCanActivate(business)

            business.updateStatus(BusinessStatus.ACTIVE, "Activated by Superuser")
            val activated = businessRepository.save(business)

            eventPublisher.publishEvent(BusinessActivatedEvent(business.id!!, business.details.businessName))
            log.info { "✅ Business activated: ${business.details.businessName} (ID: ${business.id})" }
            activated
        } ?: throw IllegalStateException("Failed to activate business ID $businessId within transaction.")

        return businessMapper.toDetailedDto(activatedBusiness)
    }


    // needs to run within a master transaction
    private fun validateAdminCreateRequest(request: AdminCreateBusinessRequest) {
        log.debug { "Validating AdminCreateBusinessRequest..." }

        // Check 1: Does business name already exist?
        if (businessRepository.existsByDetails_BusinessName(request.businessName)) {
            throw createDuplicatedResourceException("businessName", request.businessName)
        }

        // Check 2: Does admin user email already exist in IdP?
        idpPort.findUserByEmail(request.adminUserEmail)?.let { existingUser ->
            log.warn { "Admin user email ${request.adminUserEmail} already exists in IdP (ID: ${existingUser.id}). Cannot create new business with this admin." }
            throw createDuplicatedResourceException("adminUserEmail", request.adminUserEmail)
        }

        // Check 3: Does admin user email already linked to another business?
        if (businessUserRepository.findByUserEmail(request.adminUserEmail) != null) {
            throw DomainException(
                USER_ALREADY_LINKED,
                mapOf("field" to "adminUserEmail", "value" to request.adminUserEmail),
            )
        }

        // Check 4: Currency Code Validation
        if (!currencyRepository.existsByCodeAndIsActiveTrue(request.currencyCode)) {
            throw DomainException(
                INVALID_DATA,
                mapOf("field" to "currencyCode", "value" to request.currencyCode)
            )
        }
        log.debug { "AdminCreateBusinessRequest validation passed." }
    }

    private fun validateCanActivate(business: Business) {
        val reasons = mutableListOf<String>()

        if (business.statusInfo?.status != BusinessStatus.PENDING) {
            reasons.add("Business is not in PENDING state (Current: ${business.statusInfo?.status})")
        }
        if (business.adminId.isBlank()) reasons.add("Administrator ID not defined")
        if (!business.hasValidDetails()) reasons.add("Business details are incomplete")
        if (!business.hasValidContactInfo()) reasons.add("Business contact info is incomplete")
        if (!business.hasValidConfiguration()) reasons.add("Business configuration is incomplete")
        if (!business.hasMainBranch()) reasons.add("Main branch has not been defined")

        if (reasons.isNotEmpty()) {
            throw DomainException(
                errorCode = ACTIVATION_FAILED,
                details = mapOf("businessId" to business.id!!, "reasons" to reasons),
            )
        }
        log.debug { "Business ${business.id} passed activation validation." }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/business/application/service/BusinessDataService.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.service

import dev.cnpe.ventescabekotlin.business.application.api.BusinessDataPort
import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.business.domain.model.BusinessUser
import dev.cnpe.ventescabekotlin.business.dto.BusinessPaymentData
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessUserRepository
import dev.cnpe.ventescabekotlin.currency.infrastructure.persistence.CurrencyRepository
import dev.cnpe.ventescabekotlin.security.context.UserContext
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.INSUFFICIENT_CONTEXT
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.RESOURCE_NOT_FOUND
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
// This service mostly reads data. Some reads query master, others query tenant.
// Be careful with transaction boundaries if mixing master/tenant calls significantly.
// Default transaction manager is the tenant one. Use "masterTransactionManager" explicitly if needed.
@Transactional(readOnly = true)
open class BusinessDataService(
    private val businessUserRepository: BusinessUserRepository,
    private val currencyRepository: CurrencyRepository,
    private val userContext: UserContext
) : BusinessDataPort {

    @Transactional(readOnly = true, transactionManager = "masterTransactionManager")
    override fun getTenantIdForUser(idpUserId: String): String? {
        log.debug { "Querying master DB for tenant ID for user IdP ID: $idpUserId" }
        return businessUserRepository.findTenantIdByIdpUserId(idpUserId)
    }

    override fun getCurrentBusinessStatus(): BusinessStatus {
        val businessUser = getCurrentBusinessUserOrThrow()
        return businessUser.business?.statusInfo?.status
            ?: throw IllegalStateException("Business or StatusInfo is null for user ${businessUser.userEmail}")
    }

    override fun getBusinessMainBranchId(): Long {
        val businessUser = getCurrentBusinessUserOrThrow()
        return businessUser.business?.getMainBranch()?.id
            ?: throw DomainException(
                RESOURCE_NOT_FOUND,
                mapOf("entityType" to "Main BusinessBranch", "idpUserId" to businessUser.idpUserId)
            )
    }

    override fun getBusinessPaymentData(): BusinessPaymentData {
        val businessUser = getCurrentBusinessUserOrThrow()
        val business = businessUser.business
            ?: throw IllegalStateException("Business is null for user ${businessUser.userEmail}")

        val config = business.configuration
            ?: throw DomainException(
                RESOURCE_NOT_FOUND,
                mapOf("entityType" to "BusinessConfiguration", "businessId" to business.id!!)
            )

        // This queries the MASTER database within a TENANT transaction context.
        // Should be OK for read-only if masterDataSource is accessible.
        log.debug { "Querying master DB for currency info within tenant context..." }
        val currency = currencyRepository.findByCodeAndIsActiveTrue(config.currencyCode)
            ?: throw DomainException(
                RESOURCE_NOT_FOUND,
                mapOf("entityType" to "Active Currency", "code" to config.currencyCode)
            )

        return BusinessPaymentData(
            currencyCode = config.currencyCode,
            taxPercentage = config.taxPercentage,
            currencyScale = currency.scale
        )
    }

    override fun getBusinessBranchIds(): Set<Long> {
        val businessUser = getCurrentBusinessUserOrThrow()
        return businessUser.business?.branches
            ?.mapNotNull { it.id }
            ?.toSet()
            ?: emptySet()
    }

    // *******************************
    // 🔰 Private Helpers
    // *******************************

    /**
     * Retrieves the BusinessUser associated with the current request's authenticated user.
     * Uses the injected UserContext bean. Requires master transaction manager.
     * Throws DomainException if user IdP Id is missing or user is not found in master DB.
     */
    @Transactional(readOnly = true, transactionManager = "masterTransactionManager")
    protected fun getCurrentBusinessUserOrThrow(): BusinessUser {
        // Get IdP ID (sub claim) from the request-scoped context bean
        val currentUserIdpId = userContext.userId
            ?: throw DomainException(
                errorCode = INSUFFICIENT_CONTEXT,
                details = mapOf("missingContext" to "User IdP ID"),
                message = "Required IdP User ID not found in security context."
            )

        log.debug { "Querying master DB for BusinessUser by IdP ID: $currentUserIdpId" }
        return businessUserRepository.findByIdpUserId(currentUserIdpId)
            ?: throw DomainException(
                RESOURCE_NOT_FOUND,
                mapOf("entityType" to "BusinessUser", "idpUserId" to currentUserIdpId)
            )
    }

}

================================================
File: dev/cnpe/ventescabekotlin/business/application/service/BusinessFactory.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.service

import dev.cnpe.ventescabekotlin.business.application.dto.request.AdminCreateBusinessRequest
import dev.cnpe.ventescabekotlin.business.application.dto.request.UpdateBusinessBasicsRequest
import dev.cnpe.ventescabekotlin.business.application.dto.request.UpdateBusinessConfigurationRequest
import dev.cnpe.ventescabekotlin.business.application.dto.request.UpdateBusinessContactInfoRequest
import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.business.domain.enums.PaymentMethod
import dev.cnpe.ventescabekotlin.business.domain.model.Business
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessConfiguration
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessContactInfo
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessDetails
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessStatusInfo
import dev.cnpe.ventescabekotlin.tenant.service.TenantManagementService
import dev.cnpe.ventescabekotlin.tenant.vo.TenantIdentifier
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Component
import java.math.BigDecimal
import java.time.OffsetDateTime

private val log = KotlinLogging.logger {}

/**
 * Helper component responsible for creating initial Business entities and related VOs/Branches.
 * Used by AdminBusinessService and BusinessManagementService.
 */
@Component
class BusinessFactory(
    private val tenantManagementService: TenantManagementService
) {
    /**
     * Creates the initial, unsaved Business entity shell when a new business is registered by an Admin.
     * This includes creating the tenant database and schema.
     * The calling service is responsible for populating details, config, user links, etc., and saving.
     *
     * @param adminUserId The IdP User ID ('sub') of the designated business administrator.
     * @param initialBusinessName The initial name for the business (used for tenant ID generation).
     * @return A Pair containing the newly created TenantIdentifier and the unsaved Business entity shell.
     * @throws TenantCreationException If tenant DB/schema creation fails.
     */
    fun createNewBusinessShell(adminUserId: String, initialBusinessName: String): Pair<TenantIdentifier, Business> {
        require(adminUserId.isNotBlank()) { "Admin User ID cannot be blank" }
        require(initialBusinessName.isNotBlank()) { "Initial Business Name cannot be blank" }

        log.info { "Initiating creation for business '$initialBusinessName' for admin '$adminUserId'" }

        val tenantId = tenantManagementService.createTenant(initialBusinessName)

        val initialStatusInfo = BusinessStatusInfo(
            status = BusinessStatus.PENDING,
            reason = "Initial business registration",
            changedAt = OffsetDateTime.now()
        )

        val businessShell = Business(
            adminId = adminUserId,
            tenantId = tenantId,
            details = BusinessDetails(businessName = initialBusinessName, logoUrl = null, brandMessage = null),
            contactInfo = null,
            configuration = null,
            statusInfo = initialStatusInfo
        )

        log.info { "Created business shell for ${tenantId.value}" }
        return Pair(tenantId, businessShell)
    }

    fun buildBusinessDetails(request: UpdateBusinessBasicsRequest, currentDetails: BusinessDetails): BusinessDetails {
        return currentDetails.copy(
            businessName = request.businessName ?: currentDetails.businessName,
            brandMessage = request.brandMessage ?: currentDetails.brandMessage,
            // TODO: logo url update on separate handler (file upload service call)
        )
    }

    fun buildBusinessDetails(request: AdminCreateBusinessRequest): BusinessDetails {
        return BusinessDetails(
            businessName = request.businessName,
            brandMessage = request.brandMessage,
            logoUrl = null //set later
        )
    }

    fun buildBusinessContactInfo(request: UpdateBusinessContactInfoRequest): BusinessContactInfo {
        return BusinessContactInfo(
            phone = request.phone ?: "",
            email = request.email,
            website = request.website
        )
    }

    fun buildBusinessContactInfo(request: AdminCreateBusinessRequest): BusinessContactInfo? {
        return if (!request.contactPhone.isNullOrBlank()) {
            BusinessContactInfo(
                phone = request.contactPhone,
                email = request.contactEmail,
                website = request.contactWebsite
            )
        } else null
    }

    fun buildBusinessConfig(request: UpdateBusinessConfigurationRequest): BusinessConfiguration {
        return BusinessConfiguration(
            currencyCode = request.currencyCode ?: "CLP",
            taxPercentage = request.taxPercentage ?: BigDecimal.ZERO,
            acceptedPaymentMethods = request.acceptedPaymentMethods ?: setOf(PaymentMethod.CASH)
        )
    }

    fun buildBusinessConfig(request: AdminCreateBusinessRequest): BusinessConfiguration {
        return BusinessConfiguration(
            currencyCode = request.currencyCode,
            taxPercentage = request.taxPercentage,
            acceptedPaymentMethods = request.acceptedPaymentMethods
        )
    }
}

================================================
File: dev/cnpe/ventescabekotlin/business/application/service/BusinessManagementService.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.service

import dev.cnpe.ventescabekotlin.business.application.dto.request.CreateBusinessBranchRequest
import dev.cnpe.ventescabekotlin.business.application.dto.request.UpdateBusinessBasicsRequest
import dev.cnpe.ventescabekotlin.business.application.dto.request.UpdateBusinessConfigurationRequest
import dev.cnpe.ventescabekotlin.business.application.dto.request.UpdateBusinessContactInfoRequest
import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessBranchInfo
import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessDetailedResponse
import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessStatusResponse
import dev.cnpe.ventescabekotlin.business.application.mapper.BusinessMapper
import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.business.domain.model.Business
import dev.cnpe.ventescabekotlin.business.domain.model.BusinessBranch
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessRepository
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessUserRepository
import dev.cnpe.ventescabekotlin.security.context.UserContext
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.INSUFFICIENT_CONTEXT
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.RESOURCE_NOT_FOUND
import dev.cnpe.ventescabekotlin.shared.domain.vo.Address
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.ApplicationEventPublisher
import org.springframework.context.MessageSource
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}


/**
 * Service responsible for operations performed by a Business Admin on their own business.
 * Requires TenantContext to be set correctly.
 */
@Service
@Transactional
open class BusinessManagementService(
    private val businessFactory: BusinessFactory,
    private val businessRepository: BusinessRepository,
    private val businessUserRepository: BusinessUserRepository,
    private val businessMapper: BusinessMapper,
    private val eventPublisher: ApplicationEventPublisher,
    private val userContext: UserContext,
    private val messageSource: MessageSource
) {

    /**
     * Retrieves detailed data for the business associated with the currently logged-in user.
     */
    @Transactional(readOnly = true)
    fun getCurrentUserBusinessData(): BusinessDetailedResponse {
        val business = getCurrentUserBusinessOrThrow()
        return businessMapper.toDetailedDto(business)
    }




    /**
     * Updates the basic details (name, brand message) of the current user's business.
     */
    fun updateBasics(request: UpdateBusinessBasicsRequest) {
        val business = getCurrentUserBusinessOrThrow()
        log.debug { "Updating basics for business ID: ${business.id}" }

        val updatedDetails = businessFactory.buildBusinessDetails(request, business.details)
        if (updatedDetails != business.details) {
            business.details = updatedDetails
            businessRepository.save(business)
            log.info { "Updated business basics for ID: ${business.id}" }
        } else {
            log.info { "No changes detected in business basics for ID: ${business.id}" }
        }
    }

    /**
     * Updates the contact information of the current user's business.
     */
    fun updateContactInfo(request: UpdateBusinessContactInfoRequest) {
        val business = getCurrentUserBusinessOrThrow()
        log.debug { "Updating contact info for business ID: ${business.id}" }

        val newContactInfo = businessFactory.buildBusinessContactInfo(request)
        business.contactInfo = newContactInfo
        businessRepository.save(business)
        log.info { "Updated business contact info for ID: ${business.id}" }
    }

    /**
     * Updates the configuration (currency, tax, payment methods) of the current user's business.
     */
    fun updateBusinessConfiguration(request: UpdateBusinessConfigurationRequest) {
        val business = getCurrentUserBusinessOrThrow()
        log.debug { "Updating configuration for business ID: ${business.id}" }

        val newConfig = businessFactory.buildBusinessConfig(request)
        business.configuration = newConfig
        // TODO: Add validation? E.g., ensure currency code exists in Currency table?
        businessRepository.save(business)
        log.info { "Updated business configuration for ID: ${business.id}" }
    }

    /**
     * Creates a new (non-main) branch for the current user's business.
     *
     * @param request DTO containing details for the new branch.
     * @return DTO representation of the newly created branch.
     * @throws DomainException if required input is missing or invalid.
     */
    fun registerBranch(request: CreateBusinessBranchRequest): BusinessBranchInfo {
        val business = getCurrentUserBusinessOrThrow()

        val managerId = request.managerId ?: userContext.userId ?: throw DomainException(
            INSUFFICIENT_CONTEXT,
            message = "User ID not available for branch manager"
        )
        log.info { "Registering new branch for business ID ${business.id} with data: $request" }

        val newBranchAddress = Address.buildAddress(
            street = request.addressStreet,
            city = request.addressCity,
            country = request.addressCountry,
            zipCode = request.addressZipCode
        ) ?: Address.empty()

        val newBranch = BusinessBranch(
            business = business,
            branchName = request.branchName ?: "PLACEHOLDER", //TODO use messageSource
            address = newBranchAddress,
            isMainBranch = false,
            branchManagerId = managerId,
            branchContactNumber = request.contactNumber
        )

        newBranch.business = business
        business.addBranch(newBranch)

        businessRepository.save(business)
        log.info { "Successfully registered new branch '${newBranch.branchName}' (ID: ${newBranch.id}) for business ID ${business.id}" }
        val savedBranch = business.branches.find { it === newBranch }
            ?: throw IllegalStateException("Saved branch not found in collection immediately after save")

        return businessMapper.mapBranchToInfoDto(savedBranch)
    }

    /**
     * Designates an existing branch as the main branch for the business.
     * The previously main branch (if any) will be unset.
     *
     * @param branchId The ID of the branch to set as the new main branch.
     * @throws DomainException if the branch is not found, already main, or doesn't belong to the business.
     */
    fun setMainBranch(branchId: Long) {
        val business = getCurrentUserBusinessOrThrow()
        log.info { "Attempting to set branch ID $branchId as main branch for business ID ${business.id}" }

        val currentMainBranch = business.getMainBranch()
        val targetBranch = business.branches.find { it.id == branchId } ?: throw DomainException(
            RESOURCE_NOT_FOUND,
            mapOf("entityType" to "Target Branch", "branchId" to branchId)
        )

        if (targetBranch === currentMainBranch) {
            log.warn { "Branch ID $branchId is already the main branch for business ID ${business.id}. No change needed." }
            return
        }
        // extra check (maybe not needed)
        require(targetBranch.business == business) { "Branch $branchId does not belong to business ${business.id}" }

        log.info { "Changing main branch for business ${business.id} from ${currentMainBranch?.id ?: "None"} to $branchId" }
        currentMainBranch?.isMainBranch = false
        targetBranch.isMainBranch = true

        businessRepository.save(business)
        log.info { "Successfully set branch ID $branchId as main branch for business ID ${business.id}" }
    }


    /**
     * Gets the status overview for the business associated with the current user.
     * Queries the MASTER database to check existence before potentially querying tenant.
     */
    @Transactional(readOnly = true, transactionManager = "masterTransactionManager") // Query master first
    fun getCurrentBusinessStatus(): BusinessStatusResponse {
        val currentUserIdpId = userContext.userId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "User ID not available")

        val status = businessUserRepository.findBusinessStatusByIdpUserId(currentUserIdpId)

        return if (status != null) {
            val isSetupComplete = status != BusinessStatus.PENDING
            BusinessStatusResponse(status, false, isSetupComplete)
        } else {
            BusinessStatusResponse(BusinessStatus.NON_CREATED, needsCreation = true, isSetupComplete = false)
        }
    }


    // *******************************
    // 🔰 Private Helpers
    // *******************************

    /**
     * Retrieves the Business entity associated with the current logged-in user.
     * Uses UserContext and queries across tenant/master boundaries implicitly via repositories.
     * Throws if the user context or business link is missing.
     */
    @Transactional(readOnly = true)
    protected fun getCurrentUserBusinessOrThrow(): Business {
        val currentUserIdpId = userContext.userId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "User ID not available")

        val businessUser = businessUserRepository.findByIdpUserId(currentUserIdpId)
            ?: throw DomainException(
                RESOURCE_NOT_FOUND,
                mapOf("entityType" to "BusinessUserLink", "idpUserId" to currentUserIdpId)
            )

        return businessUser.business
            ?: throw DomainException(
                RESOURCE_NOT_FOUND,
                mapOf("entityType" to "Business", "userIdpId" to currentUserIdpId)
            )
    }
}

================================================
File: dev/cnpe/ventescabekotlin/business/application/service/UserManagementService.kt
================================================
package dev.cnpe.ventescabekotlin.business.application.service

import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessUserInfo
import dev.cnpe.ventescabekotlin.business.application.exception.BusinessOperationNotAllowedReason.*
import dev.cnpe.ventescabekotlin.business.config.BusinessLimitProperties
import dev.cnpe.ventescabekotlin.business.domain.model.BusinessUser
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessRepository
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessUserRepository
import dev.cnpe.ventescabekotlin.security.context.UserContext
import dev.cnpe.ventescabekotlin.security.ports.IdentityProviderPort
import dev.cnpe.ventescabekotlin.security.ports.dto.NewUserData
import dev.cnpe.ventescabekotlin.security.ports.dto.UserIdentity
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.INSUFFICIENT_CONTEXT
import dev.cnpe.ventescabekotlin.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescabekotlin.shared.application.exception.createOperationNotAllowedException
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Propagation
import org.springframework.transaction.annotation.Transactional
import org.springframework.transaction.support.TransactionTemplate

private val log = KotlinLogging.logger {}

@Service
open class UserManagementService(
    private val idpPort: IdentityProviderPort,
    private val userContext: UserContext,
    private val businessUserRepository: BusinessUserRepository,
    private val businessRepository: BusinessRepository,
    @Qualifier("masterTransactionTemplate") private val masterTransactionTemplate: TransactionTemplate,
    private val businessLimitProperties: BusinessLimitProperties
) {
    companion object {
        // roles that can be assigned by a Business Admin
        private val ALLOWED_ROLES_TO_ASSIGN = setOf("SELLER", "BRANCH_MANAGER")
        private const val TENANT_ID_ATTRIBUTE = "tenant_id"
        private const val ROLE_SELLER = "SELLER"
        private const val ROLE_BRANCH_MANAGER = "BRANCH_MANAGER"
    }

    /**
     * Creates a new user (Seller or Branch Manager) within the current Business Admin's tenant.
     */
    @Transactional(propagation = Propagation.NEVER)
    fun createBusinessUser(request: NewUserData, rolesToAssign: Set<String>): UserIdentity {
        val adminUserId = userContext.userId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin User ID missing")
        val adminTenantId = userContext.tenantId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin Tenant ID missing")

        log.info { "Business Admin [$adminUserId] attempting to create user [${request.email}] in tenant [$adminTenantId] with roles $rolesToAssign" }

        validateUserCreationRequest(request, rolesToAssign)

        val idpAttributes = mapOf(TENANT_ID_ATTRIBUTE to adminTenantId)
        val newUserIdp = idpPort.createUser(request, rolesToAssign, idpAttributes)
        log.info { "IdP user ${newUserIdp.email} created with ID ${newUserIdp.id} for tenant $adminTenantId" }

        masterTransactionTemplate.execute {

            val business = businessRepository.findByTenantIdValue(adminTenantId)
                ?: throw IllegalStateException("Cannot link user ${newUserIdp.id} - Business not found in master DB for tenant $adminTenantId")

            val displayName = "${newUserIdp.firstName ?: ""} ${newUserIdp.lastName ?: ""}"
                .trim().ifEmpty { newUserIdp.username ?: newUserIdp.email }

            val businessUserLink = BusinessUser.createLink(
                idpUserId = newUserIdp.id,
                userEmail = request.email,
                displayName = displayName,
                roles = rolesToAssign
            )
            businessUserLink.business = business
            businessUserRepository.save(businessUserLink)
            log.info { "BusinessUser link saved for IdP User ${newUserIdp.id} to Tenant $adminTenantId" }
        } ?: throw IllegalStateException("Failed to save business user link within transaction.")

        return newUserIdp
    }

    /**
     * Assigns/updates roles for a specific user within the admin's tenant.
     * Ensures admin can only assign allowed roles and only to users in their tenant.
     */
    @Transactional(propagation = Propagation.NEVER)
    fun assignBusinessUserRoles(targetUserIdpId: String, rolesToAssign: Set<String>) {
        val adminUserId = userContext.userId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin User ID missing")
        val adminTenantId = userContext.tenantId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin Tenant ID missing")

        log.info { "Admin [$adminUserId] attempting to assign roles $rolesToAssign to user [$targetUserIdpId] in tenant [$adminTenantId]" }

        val invalidRoles = rolesToAssign - ALLOWED_ROLES_TO_ASSIGN
        if (invalidRoles.isNotEmpty()) {
            throw createOperationNotAllowedException(
                CANNOT_ASSIGN_ROLES,
                additionalDetails = mapOf("requestedRoles" to rolesToAssign, "invalidRoles" to invalidRoles)
            )
        }

        verifyUserTenantAffiliation(targetUserIdpId, adminTenantId)

        // FIXME: idpPort.assignRolesToUser currently ADDS roles. If we need to REPLACE,
        // the adapter implementation needs to fetch existing roles, remove them, then add new ones.
        idpPort.assignRolesToUser(targetUserIdpId, rolesToAssign)
        log.info { "Successfully assigned roles $rolesToAssign to user [$targetUserIdpId] by admin [$adminUserId]" }
    }

    /**
     * Deletes a user associated with the admin's tenant from both the IdP
     * and the local BusinessUser link table.
     */
    @Transactional(propagation = Propagation.NEVER)
    fun deleteBusinessUser(targetUserIdpId: String) {
        val adminUserId = userContext.userId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin User ID missing")
        val adminTenantId = userContext.tenantId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin Tenant ID missing")

        log.warn { "Admin [$adminUserId] attempting to DELETE user [$targetUserIdpId] in tenant [$adminTenantId]" }

        verifyUserTenantAffiliation(targetUserIdpId, adminTenantId)

        idpPort.deleteUser(targetUserIdpId)
        log.info { "Successfully deleted user [$targetUserIdpId] from IdP by admin [$adminUserId]" }

        masterTransactionTemplate.execute {
            val deletedCount = businessUserRepository.deleteByIdpUserId(targetUserIdpId)
            if (deletedCount > 0) {
                log.info { "Successfully deleted BusinessUser link for IdP User [$targetUserIdpId] from master DB." }
            } else {
                // inconsistency
                log.warn { "Could not find BusinessUser link for IdP User [$targetUserIdpId] to delete, though user existed in IdP." }
            }
        }
        log.info { "Successfully completed deletion process for user [$targetUserIdpId] initiated by admin [$adminUserId]" }
    }

    /**
     * Lists users associated with the current Business Admin's tenant.
     * Fetches user links from master DB and potentially basic info from IdP.
     */
    @Transactional(readOnly = true, transactionManager = "masterTransactionManager")
    fun listBusinessUsers(): List<BusinessUserInfo> {
        val adminTenantId =
            userContext.tenantId ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin Tenant ID missing")

        log.debug { "Listing users for tenant [$adminTenantId]" }

        val business = businessRepository.findByTenantIdValue(adminTenantId)
            ?: throw DomainException(
                GeneralErrorCode.RESOURCE_NOT_FOUND,
                mapOf("entityType" to "Business", "tenantId" to adminTenantId)
            )

        val userLinks = businessUserRepository.findAllByBusinessId(business.id!!)

        // Consider if the BusinessUser table should store name/email snapshot.
        return userLinks.map { userLink ->
            BusinessUserInfo(
                idpUserId = userLink.idpUserId,
                email = userLink.userEmail,
                displayName = userLink.displayName ?: userLink.userEmail ?: userLink.idpUserId,
                roles = userLink.roles //placeholder
            )
        }
    }

    // *******************************
    // 🔰 Private Helpers
    // *******************************

    private fun verifyUserTenantAffiliation(targetUserIdpId: String, expectedTenantId: String) {

    }

    private fun validateUserCreationRequest(request: NewUserData, rolesToAssign: Set<String>) {

        val adminTenantId = userContext.tenantId
            ?: throw DomainException(INSUFFICIENT_CONTEXT, message = "Admin Tenant ID missing")

        if (!userContext.roles.contains("BUSINESS_ADMIN")) {
            throw createOperationNotAllowedException(NOT_AUTHORIZED_TO_MANAGE_USERS)
        }

        // 2. Check if email already exists in IdP
        idpPort.findUserByEmail(request.email)?.let {
            throw createDuplicatedResourceException("email", request.email)
        }

        // 3. Check if roles being assigned are valid for a Business Admin to assign
        val invalidRoles = rolesToAssign - ALLOWED_ROLES_TO_ASSIGN
        if (invalidRoles.isNotEmpty()) {
            throw createOperationNotAllowedException(CANNOT_ASSIGN_ROLES)
        }

        // 4. Limit checks
        val business = businessRepository.findByTenantIdValue(adminTenantId)
            ?: throw DomainException(
                errorCode = INSUFFICIENT_CONTEXT,
                message = "Could not find business details for admin's tenant $adminTenantId during validation"
            )

        val businessId = business.id!!

        val currentTotalUserCount = businessUserRepository.countByBusinessId(businessId)
        val potentialTotalUsers = currentTotalUserCount + 1

        if (potentialTotalUsers > businessLimitProperties.maxUsersPerBusiness) {
            throw createOperationNotAllowedException(
                reason = USER_LIMIT_REACHED,
                additionalDetails = mapOf("maxAllowed" to businessLimitProperties.maxUsersPerBusiness)
            )
        }


        log.debug { "User creation request validated successfully." }
    }

    // TODO: Implement method for update user (initiated by Business Admin)
    // These method MUST include checks to ensure the admin is operating only on users
    // belonging to their OWN tenant (by checking the tenant_id attribute via idpPort.getUserAttributes).
    // see: delete/list
}

================================================
File: dev/cnpe/ventescabekotlin/business/config/BusinessLimitProperties.kt
================================================
package dev.cnpe.ventescabekotlin.business.config

import jakarta.validation.constraints.PositiveOrZero
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.validation.annotation.Validated

@ConfigurationProperties(prefix = "app.business.limits")
@Validated
data class BusinessLimitProperties(

    @field:PositiveOrZero
    val maxUsersPerBusiness: Int = 10,

    @field:PositiveOrZero
    val maxBranchesPerBusiness: Int = 5
)

================================================
File: dev/cnpe/ventescabekotlin/business/domain/enums/BusinessStatus.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.enums

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum

/**
 * Represents the operational status of a business.
 * User-facing names and descriptions are resolved via MessageSource
 * using keys like "enum.BusinessStatus.ACTIVE.name" and "enum.BusinessStatus.ACTIVE.description".
 */
enum class BusinessStatus: DomainEnum {

    NON_CREATED,
    PENDING,
    ACTIVE,
    INACTIVE,
    SUSPENDED,
    TERMINATED;

}

================================================
File: dev/cnpe/ventescabekotlin/business/domain/enums/PaymentMethod.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.enums

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum

/**
 * Represents the method through which a payment can be processed.
 * User-facing names and descriptions can be obtained via MessageSource
 * using keys formatted as "enum.PaymentMethod.<METHOD_NAME>.name" and "enum.PaymentMethod.<METHOD_NAME>.description".
 */
enum class PaymentMethod : DomainEnum {
    CASH,
    CREDIT_CARD,
    DEBIT_CARD,
    MOBILE_PAYMENT,
    GIFT_CARD,
    BANK_TRANSFER,
    CHECK,
    STORE_CREDIT,
    SPLIT_PAYMENT;
}

================================================
File: dev/cnpe/ventescabekotlin/business/domain/model/Business.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.model

import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessConfiguration
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessContactInfo
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessDetails
import dev.cnpe.ventescabekotlin.business.domain.vo.BusinessStatusInfo
import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import dev.cnpe.ventescabekotlin.tenant.vo.TenantIdentifier
import jakarta.persistence.*
import java.time.OffsetDateTime

@Entity
@Table(name = "businesses")
class Business(

    @Column(name = "admin_id", nullable = false, updatable = false)
    val adminId: String,

    @Embedded
    var tenantId: TenantIdentifier,

    @Embedded
    var details: BusinessDetails,

    @Embedded
    var contactInfo: BusinessContactInfo? = null,

    @Embedded
    var configuration: BusinessConfiguration? = null,

    @Embedded
    var statusInfo: BusinessStatusInfo? = null,

    @OneToMany(mappedBy = "business", fetch = FetchType.LAZY, cascade = [CascadeType.ALL], orphanRemoval = true)
    val branches: MutableSet<BusinessBranch> = mutableSetOf(),

    @OneToMany(mappedBy = "business", fetch = FetchType.LAZY, cascade = [CascadeType.ALL], orphanRemoval = true)
    val users: MutableSet<BusinessUser> = mutableSetOf(),

    id: Long? = null,
    version: Int = 0
) : BaseEntity(id, version) {


    /**
     * Updates the business's status information with the provided status and reason.
     *
     * @param status The new operational status of the business.
     * @param reason An optional reason explaining the context or cause of the status change.
     */
    fun updateStatus(status: BusinessStatus, reason: String? = null) {

        this.statusInfo = BusinessStatusInfo(
            status = status,
            reason = reason,
            changedAt = OffsetDateTime.now()
        )
    }

    // *******************************
    // 🔰 Validation Helpers
    // *******************************

    fun hasValidDetails(): Boolean {
        return details.businessName.isNotBlank()
    }

    fun hasValidContactInfo(): Boolean {
        return contactInfo?.phone?.isNotBlank() ?: false
    }

    fun hasValidConfiguration(): Boolean {
        return configuration?.isValid ?: false
    }

    fun hasMainBranch(): Boolean {
        return branches.any { it.isMainBranch }
    }

    fun getMainBranch(): BusinessBranch? {
        return branches.firstOrNull { it.isMainBranch }
    }

    // *******************************
    // 🔰 Relationship Management
    // *******************************

    fun addBranch(branch: BusinessBranch) {
        branch.business = this
        this.branches.add(branch)
    }

    fun addUser(bUser: BusinessUser) {
        bUser.business = this
        this.users.add(bUser)
    }
}

================================================
File: dev/cnpe/ventescabekotlin/business/domain/model/BusinessBranch.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.model

import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import dev.cnpe.ventescabekotlin.shared.domain.vo.Address
import jakarta.persistence.*

@Entity
@Table(name = "business_branches")
class BusinessBranch(

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "business_id", nullable = false)
    var business: Business,

    @Column(name = "branch_name", nullable = false)
    var branchName: String,

    @Embedded
    var address: Address,

    @Column(name = "contact_number")
    var branchContactNumber: String?,

    @Column(name = "is_main_branch", nullable = false)
    var isMainBranch: Boolean = false,

    @Column(name = "branch_manager_id")
    var branchManagerId: String?,

    id: Long? = null,
    version: Int = 0
) : BaseEntity(id, version)

================================================
File: dev/cnpe/ventescabekotlin/business/domain/model/BusinessUser.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.model

import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import jakarta.persistence.*

@Entity
@Table(
    name = "business_users",
    indexes = [
        Index(name = "idx_business_user_idp_id", columnList = "idp_user_id", unique = true)
    ]
)
class BusinessUser(

    @Column(name = "idp_user_id", nullable = false, updatable = false, unique = true)
    val idpUserId: String,

    @Column(name = "user_email", nullable = true)
    var userEmail: String?,

    @Column(name = "display_name", nullable = true)
    var displayName: String?,

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "business_user_assigned_roles", joinColumns = [JoinColumn(name = "business_user_id")])
    @Column(name = "role_name", nullable = false)
    var roles: MutableSet<String> = mutableSetOf(),

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "business_id")
    var business: Business?,

    id: Long? = null,
    version: Int = 0
) : BaseEntity(id, version) {

    companion object {

        /**
         * Factory method to create a BusinessUser link instance.
         * Requires the immutable ID from the Identity Provider.
         *
         * @param idpUserId The unique user ID from the IdP ('sub' claim).
         * @param userEmail The user's email (optional, for informational purposes).
         */
        fun createLink(
            idpUserId: String,
            userEmail: String?,
            displayName: String?,
            roles: Set<String>
        ): BusinessUser {
            require(idpUserId.isNotBlank()) { "IdP User ID cannot be blank" }
            return BusinessUser(
                idpUserId = idpUserId,
                userEmail = userEmail,
                displayName = displayName,
                roles = roles.toMutableSet(),
                business = null,
            )
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/business/domain/vo/BusinessConfiguration.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.vo


import com.fasterxml.jackson.annotation.JsonIgnore
import dev.cnpe.ventescabekotlin.business.domain.enums.PaymentMethod
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.*
import jakarta.validation.constraints.*
import java.math.BigDecimal
import kotlin.collections.isNotEmpty

@Schema(description = "Configuration settings for the business.")
@Embeddable
data class BusinessConfiguration(
    @Schema(
        description = "Default currency code (ISO 4217).",
        example = "USD",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    @Column(name = "currency_code")
    @field:NotBlank
    @field:Pattern(regexp = "^[A-Z]{3}$", message = "Currency code must be a valid 3-letter ISO 4217 code")
    val currencyCode: String,

    @Schema(
        description = "Default tax percentage applied.",
        example = "8.25",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    @Column(name = "tax_percentage")
    @field:NotNull
    @field:DecimalMin(value = "0.0", inclusive = true)
    @field:Digits(integer = 3, fraction = 2)
    val taxPercentage: BigDecimal,

    @Schema(description = "Set of accepted payment methods.", requiredMode = Schema.RequiredMode.REQUIRED)
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
        name = "business_payment_methods",
        joinColumns = [JoinColumn(name = "business_id")]
    )
    @Column(name = "payment_method", nullable = false)
    @Enumerated(EnumType.STRING)
    @field:NotNull
    @field:Size(min = 1, message = "At least one payment method must be selected")
    val acceptedPaymentMethods: Set<PaymentMethod> = emptySet()
) {
    @get:JsonIgnore
    val isValid: Boolean
        get() = currencyCode.isNotBlank() &&
                taxPercentage >= BigDecimal.ZERO &&
                acceptedPaymentMethods.isNotEmpty()
}


================================================
File: dev/cnpe/ventescabekotlin/business/domain/vo/BusinessContactInfo.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.vo

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.Size
import org.hibernate.validator.constraints.URL

@Schema(description = "Contact information for the business.")
@Embeddable
data class BusinessContactInfo(

    @Schema(
        description = "Primary contact phone number.",
        example = "+1-800-555-0100",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    @field:Size(min = 7, max = 25)
    @Column(name = "phone")
    val phone: String,

    @Schema(
        description = "Primary contact email address.",
        example = "info@business.com",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @Email
    @Column(name = "email")
    val email: String?,

    @Schema(
        description = "Official business website URL.",
        example = "https://www.business.com",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:URL
    @field:Size(max = 255)
    @Column(name = "website")
    val website: String?
)


================================================
File: dev/cnpe/ventescabekotlin/business/domain/vo/BusinessDetails.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.vo

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size
import org.hibernate.validator.constraints.URL

@Schema(description = "Core identifying details of the business")
@Embeddable
data class BusinessDetails(

    @Schema(
        description = "Official name of the business.",
        example = "My Awesome Corp",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    @field:NotBlank
    @field:Size(min = 2, max = 50)
    @field:Pattern(regexp = "^[\\p{L}\\p{N}\\s&'.-]+$", message = "Business name contains invalid characters")
    @Column(name = "business_name", nullable = false)
    val businessName: String,

    @Schema(
        description = "URL of the business logo.",
        example = "https://cdn.business.com/logo.png",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:URL
    @field:Size(max = 255)
    @Column(name = "logo_url")
    val logoUrl: String?,

    @Schema(
        description = "A short brand message or slogan.",
        example = "Quality products since 2023",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:Size(max = 500)
    @Column(name = "brand_message", length = 500)
    val brandMessage: String?
)


================================================
File: dev/cnpe/ventescabekotlin/business/domain/vo/BusinessStatusInfo.kt
================================================
package dev.cnpe.ventescabekotlin.business.domain.vo

import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size
import java.time.OffsetDateTime

@Schema(description = "Information about the business's current status.")
@Embeddable
data class BusinessStatusInfo(

    @Schema(
        description = "Current operational status of the business.",
        example = "ACTIVE",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @field:NotNull
    val status: BusinessStatus,

    @Schema(
        description = "Reason for the current status (if applicable).",
        example = "Initial setup complete",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @Column(name = "status_reason")
    @field:Size(max = 255)
    val reason: String?,

    @Schema(description = "Timestamp when the status last changed.", requiredMode = Schema.RequiredMode.REQUIRED)
    @Column(name = "status_changed_at", nullable = false)
    @field:NotNull
    val changedAt: OffsetDateTime
)


================================================
File: dev/cnpe/ventescabekotlin/business/dto/BusinessPaymentData.kt
================================================
package dev.cnpe.ventescabekotlin.business.dto

import java.math.BigDecimal

/**
 * DTO carrying essential payment-related configuration for a business.
 */
data class BusinessPaymentData(
    val currencyCode: String,
    val taxPercentage: BigDecimal,
    val currencyScale: Int
)


================================================
File: dev/cnpe/ventescabekotlin/business/event/BusinessActivatedEvent.kt
================================================
package dev.cnpe.ventescabekotlin.business.event

data class BusinessActivatedEvent(
    val businessId: Long,
    val businessName: String
)

================================================
File: dev/cnpe/ventescabekotlin/business/infrastructure/persistence/BusinessRepository.kt
================================================
package dev.cnpe.ventescabekotlin.business.infrastructure.persistence

import dev.cnpe.ventescabekotlin.business.domain.model.Business
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query

interface BusinessRepository : JpaRepository<Business, Long> {

    fun existsByAdminId(adminId: String): Boolean

    @Query(
        """
        select b
        from BusinessUser bu
        join bu.business b
        where bu.userEmail = :userEmail
        """
    )
    fun findBusinessByUserEmail(userEmail: String): Business?

    @Query(
        """
        select distinct b.tenantId.value
        from Business b 
        where b.tenantId.value is not null
        """
    )
    fun findAllDistinctTenantIds(): Set<String>


    fun existsByDetails_BusinessName(businessName: String): Boolean

    fun findByTenantIdValue(tenantId: String): Business?

    @Query(
        """
        select count(b)
        from BusinessBranch b
        where b.business.id = :businessId
        """
    )
    fun countBranchesById(businessId: Long): Long
}

================================================
File: dev/cnpe/ventescabekotlin/business/infrastructure/persistence/BusinessUserRepository.kt
================================================
package dev.cnpe.ventescabekotlin.business.infrastructure.persistence

import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.business.domain.model.BusinessUser
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query

interface BusinessUserRepository : JpaRepository<BusinessUser, Long> {

    @Query(
        """
        select b.tenantId.value 
        from BusinessUser bu 
        join bu.business b 
        where bu.idpUserId = :idpUserId 
        """
    )
    fun findTenantIdByIdpUserId(idpUserId: String): String?

    fun findByIdpUserId(idpUserId: String): BusinessUser?

    fun findByUserEmail(userEmail: String): BusinessUser?


    @Query(
        """
        select b.statusInfo.status
        from BusinessUser bu
        join bu.business b
        where bu.idpUserId = :idpUserId
        """
    )
    fun findBusinessStatusByIdpUserId(idpUserId: String): BusinessStatus?

    @Query(
        """
        select bu.idpUserId
        from BusinessUser bu
        where bu.business.id = :businessId
        """
    )
    fun findAllIdpUserIdsByBusinessId(businessId: Long): List<String>

    fun countByBusinessId(businessId: Long): Long

    fun deleteByIdpUserId(idpUserId: String): Long

    fun findAllByBusinessId(businessId: Long): List<BusinessUser>

}

================================================
File: dev/cnpe/ventescabekotlin/business/infrastructure/web/AdminBusinessController.kt
================================================
package dev.cnpe.ventescabekotlin.business.infrastructure.web

import dev.cnpe.ventescabekotlin.business.application.dto.request.AdminCreateBusinessRequest
import dev.cnpe.ventescabekotlin.business.application.dto.response.BusinessDetailedResponse
import dev.cnpe.ventescabekotlin.business.application.service.AdminBusinessService
import dev.cnpe.ventescabekotlin.shared.application.dto.ApiResult
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.net.URI

@RestController
@RequestMapping("/admin/businesses")
@Tag(name = "Business Administration", description = "Endpoints for Superusers to manage businesses.")
// TODO: Enable method security in a @Configuration class and add @PreAuthorize("hasRole('SUPERADMIN')")
@SecurityRequirement(name = "bearerAuth")
class AdminBusinessController(
    private val adminBusinessService: AdminBusinessService
) {


    @PostMapping
    @Operation(
        summary = "Register a new Business and its Admin User",
        description = """
            Creates a new Business entity, its associated Tenant database and schema,
            creates the initial Business Admin user in the Identity Provider (e.g., Keycloak),
            and links the user to the business. Requires SUPERADMIN role.
            """
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201", description = "Business and Admin User created successfully.",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = BusinessDetailedResponse::class)
                )]
            ),
            ApiResponse(
                responseCode = "400", description = "Invalid input data (validation failure).",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "401", description = "Unauthorized (Not authenticated)."
            ),
            ApiResponse(
                responseCode = "403", description = "Forbidden (User does not have SUPERADMIN role)."
            ),
            ApiResponse(
                responseCode = "409", description = "Conflict (e.g., duplicate email or business name).",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "500",
                description = "Internal Server Error (e.g., IdP communication failure, tenant creation failure).",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
        ]
    )
    //TODO: Add @PreAuthorize("hasRole('SUPERADMIN')") below
    fun registerBusiness(
        @Valid @RequestBody request: AdminCreateBusinessRequest
    ): ResponseEntity<BusinessDetailedResponse> {
        val createdBusiness = adminBusinessService.registerNewBusinessAndAdmin(request)
        val location = URI.create("/admin/business/${createdBusiness.id}")
        return ResponseEntity.created(location).body(createdBusiness)
    }

    // TODO --- Add other Superuser endpoints later ---
    // GET /admin/businesses (List all)
    // GET /admin/businesses/{id} (Get specific by ID)
    // PUT /admin/businesses/{id}/status (Activate/Deactivate)

}

================================================
File: dev/cnpe/ventescabekotlin/business/infrastructure/web/UserManagementController.kt
================================================
package dev.cnpe.ventescabekotlin.business.infrastructure.web

import dev.cnpe.ventescabekotlin.business.application.dto.request.CreateBusinessUserRequest
import dev.cnpe.ventescabekotlin.business.application.service.UserManagementService
import dev.cnpe.ventescabekotlin.security.ports.dto.UserIdentity
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/business/users")
@Tag(
    name = "Business User Management",
    description = "Endpoints for Business Admins to manage users within their business."
)
@SecurityRequirement(name = "bearerAuth")
// TODO: Secure all endpoints with @PreAuthorize("hasRole('BUSINESS_ADMIN')")
class UserManagementController(
    private val userManagementService: UserManagementService
) {

    @PostMapping
    @Operation(
        summary = "Create a new user for the current business",
        description = "Creates a Seller or Branch Manager user associated with the admin's business."
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "User created successfully.",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = UserIdentity::class))]
            ),
        ]
    //TODO: Add other api responses
    )
    // TODO: Add @PreAuthorize("hasRole('BUSINESS_ADMIN')")
    fun createBusinessUser(
        @Valid @RequestBody request: CreateBusinessUserRequest
    ): ResponseEntity<UserIdentity> {
        val createdUser = userManagementService.createBusinessUser(request.userData, request.roles)
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser)
    }

    // TODO: Implement endpoints for listing users in business, updating, deleting, assigning roles
    // GET /business/users
    // PUT /business/users/{userIdpId}/roles
    // DELETE /business/users/{userIdpId}

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/api/ProductInfoPort.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.api

/**
 * Port defining operations for retrieving basic Product information needed by other modules.
 */
interface ProductInfoPort {


    /**
     * Counts the number of products associated with a specific supplier ID.
     *
     * @param supplierId The ID of the supplier.
     * @return The number of products linked to the supplier.
     */
    fun countProductsBySupplierId(supplierId: Long): Long

    /**
     * Counts the number of products associated with a specific brand ID.
     *
     * @param brandId The ID of the brand.
     * @return The number of products linked to the brand.
     */
    fun countProductsByBrandId(brandId: Long): Long

    /**
     * Counts the number of products associated with a specific category ID.
     *
     * @param categoryId The ID of the category.
     * @return The number of products linked to the category.
     */
    fun countProductsByCategoryId(categoryId: Long): Long

    // TODO: Add methods for relocating products if needed (e.g., when deleting category/brand/supplier)
    // fun relocateProductsToDefaultSupplier(oldSupplierId: Long): Int

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/common/ProductDetails.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.common

import dev.cnpe.ventescabekotlin.catalog.domain.enums.ProductStatus
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Core details of the product.")
data class ProductDetails(

    @Schema(description = "Display name of the product.", example = "iPhone 14")
    val name: String,
    @Schema(description = "Stock Keeping Unit (SKU). Unique identifier.", example = "LP-BLK-16-512")
    val sku: String?,
    @Schema(description = "Barcode (EAN, UPC, etc.).", example = "1234567890123")
    val barcode: String,
    @Schema(description = "Product description.")
    val description: String?,
    @Schema(description = "Current status of the product.")
    val status: ProductStatus

)


================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/common/ProductPricingData.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.common

import io.swagger.v3.oas.annotations.media.Schema
import java.math.BigDecimal

@Schema(description = "Calculated pricing information for the product at a point in time.")
data class ProductPricingData(

    @Schema(description = "Currency code.", example = "CLP")
    val currency: String,

    @Schema(description = "Current net selling price (excluding tax).")
    val currentNetSellingPrice: BigDecimal,

    @Schema(description = "Current gross selling price (including tax).")
    val currentSellingPrice: BigDecimal,

    @Schema(description = "Current supplier cost.")
    val currentSupplierCost: BigDecimal,

    @Schema(description = "Current profit amount (Gross Selling Price - Cost).")
    val currentProfit: BigDecimal,

    @Schema(description = "Current profit margin percentage ((Profit / Cost) * 100).")
    val currentProfitMargin: BigDecimal?
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/common/ProductRelationsData.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.common

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "IDs representing product relationships.")
data class ProductRelationsData(

    @Schema(description = "ID of the associated category.")
    val categoryId: Long?,

    @Schema(description = "ID of the associated brand.")
    val brandId: Long?,

    @Schema(description = "ID of the associated supplier.")
    val supplierId: Long?
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/common/ProductStockData.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.common

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Stock information summary (provided by Inventory module).")
data class ProductStockData(
    @Schema(description = "Current total quantity across all locations.")
    val currentQuantity: Double?,

    @Schema(description = "Configured minimum quantity level.", nullable = true)
    val minimumQuantity: Double?,

    @Schema(description = "Unit of measure (e.g., UNIT, KG).")
    val unitOfMeasure: StockUnitType
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/request/CreateProductDraftRequest.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import org.hibernate.validator.constraints.Length

@Schema(description = "Request to create a new product draft with minimal info.")
data class CreateProductDraftRequest(

    @field:NotBlank
    @field:Length(min = 3, max = 70)
    @Schema(description = "Display name of the product.", example = "Basic Widget")
    val name: String,

    @field:NotBlank
    @field:Length(min = 3, max = 70)
    @Schema(description = "Barcode (EAN, UPC, etc.). Must be unique.", example = "1234567890128")
    val barcode: String
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/request/CreateProductRequest.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.request

import dev.cnpe.ventescabekotlin.catalog.domain.enums.ProductStatus
import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import dev.cnpe.ventescabekotlin.shared.domain.vo.Image
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.DecimalMin
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import org.hibernate.validator.constraints.Length
import java.math.BigDecimal

// TODO: Add validation schemas for inventory module types when available

@Schema(description = "Request to create a full product with all necessary details.")
data class CreateProductRequest(

    @field:NotBlank @field:Length(min = 3, max = 70)
    @Schema(description = "Display name of the product.", example = "Laptop Pro 16GB")
    val name: String,

    @field:NotBlank @field:Length(min = 3, max = 70)
    @Schema(description = "Barcode (EAN, UPC, etc.). Must be unique.", example = "9780123456786")
    val barcode: String,

    @field:Length(min = 3, max = 1000)
    @Schema(description = "Detailed description of the product.", example = "High-performance laptop...")
    val description: String?,

    @field:NotNull @field:DecimalMin(value = "0.0", inclusive = false)
    @Schema(description = "Selling price (excluding tax).", example = "1299.99")
    val sellingPrice: BigDecimal,

    @field:NotNull @field:DecimalMin(value = "0.0", inclusive = false)
    @Schema(description = "Supplier cost (unit cost).", example = "750.50")
    val supplierCost: BigDecimal,

    @field:NotNull
    @Schema(description = "Unit of measure for stock.", example = "UNIT")
    val stockUnitType: StockUnitType,

    @field:NotNull
    @Schema(description = "ID of the associated category.", example = "101")
    val categoryId: Long,

    @field:NotNull
    @Schema(description = "ID of the associated brand.", example = "202")
    val brandId: Long,

    @field:NotNull
    @Schema(description = "ID of the associated supplier.", example = "303")
    val supplierId: Long,

    @Schema(description = "List of product images (URLs).")
    val photos: List<Image>? = emptyList(),

    @field:NotNull
    @Schema(description = "Initial status of the product.", example = "ACTIVE")
    val status: ProductStatus
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/request/UpdateProductBasicsRequest.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.request

import dev.cnpe.ventescabekotlin.shared.application.validation.NotBlankIfPresent
import io.swagger.v3.oas.annotations.media.Schema
import org.hibernate.validator.constraints.Length

@Schema(description = "Request to update basic product information (name, description).")
data class UpdateProductBasicsRequest(

    @field:NotBlankIfPresent
    @field:Length(min = 3, max = 70)
    @get:Schema(description = "New display name for the product.", example = "Laptop Pro 32GB")
    val name: String?,

    @field:Length(min = 3, max = 1000)
    @get:Schema(
        description = "New product description. Send empty string to clear.",
        example = "Updated description..."
    )
    val description: String?
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/request/UpdateProductRelationsRequest.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Positive

@Schema(description = "Request to update product relationships (category, brand, supplier).")
data class UpdateProductRelationsRequest(

    @field:NotNull
    @field:Positive
    @Schema(description = "ID of the new category.", example = "102")
    val categoryId: Long,

    @field:NotNull
    @field:Positive
    @Schema(description = "ID of the new brand.", example = "203")
    val brandId: Long,

    @field:NotNull
    @field:Positive
    @Schema(description = "ID of the new supplier.", example = "304")
    val supplierId: Long
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/request/UpdateProductSellingPriceRequest.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.request

import dev.cnpe.ventescabekotlin.catalog.domain.enums.PriceChangeReason
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.DecimalMin
import jakarta.validation.constraints.NotNull
import java.math.BigDecimal

@Schema(description = "Request to update the selling price of a product.")
data class UpdateProductSellingPriceRequest(

    @field:NotNull
    @field:DecimalMin(value = "0.01", message = "Selling price must be positive")
    @Schema(description = "The new selling price amount.", example = "1349.99")
    val sellingPrice: BigDecimal,

    @field:NotNull
    @Schema(description = "Indicates if the provided sellingPrice includes tax.", example = "false")
    val taxInclusive: Boolean,

    @field:NotNull
    @Schema(description = "Reason for this price change.", example = "COST_CHANGE")
    val reason: PriceChangeReason
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/request/UpdateProductStatusRequest.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.request

import dev.cnpe.ventescabekotlin.catalog.domain.enums.ProductStatus
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotNull

@Schema(description = "Request to update the status of a product.")
data class UpdateProductStatusRequest(

    @field:NotNull
    @Schema(description = "The new status for the product.", example = "INACTIVE")
    val status: ProductStatus
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/request/UpdateProductSupplierCostRequest.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.DecimalMin
import jakarta.validation.constraints.NotNull
import java.math.BigDecimal

@Schema(description = "Request to update the supplier cost of a product.")
data class UpdateProductSupplierCostRequest(

    @field:NotNull
    @field:DecimalMin(value = "0.01", message = "Supplier cost must be positive")
    @Schema(description = "The new supplier cost amount.", example = "780.00")
    val supplierCost: BigDecimal
)

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/response/ProductCreatedResponse.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.response

import dev.cnpe.ventescabekotlin.catalog.domain.enums.ProductStatus
import io.swagger.v3.oas.annotations.media.Schema
import java.time.OffsetDateTime

@Schema(description = "Response after successfully creating a product.")
data class ProductCreatedResponse(

    @Schema(description = "ID of the newly created product.", requiredMode = Schema.RequiredMode.REQUIRED)
    val id: Long,

    @Schema(description = "Initial status of the created product.", requiredMode = Schema.RequiredMode.REQUIRED)
    val status: ProductStatus,

    @Schema(description = "Timestamp of creation.", requiredMode = Schema.RequiredMode.REQUIRED, format = "date-time")
    val createdAt: OffsetDateTime
)


================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/response/ProductDetailedResponse.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.response

import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductDetails
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductPricingData
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductRelationsData
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductStockData
import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import dev.cnpe.ventescabekotlin.shared.domain.vo.Image
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Complete details for a single product.")
data class ProductDetailedResponse(

    @Schema(description = "Product ID.", requiredMode = Schema.RequiredMode.REQUIRED)
    val id: Long,

    @Schema(description = "Core product details.", requiredMode = Schema.RequiredMode.REQUIRED)
    val details: ProductDetails,

    @Schema(description = "Pricing information.", requiredMode = Schema.RequiredMode.REQUIRED)
    val pricing: ProductPricingData,

    @Schema(description = "Stock information.", requiredMode = Schema.RequiredMode.REQUIRED)
    val stockInfo: ProductStockData,

    @Schema(description = "List of product images.")
    val photos: List<Image>?,

    @Schema(description = "Relationship IDs.", requiredMode = Schema.RequiredMode.REQUIRED)
    val relations: ProductRelationsData,

    @Schema(description = "Audit information.", requiredMode = Schema.RequiredMode.REQUIRED)
    val auditData: ResourceAuditData


)


================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/response/ProductPriceInfoResponse.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import java.math.BigDecimal
import java.time.LocalDateTime

@Schema(description = "Information about a product price.")
data class ProductPriceInfoResponse(

    @Schema(description = "Selling price of the product.")
    val sellingPrice: BigDecimal,

    @Schema(description = "Purchase price of the product.")
    val supplierCost: BigDecimal,

    @Schema(description = "Profit of the product.")
    val profit: BigDecimal,

    @Schema(description = "Profit margin of the product.")
    val profitMargin: BigDecimal?,

    @Schema(description = "Start date of the product price.")
    val startDate: LocalDateTime,

    @Schema(description = "End date of the product price.")
    val endDate: LocalDateTime?,

    @Schema(description = "Reason for the price change.")
    val changeReason: String

)


================================================
File: dev/cnpe/ventescabekotlin/catalog/application/dto/response/ProductSummaryResponse.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.dto.response

import dev.cnpe.ventescabekotlin.catalog.domain.enums.ProductStatus
import io.swagger.v3.oas.annotations.media.Schema
import java.math.BigDecimal

@Schema(name = "ProductSimpleResponse", description = "Basic summary information for a product, suitable for lists.")
data class ProductSummaryResponse(

    @Schema(description = "Product ID.", requiredMode = Schema.RequiredMode.REQUIRED)
    val id: Long,

    @Schema(description = "Product name.", requiredMode = Schema.RequiredMode.REQUIRED, example = "Churu 30g")
    val name: String,

    @Schema(description = "Product barcode.", requiredMode = Schema.RequiredMode.REQUIRED, example = "14658974987")
    val barcode: String,

    @Schema(description = "Current selling price (tax included).", requiredMode = Schema.RequiredMode.REQUIRED)
    val currentSellingPrice: BigDecimal,

    @Schema(description = "Total stock across all locations.", requiredMode = Schema.RequiredMode.REQUIRED)
    val currentTotalStock: Double,

    @Schema(description = "Current status.", requiredMode = Schema.RequiredMode.REQUIRED)
    val status: ProductStatus,

    @Schema(description = "Associated category ID.", requiredMode = Schema.RequiredMode.REQUIRED)
    val categoryId: Long?

)


================================================
File: dev/cnpe/ventescabekotlin/catalog/application/factory/ProductFactory.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.factory

import dev.cnpe.ventescabekotlin.catalog.application.dto.request.CreateProductRequest
import dev.cnpe.ventescabekotlin.catalog.application.service.SkuGenerator
import dev.cnpe.ventescabekotlin.catalog.domain.enums.PriceChangeReason
import dev.cnpe.ventescabekotlin.catalog.domain.enums.ProductStatus
import dev.cnpe.ventescabekotlin.catalog.domain.model.Product
import dev.cnpe.ventescabekotlin.catalog.domain.model.ProductPrice
import dev.cnpe.ventescabekotlin.currency.service.MoneyFactory
import org.springframework.stereotype.Component

/**
 * Factory responsible for constructing Product domain entities and initial ProductPrice.
 * Relies on calling services to provide necessary context like currency and relationship IDs.
 */
@Component
class ProductFactory(
    private val moneyFactory: MoneyFactory,
    private val skuGenerator: SkuGenerator
) {


    /**
     * Creates a new Product entity in a DRAFT state with minimal information.
     * Requires default relationship IDs to be provided by the calling service.
     */
    fun createDraft(
        barcode: String,
        productName: String,
        defaultCategoryId: Long,
        defaultBrandId: Long,
        defaultSupplierId: Long,
        currencyCode: String
    ): Product {
        require(barcode.isNotBlank()) { "Barcode cannot be blank" }
        require(productName.isNotBlank()) { "Product name cannot be blank" }

        val sanitizedProductName = sanitizeProductName(productName)

        val product = Product(
            name = sanitizedProductName,
            barcode = barcode,
            status = ProductStatus.DRAFT,
            categoryId = defaultCategoryId,
            brandId = defaultBrandId,
            supplierId = defaultSupplierId,
        )

        product.assignSku(skuGenerator.generateSku(product.name))

        val zeroPrice = moneyFactory.zero(currencyCode)
        val initialPrice = ProductPrice(
            sellingPrice = zeroPrice,
            supplierCost = zeroPrice,
            reason = PriceChangeReason.INITIAL,
            product = product
        )
        product.addPrice(initialPrice)
        return product
    }


    /**
     * Creates a fully populated Product entity from a DTO request.
     * Requires currency code to be provided by the calling service.
     */
    fun createFromRequest(request: CreateProductRequest, currencyCode: String): Product {
        val product = Product(
            name = sanitizeProductName(request.name),
            barcode = request.barcode,
            description = request.description?.trim(),
            status = request.status,
            categoryId = request.categoryId,
            brandId = request.brandId,
            supplierId = request.supplierId,
            photos = request.photos?.toMutableList() ?: mutableListOf()
        )

        product.assignSku(skuGenerator.generateSku(product.name))

        val sellingPriceMoney = moneyFactory.createMoney(request.sellingPrice, currencyCode)
        val supplierCostMoney = moneyFactory.createMoney(request.supplierCost, currencyCode)

        val initialPrice = ProductPrice(
            sellingPrice = sellingPriceMoney,
            supplierCost = supplierCostMoney,
            reason = PriceChangeReason.INITIAL,
            product = product
        )
        product.addPrice(initialPrice)

        // TODO: Consider stock unit type - where should this be stored/handled?

        return product
    }

    /**
     * Sanitizes the product name by trimming whitespace, converting it to lowercase,
     * and capitalizing the first character.
     *
     * @param productName The original product name to be sanitized.
     * @return A sanitized version of the product name.
     */
    private fun sanitizeProductName(productName: String): String {
        return productName.trim().lowercase().replaceFirstChar { it.titlecase() }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/mapper/ProductMapper.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.mapper

import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductDetails
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductPricingData
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductRelationsData
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductStockData
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductCreatedResponse
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductDetailedResponse
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductPriceInfoResponse
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductSummaryResponse
import dev.cnpe.ventescabekotlin.catalog.domain.model.Product
import dev.cnpe.ventescabekotlin.catalog.domain.model.ProductPrice
import dev.cnpe.ventescabekotlin.inventory.application.api.dto.ProductInventorySummary
import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import org.springframework.stereotype.Component
import java.math.BigDecimal

@Component
class ProductMapper {

    /**
     * Maps a Product entity to a ProductCreatedResponse DTO.
     */
    fun toCreated(product: Product): ProductCreatedResponse {
        return ProductCreatedResponse(
            id = product.id!!,
            status = product.status,
            createdAt = product.createdAt
        )
    }

    /**
     * Maps a Product entity to a ProductSummaryResponse DTO.
     */
    fun toSummary(product: Product): ProductSummaryResponse {
        val currentPrice = product.getCurrentPrice()
        val sellingPrice = currentPrice?.sellingPrice?.amount ?: BigDecimal.ZERO

        return ProductSummaryResponse(
            id = product.id!!,
            name = product.name,
            barcode = product.barcode,
            currentSellingPrice = sellingPrice,
            currentTotalStock = product.totalCurrentStock,
            status = product.status,
            categoryId = product.categoryId
        )
    }

    /**
     * Maps a Product entity and related info (pricing, inventory) to a ProductDetailedResponse DTO.
     * Assumes pricingData and inventoryItemInfo are pre-calculated/fetched and passed in.
     */
    fun toDetailed(
        product: Product,
        pricingData: ProductPricingData,
        stockData: ProductStockData
    ): ProductDetailedResponse {
        return ProductDetailedResponse(
            id = product.id!!,
            details = ProductDetails(
                name = product.name,
                sku = product.sku,
                barcode = product.barcode,
                description = product.description,
                status = product.status
            ),
            pricing = pricingData,
            stockInfo = stockData,
            photos = product.photos,
            relations = ProductRelationsData(
                categoryId = product.categoryId,
                brandId = product.brandId,
                supplierId = product.supplierId
            ),
            auditData = ResourceAuditData.fromBaseEntity(product)
        )
    }

    /**
     * Maps a ProductPrice entity (historical price record) to a ProductPriceInfoResponse DTO.
     */
    fun toProductPriceInfo(productPrice: ProductPrice): ProductPriceInfoResponse {
        return ProductPriceInfoResponse(
            sellingPrice = productPrice.sellingPrice.amount,
            supplierCost = productPrice.supplierCost.amount,
            profit = productPrice.calculateProfit().amount,
            profitMargin = productPrice.calculateProfitMargin(),
            startDate = productPrice.startDate,
            endDate = productPrice.endDate,
            changeReason = productPrice.reason.name
        )
    }
}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/service/ProductInfoAdapter.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.service

import dev.cnpe.ventescabekotlin.catalog.api.ProductInfoPort
import dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence.ProductRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
@Transactional(readOnly = true)
class ProductInfoAdapter(
    private val productRepository: ProductRepository
) : ProductInfoPort {

    override fun countProductsBySupplierId(supplierId: Long): Long {
        log.debug { "Counting products for Supplier ID: $supplierId" }
        val count = productRepository.countAllBySupplierId(supplierId)
        log.debug { "Found $count products for Supplier ID: $supplierId" }
        return count
    }

    override fun countProductsByBrandId(brandId: Long): Long {
        log.debug { "Counting products for Brand ID: $brandId" }
        val count = productRepository.countAllByBrandId(brandId)
        log.debug { "Found $count products for Brand ID: $brandId" }
        return count
    }

    override fun countProductsByCategoryId(categoryId: Long): Long {
        log.debug { "Counting products for Category ID: $categoryId" }
        val count = productRepository.countAllByCategoryId(categoryId)
        log.debug { "Found $count products for Category ID: $categoryId" }
        return count
    }

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/service/ProductService.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.service

import dev.cnpe.ventescabekotlin.brands.application.api.BrandInfoPort
import dev.cnpe.ventescabekotlin.business.application.api.BusinessDataPort
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductPricingData
import dev.cnpe.ventescabekotlin.catalog.application.dto.common.ProductStockData
import dev.cnpe.ventescabekotlin.catalog.application.dto.request.CreateProductDraftRequest
import dev.cnpe.ventescabekotlin.catalog.application.dto.request.CreateProductRequest
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductCreatedResponse
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductDetailedResponse
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductPriceInfoResponse
import dev.cnpe.ventescabekotlin.catalog.application.dto.response.ProductSummaryResponse
import dev.cnpe.ventescabekotlin.catalog.application.factory.ProductFactory
import dev.cnpe.ventescabekotlin.catalog.application.mapper.ProductMapper
import dev.cnpe.ventescabekotlin.catalog.application.util.ProductUtils
import dev.cnpe.ventescabekotlin.catalog.application.validation.ProductRelationValidator
import dev.cnpe.ventescabekotlin.catalog.event.ProductCreatedEvent
import dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence.ProductPriceRepository
import dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence.ProductRepository
import dev.cnpe.ventescabekotlin.categories.application.api.CategoryInfoPort
import dev.cnpe.ventescabekotlin.inventory.application.api.InventoryInfoPort
import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import dev.cnpe.ventescabekotlin.shared.application.dto.PageResponse
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.INVALID_STATE
import dev.cnpe.ventescabekotlin.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import dev.cnpe.ventescabekotlin.suppliers.application.api.SupplierInfoPort
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.ApplicationEventPublisher
import org.springframework.data.domain.Pageable
import org.springframework.data.repository.findByIdOrNull
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
@Transactional
class ProductService(
    private val productRepository: ProductRepository,
    private val productPriceRepository: ProductPriceRepository,
    private val productFactory: ProductFactory,
    private val productMapper: ProductMapper,
    private val businessDataPort: BusinessDataPort,
    private val productUtils: ProductUtils,
    private val eventPublisher: ApplicationEventPublisher,
    private val inventoryInfoPort: InventoryInfoPort,
    private val categoryInfoPort: CategoryInfoPort,
    private val brandInfoPort: BrandInfoPort,
    private val supplierInfoPort: SupplierInfoPort,
    private val relationValidator: ProductRelationValidator
) {

    fun createProductDraft(request: CreateProductDraftRequest): ProductCreatedResponse {
        log.debug { "Creating product draft: Name=${request.name}, Barcode=${request.barcode}" }
        validateProductDraftRequest(request)

        val currencyCode = businessDataPort.getBusinessPaymentData().currencyCode
        val defaultCategoryId = categoryInfoPort.getDefaultCategoryId()
        val defaultBrandId = brandInfoPort.getDefaultBrandId()
        val defaultSupplierId = supplierInfoPort.getDefaultSupplierId()

        val newProductDraft = productFactory.createDraft(
            barcode = request.barcode,
            productName = request.name,
            defaultCategoryId = defaultCategoryId,
            defaultBrandId = defaultBrandId,
            defaultSupplierId = defaultSupplierId,
            currencyCode = currencyCode
        )

        val savedProduct = productRepository.save(newProductDraft)
        log.info { "Product draft created: ${savedProduct.name} (ID: ${savedProduct.id})" }

        eventPublisher.publishEvent(ProductCreatedEvent(savedProduct.id!!, StockUnitType.UNIT))

        return productMapper.toCreated(savedProduct)
    }

    fun createProduct(request: CreateProductRequest): ProductCreatedResponse {
        log.debug { "Creating full product: Name=${request.name}, Barcode=${request.barcode}" }
        validateProductRequest(request)

        val currencyCode = businessDataPort.getBusinessPaymentData().currencyCode

        val newProduct = productFactory.createFromRequest(request, currencyCode)

        val savedProduct = productRepository.save(newProduct)
        log.info { "Full product created: ${savedProduct.name} (ID: ${savedProduct.id})" }

        eventPublisher.publishEvent(ProductCreatedEvent(savedProduct.id!!, request.stockUnitType))

        return productMapper.toCreated(savedProduct)
    }

    @Transactional(readOnly = true)
    fun getProductDetails(id: Long): ProductDetailedResponse {
        log.debug { "Fetching details for product ID: $id" }

        val product = productRepository.findByIdOrNull(id)
            ?: throw createResourceNotFoundException("Product", id)

        val inventorySummary = inventoryInfoPort.getInventorySummary(id)
        val businessPaymentData = businessDataPort.getBusinessPaymentData()

        val currentPrice = product.getCurrentPrice()
            ?: throw DomainException(INVALID_STATE, details = mapOf("reason" to "NO_ACTIVE_PRICE"))

        val pricingData = ProductPricingData(
            currency = businessPaymentData.currencyCode,
            currentNetSellingPrice = productUtils.calculateNetPrice(
                currentPrice.sellingPrice.amount,
                businessPaymentData
            ),
            currentSellingPrice = currentPrice.sellingPrice.amount,
            currentSupplierCost = currentPrice.supplierCost.amount,
            currentProfit = currentPrice.calculateProfit().amount,
            currentProfitMargin = currentPrice.calculateProfitMargin()
        )

        val productStockData = ProductStockData(
            currentQuantity = inventorySummary.totalStockQuantity,
            minimumQuantity = inventorySummary.representativeMinimumQuantity,
            unitOfMeasure = inventorySummary.unitOfMeasure
        )

        return productMapper.toDetailed(product, pricingData, productStockData)
    }

    @Transactional(readOnly = true)
    fun getAllProductSummaries(pageable: Pageable): PageResponse<ProductSummaryResponse> {
        log.debug { "Fetching product summaries page: $pageable" }
        val productPage = productRepository.findAllWithPriceHistory(pageable)

        return PageResponse.from(productPage.map { productMapper.toSummary(it) })

    }

    @Transactional(readOnly = true)
    fun getProductPriceHistory(productId: Long, pageable: Pageable): PageResponse<ProductPriceInfoResponse> {
        log.debug { "Fetching price history for product ID: $productId, page: $pageable" }
        if (!productRepository.existsById(productId)) {
            throw createResourceNotFoundException("Product", productId)
        }
        val pricePage = productPriceRepository.getProductPriceHistory(productId, pageable)
        return PageResponse.from(pricePage.map { productMapper.toProductPriceInfo(it) })
    }

    // *******************************
    // 🔰 Private Helpers
    // *******************************

    private fun validateProductDraftRequest(request: CreateProductDraftRequest) {
        if (productRepository.existsByName(request.name)) {
            throw createDuplicatedResourceException("name", request.name)
        }
        if (productRepository.existsByBarcode(request.barcode)) {
            throw createDuplicatedResourceException("barcode", request.barcode)
        }
    }

    private fun validateProductRequest(request: CreateProductRequest) {
        if (productRepository.existsByName(request.name)) {
            throw createDuplicatedResourceException("name", request.name)
        }
        if (productRepository.existsByBarcode(request.barcode)) {
            throw createDuplicatedResourceException("barcode", request.barcode)
        }
        relationValidator.validateRelations(
            categoryId = request.categoryId,
            brandId = request.brandId,
            supplierId = request.supplierId
        )
    }
}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/service/ProductUpdateService.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.service

import dev.cnpe.ventescabekotlin.business.application.api.BusinessDataPort
import dev.cnpe.ventescabekotlin.catalog.application.dto.request.*
import dev.cnpe.ventescabekotlin.catalog.application.util.ProductUtils
import dev.cnpe.ventescabekotlin.catalog.application.validation.ProductRelationValidator
import dev.cnpe.ventescabekotlin.catalog.domain.enums.PriceChangeReason
import dev.cnpe.ventescabekotlin.catalog.domain.model.Product
import dev.cnpe.ventescabekotlin.catalog.domain.model.ProductPrice
import dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence.ProductRepository
import dev.cnpe.ventescabekotlin.currency.service.MoneyFactory
import dev.cnpe.ventescabekotlin.inventory.event.StockUpdatedEvent
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode
import dev.cnpe.ventescabekotlin.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.data.repository.findByIdOrNull
import org.springframework.modulith.events.ApplicationModuleListener
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
@Transactional
class ProductUpdateService(
    private val productRepository: ProductRepository,
    private val businessDataPort: BusinessDataPort,
    private val moneyFactory: MoneyFactory,
    private val productUtils: ProductUtils,
    private val relationValidator: ProductRelationValidator
) {

    fun updateBasics(id: Long, request: UpdateProductBasicsRequest) {
        val product = findProductByIdOrThrow(id)
        log.debug { "Updating basics for product ID: ${product.id}" }

        var updated = false
        request.name?.takeIf { it.isNotBlank() && it != product.name }?.let { newName ->
            if (productRepository.existsByName(newName)) {
                throw createDuplicatedResourceException("name", newName)
            }
            product.name = newName
            log.trace { "Product $id name updated to '$newName'" }
            updated = true
        }

        // description can be set to blank if needed
        request.description?.takeIf { it != product.description }?.let {
            product.description = it.trim()
            log.trace { "Product $id description updated" }
            updated = true
        }
        if (updated) log.info { "Product basics updated for ID: $id" }
        else log.info { "No changes detected in product basics for ID: $id" }
    }

    fun updateSellingPrice(id: Long, request: UpdateProductSellingPriceRequest) {
        val product = findProductByIdOrThrow(id)
        val currentPrice = product.getCurrentPrice()
            ?: throw DomainException(GeneralErrorCode.INVALID_STATE, details = mapOf("reason" to "NO_ACTIVE_PRICE"))

        val businessPaymentData = businessDataPort.getBusinessPaymentData()
        val currencyCode = currentPrice.sellingPrice.currencyCode

        val grossSellingPrice = if (request.taxInclusive) {
            // TODO: Maybe validate that request.sellingPrice > cost if taxInclusive?
            request.sellingPrice
        } else {
            productUtils.calculateFinalPrice(request.sellingPrice, businessPaymentData)
        }

        if (currentPrice.sellingPrice.amount == grossSellingPrice) {
            log.warn { "Requested selling price results in the same gross price (${grossSellingPrice}). No update performed." }
            return
        }

        log.debug { "Updating selling price for product ID: $id to $grossSellingPrice $currencyCode (Reason: ${request.reason})" }

        val newPriceRecord = ProductPrice(
            sellingPrice = moneyFactory.createMoney(grossSellingPrice, currencyCode),
            supplierCost = currentPrice.supplierCost,
            reason = request.reason,
            product = product
        )
        product.addPrice(newPriceRecord)
        log.info { "Selling price updated for product $id. New active price: ${newPriceRecord.sellingPrice}" }
    }

    fun updateSupplierCost(id: Long, request: UpdateProductSupplierCostRequest) {
        val product = findProductByIdOrThrow(id)
        val currentPrice = product.getCurrentPrice()
            ?: throw DomainException(GeneralErrorCode.INVALID_STATE, details = mapOf("reason" to "NO_ACTIVE_PRICE"))

        val currencyCode = currentPrice.supplierCost.currencyCode
        val newCost = moneyFactory.createMoney(request.supplierCost, currencyCode)

        if (currentPrice.supplierCost == newCost) {
            log.warn { "Requested supplier cost ${request.supplierCost} is same as current. No update performed." }
            return
        }

        log.debug { "Updating supplier cost for product ID: $id to $newCost" }

        val newPriceRecord = ProductPrice(
            sellingPrice = currentPrice.sellingPrice,
            supplierCost = newCost,
            reason = PriceChangeReason.COST_CHANGE,
            product = product
        )
        product.addPrice(newPriceRecord)

        log.info { "Supplier cost updated for product $id. New active cost: ${newPriceRecord.supplierCost}" }
    }

    fun updateRelations(id: Long, request: UpdateProductRelationsRequest) {
        val product = findProductByIdOrThrow(id)
        log.debug { "Updating relations for product ID: $id to Cat=${request.categoryId}, Brand=${request.brandId}, Sup=${request.supplierId}" }

        relationValidator.validateRelations(
            categoryId = request.categoryId,
            brandId = request.brandId,
            supplierId = request.supplierId
        )

        var updated = false
        if (product.categoryId != request.categoryId) {
            product.categoryId = request.categoryId
            updated = true
        }
        if (product.brandId != request.brandId) {
            product.brandId = request.brandId
            updated = true
        }
        if (product.supplierId != request.supplierId) {
            product.supplierId = request.supplierId
            updated = true
        }

        if (updated) {
            log.info { "Product relations updated for ID: $id" }
        } else {
            log.info { "No changes detected in product relations for ID: $id" }
        }
    }

    fun updateStatus(id: Long, request: UpdateProductStatusRequest) {
        val product = findProductByIdOrThrow(id)
        if (product.status != request.status) {
            log.info { "Updating product $id status from ${product.status} to ${request.status}" }
            product.status = request.status
        }
    }

    /**
     * Activates a product by setting its status to ACTIVE.
     * Requires validation checks to be passed.
     */
    fun activateProduct(id: Long) {
        val product = findProductByIdOrThrow(id)
        log.info { "Attempting to activate product: ${product.name} (ID: $id)" }
        product.activate()
        log.info { "🟢 Product activated: ${product.name} (ID: $id)" }
    }


    @ApplicationModuleListener
    fun onStockUpdated(event: StockUpdatedEvent) {
        log.debug { "Received stock update for product ${event.productId}, new total: ${event.totalStockQuantity}" }
        productRepository.findByIdOrNull(event.productId)?.let { product ->
            if (product.totalCurrentStock != event.totalStockQuantity) {
                product.totalCurrentStock = event.totalStockQuantity
                log.info { "Updated totalCurrentStock for product ${product.id} to ${product.totalCurrentStock}" }
            }
        } ?: log.warn { "Received stock update for non-existent product ID: ${event.productId}" }
    }


    // *******************************
    // 🔰 Private Helpers
    // *******************************

    private fun findProductByIdOrThrow(id: Long): Product {
        return productRepository.findByIdOrNull(id)
            ?: throw createResourceNotFoundException("Product", id)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/service/SkuGenerator.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.service

import org.springframework.stereotype.Service
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*

@Service
class SkuGenerator {

    companion object {
        private const val DELIMITER = "-"
        private const val CODE_LENGTH = 6
        private const val UUID_LENGTH = 6
        private const val DATE_PATTERN = "yyyyMM"
        private const val PREFIX = "P"
    }

    /**
     * Generates a unique SKU based on product name, creation date, and a random ID.
     * Example: P-LAPTOP-202410-A1B2C3
     *
     * @param productName The name of the product.
     * @return A generated SKU string.
     */
    fun generateSku(productName: String?): String {
        require(!productName.isNullOrBlank()) { "Product name cannot be blank for SKU generation" }

        val productCode = generateCodeFromName(productName)
        val creationDate = LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN))
        val uniqueId = UUID.randomUUID().toString().replace("-", "").take(UUID_LENGTH)

        return "$PREFIX$DELIMITER$productCode$DELIMITER$creationDate$DELIMITER$uniqueId".uppercase()
    }

    /**
     * Generates a fixed-length code derived from the product name.
     * Removes special chars, vowels, takes first letters, pads if necessary.
     */
    private fun generateCodeFromName(name: String): String {
        // uppercase, remove non-alphanumeric
        val processedBase = name.uppercase().replace(Regex("[^A-Z0-9]"), "")

        // try removing vowels first
        var processed = processedBase.replace(Regex("[AEIOU]"), "")

        // if too short after removing vowels, revert to base without vowels removed
        if (processed.length < CODE_LENGTH) {
            processed = processedBase
        }

        // pad with 'X' if still too short
        val padded = processed.padEnd(CODE_LENGTH, 'X')

        return padded.take(CODE_LENGTH)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/util/ProductUtils.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.util

import dev.cnpe.ventescabekotlin.business.dto.BusinessPaymentData
import org.springframework.stereotype.Component
import java.math.BigDecimal
import java.math.RoundingMode

/**
 * Utility service providing helper functions related to product pricing and taxes.
 */
@Component
class ProductUtils {

    companion object {
        private val ONE_HUNDRED = BigDecimal(100)
        private val ONE = BigDecimal.ONE
    }

    /**
     * Adjusts a price based on whether it includes tax or needs tax added.
     *
     * @param price The base price amount.
     * @param paymentData Business data containing tax percentage and currency scale.
     * @param taxInclusive True if the input 'price' already includes tax (calculates net),
     *                     False if tax needs to be added to the 'price' (calculates gross).
     * @return The adjusted price (either net or gross).
     */
    fun applyTaxAdjustment(
        price: BigDecimal,
        paymentData: BusinessPaymentData,
        taxInclusive: Boolean
    ): BigDecimal {
        val taxRate = paymentData.taxPercentage.divide(ONE_HUNDRED, 4, RoundingMode.HALF_UP)
        val taxFactor = ONE + taxRate
        val scale = paymentData.currencyScale
        val roundingMode = RoundingMode.HALF_UP

        return if (taxInclusive) {
            price.divide(taxFactor, scale, roundingMode)
        } else {
            price.multiply(taxFactor).setScale(scale, roundingMode)
        }
    }

    /**
     * Calculates the net price (excluding tax) from a given gross price (including tax).
     */
    fun calculateNetPrice(grossPrice: BigDecimal, paymentData: BusinessPaymentData): BigDecimal {
        return applyTaxAdjustment(grossPrice, paymentData, taxInclusive = true)
    }

    /**
     * Calculates the final gross price (including tax) from a given net price (excluding tax).
     */
    fun calculateFinalPrice(netPrice: BigDecimal, paymentData: BusinessPaymentData): BigDecimal {
        return applyTaxAdjustment(netPrice, paymentData, taxInclusive = false)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/application/validation/ProductRelationValidator.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.application.validation

import dev.cnpe.ventescabekotlin.brands.application.api.BrandInfoPort
import dev.cnpe.ventescabekotlin.categories.application.api.CategoryInfoPort
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.*
import dev.cnpe.ventescabekotlin.suppliers.application.api.SupplierInfoPort
import org.springframework.stereotype.Component

@Component
class ProductRelationValidator(
    private val categoryInfoPort: CategoryInfoPort,
    private val brandInfoPort: BrandInfoPort,
    private val supplierInfoPort: SupplierInfoPort
) {

    fun validateRelations(categoryId: Long?, brandId: Long?, supplierId: Long?) {
        validateRelationExists(categoryInfoPort::getCategoryCodeById, categoryId, "Category")
        validateRelationExists(brandInfoPort::getBrandCodeById, brandId, "Brand")
        validateRelationExists(supplierInfoPort::getSupplierNameById, supplierId, "Supplier")
    }

    /**
     * Validates if a related entity with the given ID exists by calling the provided fetcher function.
     * Throws an INVALID_DATA DomainException if the entity is not found or the fetcher fails.
     *
     * @param fetcher A function (lambda or method reference) that takes a Long ID and returns Any? (or throws).
     * @param id The ID of the entity to validate.
     * @param entityTypeName The user-friendly name of the entity type (e.g., "Category", "Brand").
     * @throws DomainException if validation fails.
     */
    private fun validateRelationExists(fetcher: (Long) -> Any?, id: Long?, entityTypeName: String) {
        if (id == null) {
            throw DomainException(INVALID_DATA, details = mapOf("field" to "${entityTypeName}Id"))
        }
        try {
            fetcher(id) ?: throw DomainException(
                INVALID_DATA,
                details = mapOf("field" to "${entityTypeName}Id", "value" to id),
                message = "Invalid $entityTypeName ID: $id"
            )
        } catch (e: DomainException) {
            if (e.errorCode == RESOURCE_NOT_FOUND) {
                throw DomainException(
                    INVALID_DATA,
                    details = mapOf("field" to "${entityTypeName}Id", "value" to id),
                    cause = e
                )
            } else {
                throw e
            }
        } catch (e: Exception) {
            throw DomainException(GENERAL, message = "Error validating $entityTypeName ID $id", cause = e)
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/catalog/domain/enums/PriceChangeReason.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.domain.enums

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "The reason for a change in product price (selling or cost).")
enum class PriceChangeReason : DomainEnum {
    @Schema(description = "Price set when product is first created.")
    INITIAL,

    @Schema(description = "Price changed due to update in supplier cost.")
    COST_CHANGE,

    @Schema(description = "Temporary price adjustment for a promotion.")
    PROMOTION,

    @Schema(description = "Price change based on seasonality.")
    SEASONAL,

    @Schema(description = "Price adjusted due to competitor pricing.")
    MARKET_COMPETITION,

    @Schema(description = "Price change resulting from switching suppliers.")
    SUPPLIER_CHANGE,

    @Schema(description = "Manual price adjustment or correction.")
    MANUAL_ADJUSTMENT,

    @Schema(description = "Price change due to other unspecified reasons.")
    OTHER;
}

================================================
File: dev/cnpe/ventescabekotlin/catalog/domain/enums/ProductStatus.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.domain.enums

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "The status of the product within the catalog and sales channel.")
enum class ProductStatus : DomainEnum {

    @Schema(description = "Initial state, minimal info provided (name, barcode). Not sellable.")
    DRAFT,

    @Schema(description = "Actively listed, sellable, and visible (if stock allows).")
    ACTIVE,

    @Schema(description = "Temporarily delisted or disabled, not sellable.")
    INACTIVE;

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/domain/model/Product.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.domain.model

import dev.cnpe.ventescabekotlin.catalog.domain.enums.ProductStatus
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.INVALID_STATE
import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import dev.cnpe.ventescabekotlin.shared.domain.vo.Image
import jakarta.persistence.*
import java.time.LocalDateTime

@Entity
@Table(
    name = "products",
    uniqueConstraints = [
        UniqueConstraint(name = "uk_product_sku", columnNames = ["sku"]),
        UniqueConstraint(name = "uk_product_barcode", columnNames = ["barcode"])
    ],
    indexes = [
        Index(name = "idx_product_sku", columnList = "sku"),
        Index(name = "idx_product_barcode", columnList = "barcode")
    ]
)
class Product(

    @Column(name = "name", nullable = false)
    var name: String,

    @Column(name = "sku", unique = true)
    var sku: String? = null,

    @Column(name = "barcode", unique = true, updatable = false)
    val barcode: String,

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    var status: ProductStatus = ProductStatus.DRAFT,

    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "product_images", joinColumns = [JoinColumn(name = "product_id")])
    @OrderColumn(name = "image_order")
    var photos: MutableList<Image> = mutableListOf(),

    @Column(name = "description", columnDefinition = "TEXT")
    var description: String? = null,

    @Column(name = "total_current_stock")
    var totalCurrentStock: Double = 0.0,

    @Column(name = "category_id", nullable = false)
    var categoryId: Long?,

    @Column(name = "brand_id", nullable = false)
    var brandId: Long?,

    @Column(name = "supplier_id", nullable = false)
    var supplierId: Long?,

    @OneToMany(
        mappedBy = "product",
        cascade = [CascadeType.ALL],
        orphanRemoval = true,
        fetch = FetchType.EAGER
    )
    @OrderBy("startDate DESC")
    val priceHistory: MutableSet<ProductPrice> = mutableSetOf(),


    id: Long? = null,
    version: Int = 0,
) : BaseEntity(id, version) {

    /**
     * Assigns the SKU if not already set. Prevents reassignment.
     * @throws DomainException if SKU is already assigned.
     */
    fun assignSku(skuToAssign: String) {
        require(skuToAssign.isNotBlank()) { "SKU cannot be blank" }
        if (this.sku != null) {
            throw DomainException(
                INVALID_STATE,
                details = mapOf("property" to "sku", "value" to skuToAssign, "reason" to "ALREADY_ASSIGNED"),
            )
        }
        this.sku = skuToAssign
    }

    /**
     * Adds a new price record to the product's history.
     * Automatically sets the end date of the previous current price.
     * @param price The new ProductPrice record (should have product link potentially unset).
     * @throws DomainException if the new price is invalid.
     */
    fun addPrice(price: ProductPrice) {
        price.validatePrices()

        getCurrentPrice()?.endDate = LocalDateTime.now()

        price.product = this
        this.priceHistory.add(price)
    }

    /**
     * Retrieves the currently active price record, if one exists.
     * Returns null if no price is currently active.
     */
    fun getCurrentPrice(): ProductPrice? {
        // Assumes @OrderBy("startDate DESC") keeps the latest start dates first
        return priceHistory.firstOrNull { it.isActive() }
    }

    /**
     * Validates if the product has the minimum required data to be activated.
     * Checks for positive prices, matching currencies, and assigned relationships.
     * @throws DomainException if validation fails.
     */
    fun validateCanActivate() {
        val currentPrice = getCurrentPrice()
            ?: throw DomainException(
                INVALID_STATE,
                details = mapOf("reason" to "MISSING_ACTIVE_PRICE"),
            )

        require(currentPrice.sellingPrice.isPositive()) { "Selling price must be positive for activation." }
        require(currentPrice.supplierCost.isPositive()) { "Supplier cost must be positive for activation." }

        require(categoryId != null) { "Product must have a category assigned for activation." }
        require(brandId != null) { "Product must have a brand assigned for activation." }
        require(supplierId != null) { "Product must have a supplier assigned for activation." }
        require(!sku.isNullOrBlank()) { "Product must have an SKU assigned for activation." }
    }

    /** Activates the product if validation passes. */
    fun activate() {
        validateCanActivate()
        this.status = ProductStatus.ACTIVE
    }

    /** Deactivates the product. */
    fun deactivate() {
        this.status = ProductStatus.INACTIVE
    }

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/domain/model/ProductPrice.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.domain.model

import dev.cnpe.ventescabekotlin.catalog.domain.enums.PriceChangeReason
import dev.cnpe.ventescabekotlin.currency.vo.Money
import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import jakarta.persistence.*
import java.math.BigDecimal
import java.math.RoundingMode
import java.time.LocalDateTime

@Entity
@Table(name = "product_prices")
class ProductPrice(

    @Embedded
    @AttributeOverrides(
        AttributeOverride(name = "amount", column = Column(name = "selling_price_amount", nullable = false)),
        AttributeOverride(
            name = "currencyCode",
            column = Column(name = "selling_price_currency", nullable = false, length = 3)
        )
    )
    val sellingPrice: Money,

    @Embedded
    @AttributeOverrides(
        AttributeOverride(name = "amount", column = Column(name = "cost_price_amount", nullable = false)),
        AttributeOverride(
            name = "currencyCode",
            column = Column(name = "cost_price_currency", nullable = false, length = 3)
        )
    )
    val supplierCost: Money,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    var product: Product,


    @Column(name = "start_date", nullable = false)
    val startDate: LocalDateTime = LocalDateTime.now(),

    @Column(name = "end_date")
    var endDate: LocalDateTime? = null,

    @Column(name = "reason", nullable = false)
    @Enumerated(EnumType.STRING)
    val reason: PriceChangeReason,

    id: Long? = null,
    version: Int = 0,
) : BaseEntity(id, version) {

    fun calculateProfit(): Money {
        sellingPrice.assertSameCurrency(supplierCost)
        return sellingPrice - supplierCost
    }

    fun calculateProfitMargin(): BigDecimal {
        sellingPrice.assertSameCurrency(supplierCost)
        if (supplierCost.isZero()) {
            return BigDecimal.ZERO
        }
        val profitAmount = calculateProfit().amount
        return profitAmount.divide(supplierCost.amount, 4, RoundingMode.HALF_UP)
            .multiply(BigDecimal(100))
    }

    fun isActive(): Boolean {
        val now = LocalDateTime.now()
        return !startDate.isAfter(now) && (endDate == null || endDate!!.isAfter(now))
    }

    fun validatePrices() {
        require(sellingPrice.isNonNegative()) { "Selling price must be non-negative" }
        require(supplierCost.isNonNegative()) { "Supplier cost must be non-negative" }
        sellingPrice.assertSameCurrency(supplierCost)
    }

    @PrePersist
    fun prePersist() {
        validatePrices()
    }

    @PreUpdate
    fun preUpdate() {
        validatePrices()
    }
}

================================================
File: dev/cnpe/ventescabekotlin/catalog/event/ProductCreatedEvent.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.event

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType

data class ProductCreatedEvent(
    val productId: Long,
    val unitType: StockUnitType
)


================================================
File: dev/cnpe/ventescabekotlin/catalog/infrastructure/persistence/ProductPriceRepository.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence

import dev.cnpe.ventescabekotlin.catalog.domain.model.ProductPrice
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query

interface ProductPriceRepository : JpaRepository<ProductPrice, Long> {


    @Query(
        value = """
            select pp from ProductPrice pp
            where pp.product.id = :productId
            order by pp.startDate desc
        """,
        countQuery = """
            select count(pp)
            from ProductPrice pp
            where pp.product.id = :productId
        """
    )
    fun getProductPriceHistory(productId: Long, pageable: Pageable): Page<ProductPrice>

}

================================================
File: dev/cnpe/ventescabekotlin/catalog/infrastructure/persistence/ProductRepository.kt
================================================
package dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence

import dev.cnpe.ventescabekotlin.catalog.domain.model.Product
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.JpaSpecificationExecutor
import org.springframework.data.jpa.repository.Query

interface ProductRepository : JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {

    fun existsByBarcode(barcode: String): Boolean

    fun existsByName(name: String): Boolean

    fun countAllByCategoryId(categoryId: Long): Long

    fun countAllBySupplierId(supplierId: Long): Long

    fun countAllByBrandId(brandId: Long): Long

    fun findByBarcode(barcode: String): Product?

    @Query(
        value = """
            select distinct p
            from Product p
            left join fetch p.priceHistory ph
            order by p.createdAt desc
        """,
        countQuery = """
            select count(p)
            from Product p
        """
    )
    fun findAllWithPriceHistory(pageable: Pageable): Page<Product>

}

================================================
File: dev/cnpe/ventescabekotlin/categories/application/api/CategoryInfoPort.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.api

/**
 * Port defining operations for retrieving basic Category information needed by other modules.
 */
interface CategoryInfoPort {
    /**
     * Retrieves the unique code of a category by its ID.
     *
     * @param categoryId The ID of the category.
     * @return The category code string.
     * @throws DomainException (e.g., RESOURCE_NOT_FOUND) if the category ID is invalid.
     */
    fun getCategoryCodeById(categoryId: Long): String

    /**
     * Retrieves the unique identifier of the default category configured for the tenant.
     *
     * @return The ID of the default category.
     * @throws DomainException (e.g., RESOURCE_NOT_FOUND) if no default category is configured or found.
     */
    fun getDefaultCategoryId(): Long
}

================================================
File: dev/cnpe/ventescabekotlin/categories/application/dto/request/CreateCategoryRequest.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import org.hibernate.validator.constraints.Length

@Schema(description = "Request payload for creating a new category.")
data class CreateCategoryRequest(

    @field:NotBlank(message = "Name must not be blank.")
    @field:Length(min = 2, max = 50, message = "Name must be between 2 and 50 characters.")
    @Schema(description = "Name of the category.", example = "Electronics", requiredMode = Schema.RequiredMode.REQUIRED)
    val name: String
)


================================================
File: dev/cnpe/ventescabekotlin/categories/application/dto/request/UpdateCategoryRequest.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.dto.request

import dev.cnpe.ventescabekotlin.shared.application.validation.NotBlankIfPresent
import io.swagger.v3.oas.annotations.media.Schema
import org.hibernate.validator.constraints.Length

@Schema(description = "Request payload for updating an existing category. All fields are optional.")
data class UpdateCategoryRequest(

    @field:NotBlankIfPresent
    @field:Length(min = 2, max = 50, message = "Name must be between 2 and 50 characters.")
    @Schema(
        description = "Updated name of the category.",
        example = "Consumer Electronics",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val name: String?,

    @field:NotBlankIfPresent
    @field:Length(max = 150, message = "Description must be at most 150 characters.")
    @Schema(
        description = "Updated description for the category.",
        example = "Devices and gadgets for everyday use.",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val description: String?,

    @field:NotBlankIfPresent
    @field:Length(max = 7, message = "Color must be at most 7 characters.")
    @Schema(
        description = "Updated color code for the category (e.g., hex format).",
        example = "#FF5733",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val color: String?

)


================================================
File: dev/cnpe/ventescabekotlin/categories/application/dto/response/CategoryCreatedResponse.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import java.time.OffsetDateTime

@Schema(description = "Response after successfully creating a category.")
data class CategoryCreatedResponse(

    @Schema(
        description = "ID of the newly created category.",
        example = "123",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val id: Long,

    @Schema(
        description = "Name of the created category.",
        example = "Electronics",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val name: String,

    @Schema(
        description = "Generated code for the created category.",
        example = "CAT-ELEC",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val code: String,

    @Schema(
        description = "Timestamp when the category was created.",
        format = "date-time",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val createdAt: OffsetDateTime

)


================================================
File: dev/cnpe/ventescabekotlin/categories/application/dto/response/CategoryDetailedResponse.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.dto.response

import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Complete detailed information about a category, including parent, children, and metadata.")
data class CategoryDetailedResponse(

    @Schema(
        description = "Unique identifier of the category.",
        example = "305",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val id: Long,

    @Schema(
        description = "Name of the category.",
        example = "Smartphones",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val name: String,

    @Schema(
        description = "Detailed description of the category.",
        example = "Mobile phones with advanced computing capabilities.",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val description: String?,

    @Schema(
        description = "Unique code assigned to the category.",
        example = "CAT-SMART",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val code: String,

    @Schema(
        description = "Color code associated with the category.",
        example = "#F0E68C",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val color: String,

    @Schema(
        description = "Indicates if this category has no parent.",
        example = "false",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isRootCategory: Boolean,

    @Schema(
        description = "Indicates if this is the default category.",
        example = "false",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isDefaultCategory: Boolean,

    @Schema(
        description = "Basic information about the parent category (null if root).",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val parent: CategorySummaryResponse?,

    @Schema(
        description = "Set of direct subcategories.",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val subcategories: Set<CategorySummaryResponse>,

    @Schema(
        description = "Number of products directly associated with this category.",
        example = "25",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val productCount: Long,

    @Schema(
        description = "Audit information.",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val auditData: ResourceAuditData
)


================================================
File: dev/cnpe/ventescabekotlin/categories/application/dto/response/CategorySummaryResponse.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Basic summary information for a category, suitable for lists.")
data class CategorySummaryResponse(

    @Schema(
        description = "Unique identifier of the category.",
        example = "101",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val id: Long,

    @Schema(description = "Name of the category.", example = "Groceries", requiredMode = Schema.RequiredMode.REQUIRED)
    val name: String,

    @Schema(
        description = "Unique code assigned to the category.",
        example = "CAT-GROC",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val code: String,

    @Schema(
        description = "Color code associated with the category.",
        example = "#33FF57",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val color: String,

    @Schema(
        description = "Indicates if this is the default category.",
        example = "false",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isDefault: Boolean,

    @Schema(
        description = "Number of products associated with this category.",
        example = "42",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val productCount: Long

)

================================================
File: dev/cnpe/ventescabekotlin/categories/application/dto/response/CategoryWithChildrenResponse.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Information about a category including its direct subcategories.")
data class CategoryWithChildrenResponse(

    @Schema(
        description = "Unique identifier of the category.",
        example = "201",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val id: Long,

    @Schema(
        description = "Name of the category.",
        example = "Clothing",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val name: String,

    @Schema(
        description = "Unique code assigned to the category.",
        example = "CAT-CLOTH",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val code: String,

    @Schema(
        description = "Color code associated with the category.",
        example = "#3357FF",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val color: String,

    @Schema(
        description = "Indicates if this category has no parent.",
        example = "true",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isRootCategory: Boolean,

    @Schema(
        description = "Indicates if this is the default category.",
        example = "false",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isDefaultCategory: Boolean,

    @Schema(
        description = "Number of products directly associated with this category.",
        example = "15",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val productCount: Long,

    @Schema(
        description = "Set of direct subcategories.",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val subcategories: Set<CategorySummaryResponse>
)


================================================
File: dev/cnpe/ventescabekotlin/categories/application/events/CategoryRelocatedEvent.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.events

data class CategoryRelocatedEvent(
    val categoryId: Long
)


================================================
File: dev/cnpe/ventescabekotlin/categories/application/events/DefaultCategoryCreatedEvent.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.events

data class DefaultCategoryCreatedEvent(
    val categoryId: Long
)


================================================
File: dev/cnpe/ventescabekotlin/categories/application/exception/CategoryOperationNotAllowedReason.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.OperationNotAllowedReason
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Reasons why a category operation is not allowed.")
enum class CategoryOperationNotAllowedReason: OperationNotAllowedReason {

    @Schema(description = "The category is the default category.")
    IS_DEFAULT_CATEGORY,

    @Schema(description = "The category has subcategories.")
    HAS_SUBCATEGORIES,

    @Schema(description = "Cannot add a subcategory to the default category.")
    ADD_SUBCATEGORY_TO_DEFAULT,

    @Schema(description = "The category has reached the maximum depth.")
    REACHED_MAX_DEPTH
}

================================================
File: dev/cnpe/ventescabekotlin/categories/application/mapper/CategoryMapper.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.mapper

import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryCreatedResponse
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryDetailedResponse
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategorySummaryResponse
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryWithChildrenResponse
import dev.cnpe.ventescabekotlin.categories.domain.model.Category
import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import org.springframework.stereotype.Component

@Component
class CategoryMapper {

    fun toSummary(category: Category, productCount: Long): CategorySummaryResponse {

        return CategorySummaryResponse(
            id = category.id!!,
            name = category.name,
            code = category.code.codeValue,
            color = category.color,
            isDefault = category.isDefault,
            productCount = productCount
        )
    }

    fun toDetailed(category: Category, productCount: Long): CategoryDetailedResponse {
        return CategoryDetailedResponse(
            id = category.id!!,
            name = category.name,
            code = category.code.codeValue,
            color = category.color,
            description = category.description,
            isRootCategory = category.isRootCategory(),
            isDefaultCategory = category.isDefault,
            parent = category.parent?.let { toSummary(it, productCount) },
            subcategories = category.subcategories.map { toSummary(it, productCount) }.toSet(),
            productCount = productCount,
            auditData = ResourceAuditData.fromBaseEntity(category)
        )

    }

    fun toCreated(category: Category): CategoryCreatedResponse {
        return CategoryCreatedResponse(
            id = category.id!!,
            name = category.name,
            code = category.code.codeValue,
            createdAt = category.createdAt
        )
    }

    fun toWithChildren(category: Category, productCount: Long): CategoryWithChildrenResponse {
        return CategoryWithChildrenResponse(
            id = category.id!!,
            name = category.name,
            code = category.code.codeValue,
            color = category.color,
            isRootCategory = category.isRootCategory(),
            isDefaultCategory = category.isDefault,
            productCount = productCount,
            subcategories = category.subcategories.map { toSummary(it, productCount) }.toSet()
        )
    }
}

================================================
File: dev/cnpe/ventescabekotlin/categories/application/service/CategoryService.kt
================================================
package dev.cnpe.ventescabekotlin.categories.application.service

import dev.cnpe.ventescabekotlin.categories.application.dto.request.CreateCategoryRequest
import dev.cnpe.ventescabekotlin.categories.application.dto.request.UpdateCategoryRequest
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryCreatedResponse
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryDetailedResponse
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryWithChildrenResponse
import dev.cnpe.ventescabekotlin.categories.application.events.CategoryRelocatedEvent
import dev.cnpe.ventescabekotlin.categories.application.exception.CategoryOperationNotAllowedReason.*
import dev.cnpe.ventescabekotlin.categories.application.mapper.CategoryMapper
import dev.cnpe.ventescabekotlin.categories.domain.factory.CategoryFactory
import dev.cnpe.ventescabekotlin.categories.domain.model.Category
import dev.cnpe.ventescabekotlin.categories.infrastructure.CategoryRepository
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescabekotlin.shared.application.exception.createOperationNotAllowedException
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import dev.cnpe.ventescabekotlin.shared.application.service.CodeGeneratorService
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.ApplicationEventPublisher
import org.springframework.data.repository.findByIdOrNull
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private const val MAX_CATEGORY_DEPTH: Int = 2
private val log = KotlinLogging.logger {}

@Service
@Transactional
class CategoryService(
    private val categoryRepository: CategoryRepository,
    private val categoryMapper: CategoryMapper,
    private val categoryFactory: CategoryFactory,
    private val eventPublisher: ApplicationEventPublisher,
    private val codeGeneratorService: CodeGeneratorService
) {

    // *******************************
    // 🔰 Category Management
    // *******************************

    /**
     * Retrieves detailed information about a category, including a count of associated products.
     *
     * @param id the unique identifier of the category to retrieve
     * @return a detailed response object containing category information and product count
     * @throws DomainException if the specified category does not exist or is a default category.
     */
    @Transactional(readOnly = true)
    fun getCategoryDetails(id: Long): CategoryDetailedResponse {
        val category = findCategoryByIdOrThrow(id)
        val productCount = 666L // TODO: Replace with productInfoPort.countProductsByCategoryId(id)
//        val productCount: Long = productInfoPort.countProductsByCategoryId(id)

        return categoryMapper.toDetailed(category, productCount)
    }

    /**
     * Deletes a category by its unique identifier. Before deletion, this method validates whether
     * the category is eligible for removal and handles the relocation of any associated products
     * to another category. If the specified category has subcategories or is a default category,
     * deletion is not allowed.
     *
     * @param id the unique identifier of the category to be deleted
     * @throws DomainException if the specified category is a default category or has subcategories.
     */
    fun deleteCategory(id: Long) {
        log.debug { "Attempting to delete category for ID: $id" }
        val category = findCategoryByIdOrThrow(id)

        validateDeletion(category)
        relocateProducts(category)


        log.info { "Deleting category: ${category.name} (ID: ${category.id})" }
        categoryRepository.delete(category)
        log.info { "Deleted category: ${category.name} (ID: ${category.id})" }
    }

    /**
     * Creates a new category based on the provided request data.
     *
     * @param request the request containing the details necessary to create a new category
     * @return the response containing the details of the newly created category
     * @throws DomainException if a category with the same name already exists or the provided request is invalid.
     */
    fun createCategory(request: CreateCategoryRequest): CategoryCreatedResponse {
        log.debug { "Attempting to create category: ${request.name}" }
        validateCategory(request)

        val newCategory = categoryFactory.create(request.name)
        val created = categoryRepository.save(newCategory)
        log.info { "Created category: ${created.name} (ID: ${created.id})" }

        return categoryMapper.toCreated(created)
    }

    /**
     * Updates an existing category with the provided details.
     *
     * @param id The unique identifier of the category to be updated.
     * @param request The data used to update the category, encapsulated in an UpdateCategoryRequest object.
     * @return A detailed response object containing updated category information.
     * @throws DomainException If the provided request is invalid, or if the category with the specified ID does not exist.
     */
    fun updateCategory(id: Long, request: UpdateCategoryRequest): CategoryDetailedResponse {
        log.debug { "Attempting to update category for ID: $id with data: $request" }
        val category = findCategoryByIdOrThrow(id)
        val productCount = 0L // TODO

        updateCategoryFromRequest(category, request)
        val updatedCategory = categoryRepository.save(category)
        log.info { "Updated category: ${updatedCategory.name} (ID: ${updatedCategory.id})" }
        return categoryMapper.toDetailed(updatedCategory, productCount)

    }

    /**
     * Adds a subcategory to an existing parent category.
     *
     * @param request The request object containing the details of the subcategory to be created.
     * @param parentId The ID of the parent category under which the subcategory will be added.
     * @return A response object containing details of the created subcategory.
     * @throws DomainException If the specified parent category does not exist, the provided request is invalid, or if the category already has a subcategory with the same name.
     */
    fun addSubcategory(request: CreateCategoryRequest, parentId: Long): CategoryCreatedResponse {
        log.debug { "Attempting to add subcategory: ${request.name} to parent ID: $parentId" }
        val parent = findCategoryByIdOrThrow(parentId)

        validateParentCategory(parent)
        validateCategoryDepth(parent)
        validateCategory(request)

        val subcategory = categoryFactory.createSubcategory(request.name, parent)
        val savedSubcategory = categoryRepository.save(subcategory)

        log.info { "Created subcategory: ${savedSubcategory.name} (ID: ${savedSubcategory.id}) under parent ${parent.name}" }
        return categoryMapper.toCreated(savedSubcategory)
    }

    /**
     * Fetches all parent categories along with their child categories.
     *
     * @return a list of categories with their respective children.
     */
    @Transactional(readOnly = true)
    fun getAllCategories(): List<CategoryWithChildrenResponse> {
        log.debug { "Fetching all categories" }
        val productCount = 0L // TODO: Replace with productInfoPort calls
        return categoryRepository.findAllParentCategories().map { categoryMapper.toWithChildren(it, productCount) }
    }


    // *******************************
    // 🔰 Private Helpers
    // *******************************

    private fun findCategoryByIdOrThrow(id: Long): Category {
        log.debug { "Fetching category details for ID: $id" }
        return categoryRepository.findByIdOrNull(id)
            ?: throw createResourceNotFoundException("Category", id)
    }

    private fun validateParentCategory(parent: Category) {
        if (parent.isDefault) {
            throw createOperationNotAllowedException(
                reason = ADD_SUBCATEGORY_TO_DEFAULT,
                entityId = parent.id!!,
                additionalDetails = mapOf("parentName" to parent.name)
            )
        }
    }

    private fun updateCategoryFromRequest(category: Category, request: UpdateCategoryRequest) {
        request.name?.let { newName ->
            if (category.name != newName && categoryRepository.existsByName(newName)) {
                throw createDuplicatedResourceException("name", request.name)
            }
            category.name = newName
            category.updateCode(codeGeneratorService.generateCode(newName))
            log.trace { "Updated category ID ${category.id} name to '$newName' and regenerated code" }
        }
        request.description?.let { category.description = it }
        request.color?.let { newColor ->
            // TODO: Optionally update children colors recursively? Requires loading children.
            // category.subcategories.forEach { child -> child.color = categoryFactory.generateSubcategoryColor(newColor) }
            log.trace { "Updated category ID ${category.id} color to '$newColor'" }
        }
    }


    private fun relocateProducts(category: Category) {
        val defaultCategory = (categoryRepository.getDefaultCategory()
            ?: throw IllegalStateException("Default category not found during product relocation"))

        val targetCategoryId = if (category.isRootCategory()) {
            defaultCategory.id!!
        } else {
            category.parent!!.id!!
        }
        log.info {
            "Relocating products from category ${category.name} " +
                    "(ID: ${category.id}) to category ${defaultCategory.name} " +
                    "(ID: ${defaultCategory.id}) before deletion"
        }
        eventPublisher.publishEvent(CategoryRelocatedEvent(targetCategoryId))
    }

    private fun validateCategoryDepth(parent: Category) {
        var depth = 0
        var current: Category? = parent
        while (current != null) {
            current = current.parent
            depth++
        }

        val resultingDepth = depth + 1

        if (resultingDepth > MAX_CATEGORY_DEPTH) {
            throw createOperationNotAllowedException(
                reason = REACHED_MAX_DEPTH,
                entityId = parent.id!!,
                additionalDetails = mapOf(
                    "maxAllowedDepth" to MAX_CATEGORY_DEPTH,
                    "attemptedDepth" to resultingDepth,
                    "parentName" to parent.name,
                )
            )
        }
    }

    private fun validateDeletion(category: Category) {
        if (category.isDefault) {
            throw createOperationNotAllowedException(
                reason = IS_DEFAULT_CATEGORY,
                entityId = category.id!!,
                additionalDetails = mapOf("categoryName" to category.name)
            )
        }

        // TODO: Add check using ProductInfoPort
        // val productCount = productInfoPort.countProductsByCategoryId(category.id!!)
        // if (productCount > 0) {
        //     throw DomainException(OPERATION_NOT_ALLOWED, "Cannot delete category with associated products ($productCount)")
        // }
        if (category.subcategories.isNotEmpty()) {
            throw createOperationNotAllowedException(
                reason = HAS_SUBCATEGORIES,
                entityId = category.id!!,
                additionalDetails = mapOf(
                    "categoryName" to category.name,
                    "subCategoryCount" to category.subcategories.size
                )
            )
        }
    }

    private fun validateCategory(request: CreateCategoryRequest) {
        if (categoryRepository.existsByName(request.name)) {
            throw createDuplicatedResourceException("name", request.name)
        }
    }

}

================================================
File: dev/cnpe/ventescabekotlin/categories/domain/factory/CategoryFactory.kt
================================================
package dev.cnpe.ventescabekotlin.categories.domain.factory

import dev.cnpe.ventescabekotlin.categories.domain.model.Category
import dev.cnpe.ventescabekotlin.categories.infrastructure.CategoryRepository
import dev.cnpe.ventescabekotlin.shared.application.service.CodeGeneratorService
import dev.cnpe.ventescabekotlin.shared.domain.vo.GeneratedCode
import org.springframework.stereotype.Component
import java.awt.Color
import kotlin.math.max
import kotlin.math.min
import kotlin.random.Random

private const val DEFAULT_CATEGORY_COLOR = "607d8b"

@Component
class CategoryFactory(
    private val codeGeneratorService: CodeGeneratorService,
    private val categoryRepository: CategoryRepository
) {

    fun create(name: String): Category {
        val sanitized = name.replaceFirstChar { it.titlecase() }.trim()
        val uniqueCode = ensureUniqueCode(codeGeneratorService.generateCode(sanitized))

        return Category(
            name = sanitized,
            color = generateHexColor(),
            code = GeneratedCode(uniqueCode)
        )
    }

    fun createSubcategory(name: String, parent: Category): Category {
        val sanitized = name.replaceFirstChar { it.titlecase() }.trim()

        val uniqueSubCode = ensureUniqueCode(codeGeneratorService.generateCode(sanitized))
        val fullCode = "${parent.code.codeValue}-$uniqueSubCode"
        val color = generateSubcategoryColor(parent.color)

        val newSubcategory = Category(
            name = sanitized,
            color = color,
            parent = parent,
            code = GeneratedCode(fullCode)
        )
        parent.addSubcategory(newSubcategory)
        return newSubcategory
    }

    fun createDefault(name: String): Category {
        val code = codeGeneratorService.generateCode(name)

        return Category(
            name = name,
            color = DEFAULT_CATEGORY_COLOR,
            code = GeneratedCode(code),
            isDefault = true
        )
    }

    private fun generateHexColor(): String {
        val hue = Random.nextFloat()
        val saturation = 0.4f
        val brightness = 0.8f

        val color = Color.getHSBColor(hue, saturation, brightness)
        return String.format("#%06X", color.rgb and 0xFFFFFF)
    }

    private fun generateSubcategoryColor(parentColorHex: String): String {
        return try {
            val parentColor = Color.decode(parentColorHex)
            val hsbValues = Color.RGBtoHSB(parentColor.red, parentColor.green, parentColor.blue, null)

            val brightnessDelta = Random.nextDouble(0.05, 0.20).toFloat()

            val newBrightness = min(hsbValues[2] + brightnessDelta, 0.95f)
            val newColor = Color.getHSBColor(hsbValues[0], hsbValues[1], newBrightness)
            String.format("#%06X", newColor.rgb and 0xFFFFFF)
        } catch (e: NumberFormatException) {
            generateHexColor()
        }
    }

    private fun ensureUniqueCode(baseCode: String): String {
        var currentCode = baseCode
        var suffix = 1
        val maxAttempts = 36

        while (categoryRepository.existsByCode(GeneratedCode(currentCode)) && suffix <= maxAttempts) {
            val codeRoot = baseCode.take(max(0, CodeGeneratorService.CODE_LENGTH - 1))
            currentCode = if (suffix <= 9) {
                codeRoot + suffix
            } else {
                codeRoot + ('A'.code + (suffix - 10)).toChar()
            }
            suffix++
        }
        if (suffix > maxAttempts) {
            //Consider generating a random code?
            throw IllegalStateException("Unable to generate unique code for category with base code $baseCode")
        }
        return currentCode
    }

}




================================================
File: dev/cnpe/ventescabekotlin/categories/domain/model/Category.kt
================================================
package dev.cnpe.ventescabekotlin.categories.domain.model

import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import dev.cnpe.ventescabekotlin.shared.domain.vo.GeneratedCode
import jakarta.persistence.*

@Entity
@Table(name = "categories")
class Category(

    @Column(name = "name", nullable = false, unique = true)
    var name: String,

    @Column(name = "color", nullable = false, length = 7)
    var color: String,

    @Column(name = "description")
    var description: String? = null,

    @Column(name = "is_default", nullable = false)
    var isDefault: Boolean = false,

    @Embedded
    var code: GeneratedCode,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    var parent: Category? = null,

    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY, cascade = [CascadeType.PERSIST, CascadeType.MERGE])
    var subcategories: MutableSet<Category> = mutableSetOf(),

    id: Long? = null,
    version: Int = 0
) : BaseEntity(id, version) {

    fun updateCode(newCodeValue: String) {
        this.code = GeneratedCode(newCodeValue)
    }

    fun addSubcategory(child: Category) {
        child.parent = this
        this.subcategories.add(child)
    }

    fun removeChild(child: Category) {
        child.parent = null
        this.subcategories.remove(child)
    }

    fun assignParent(parent: Category) {
        this.parent = parent
        parent.addSubcategory(this)
    }

    fun isRootCategory(): Boolean {
        return this.parent == null
    }
}

================================================
File: dev/cnpe/ventescabekotlin/categories/infrastructure/CategoryRepository.kt
================================================
package dev.cnpe.ventescabekotlin.categories.infrastructure

import dev.cnpe.ventescabekotlin.categories.domain.model.Category
import dev.cnpe.ventescabekotlin.shared.domain.vo.GeneratedCode
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query

interface CategoryRepository : JpaRepository<Category, Long> {


    @Query(
        """
        select c
        from Category c
        left join fetch c.subcategories
        where c.parent is null
        """
    )
    fun findAllParentCategories(): List<Category>

    @Query(
        """
        select c 
        from Category c
        where c.isDefault = true
        """
    )
    fun getDefaultCategory(): Category?

    @Query(
        """
        select c.code.codeValue
        from Category c
        where c.id = :categoryId
        """
    )
    fun getCategoryCodeById(categoryId: Long): String?

    fun existsByCode(code: GeneratedCode): Boolean

    fun existsByName(name: String): Boolean
}

================================================
File: dev/cnpe/ventescabekotlin/categories/infrastructure/web/CategoryController.kt
================================================
package dev.cnpe.ventescabekotlin.categories.infrastructure.web

import dev.cnpe.ventescabekotlin.categories.application.dto.request.CreateCategoryRequest
import dev.cnpe.ventescabekotlin.categories.application.dto.request.UpdateCategoryRequest
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryCreatedResponse
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryDetailedResponse
import dev.cnpe.ventescabekotlin.categories.application.dto.response.CategoryWithChildrenResponse
import dev.cnpe.ventescabekotlin.categories.application.service.CategoryService
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.net.URI

@RestController
@RequestMapping("/categories")
@Tag(name = "Categories", description = "Manage categories in the business.")
class CategoryController(
    private val categoryService: CategoryService
) {

    @PostMapping
    @Operation(summary = "Create a new category", description = "Creates a new category in the business.")
    @ApiResponse(
        responseCode = "201",
        description = "Category created successfully",
        content = [Content(
            mediaType = "application/json",
            schema = Schema(implementation = CategoryCreatedResponse::class)
        )]
    )
    @ApiResponse(
        responseCode = "409",
        description = "Invalid input (e.g., duplicate name)"
    )
    fun createCategory(@RequestBody @Valid request: CreateCategoryRequest): ResponseEntity<CategoryCreatedResponse> {
        val created = categoryService.createCategory(request)
        return ResponseEntity.created(URI.create("/brands/${created.id}")).body(created)
    }

    @PostMapping("/{parentId}/subcategories")
    @Operation(summary = "Create a subcategory", description = "Adds a subcategory to an existing category.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "Subcategory created successfully",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = CategoryCreatedResponse::class)
                )]
            ),
            ApiResponse(responseCode = "409", description = "Invalid input (e.g., duplicate name)"),
            ApiResponse(responseCode = "404", description = "Parent category not found"),
            ApiResponse(responseCode = "405", description = "Cannot add subcategory to default category"),
            ApiResponse(responseCode = "405", description = "Maximum depth reached")
        ]
    )
    fun addSubcategory(
        @PathVariable(name = "parentId") parentId: Long,
        @RequestBody @Valid request: CreateCategoryRequest
    ): ResponseEntity<CategoryCreatedResponse> {

        val createdSubcategory = categoryService.addSubcategory(request, parentId)

        return ResponseEntity
            .created(URI.create("/categories/${createdSubcategory.id}"))
            .body(createdSubcategory)
    }

    @GetMapping
    @Operation(summary = "Get all categories", description = "Retrieves a list of all categories in the business.")
    @ApiResponse(
        responseCode = "200",
        description = "List of categories retrieved successfully",
        content = [
            Content(
                mediaType = "application/json",
                schema = Schema(implementation = CategoryWithChildrenResponse::class, type = "array")
            )
        ]
    )
    fun getAllCategories(): List<CategoryWithChildrenResponse> {
        return categoryService.getAllCategories()
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get category by ID", description = "Retrieves a single category by its unique identifier.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Category retrieved successfully",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = CategoryDetailedResponse::class)
                )]
            ),
            ApiResponse(responseCode = "404", description = "Category not found")
        ]
    )
    fun getCategoryById(@PathVariable(name = "id") id: Long): CategoryDetailedResponse {
        return categoryService.getCategoryDetails(id)
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @Operation(summary = "Delete category by ID", description = "Deletes a single category by its unique identifier.")
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "204", description = "Category deleted successfully"),
            ApiResponse(responseCode = "404", description = "Category not found")
        ]
    )
    fun deleteCategoryById(@PathVariable(name = "id") id: Long) {
        categoryService.deleteCategory(id)
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update category by ID", description = "Updates a single category by its unique identifier.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Category updated successfully",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = CategoryDetailedResponse::class)
                )]
            ),
            ApiResponse(responseCode = "404", description = "Category not found"),
            ApiResponse(responseCode = "409", description = "Invalid input (e.g., duplicate name)")
        ]
    )
    fun updateCategory(
        @PathVariable(name = "id") id: Long,
        @RequestBody @Valid request: UpdateCategoryRequest
    ): CategoryDetailedResponse {
        return categoryService.updateCategory(id, request)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/config/MessageSourceConfig.kt
================================================
package dev.cnpe.ventescabekotlin.config

import org.springframework.context.MessageSource
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.support.ReloadableResourceBundleMessageSource
import org.springframework.web.servlet.LocaleResolver
import org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver
import java.util.*

@Configuration
class MessageSourceConfig {

    @Bean
    fun messageSource(): MessageSource {
        return ReloadableResourceBundleMessageSource().apply {
            setBasenames(
                "classpath:messages/errors",
                "classpath:messages/enums",
                "classpath:messages/defaults"
            )
            setDefaultEncoding("UTF-8")
            setUseCodeAsDefaultMessage(true)
        }
    }

    @Bean
    fun localeResolver(): LocaleResolver {
        return AcceptHeaderLocaleResolver().apply {
            supportedLocales = listOf(Locale.ENGLISH, Locale.of("es"))
            setDefaultLocale(Locale.of("es"))
        }
    }

}

================================================
File: dev/cnpe/ventescabekotlin/config/PersistenceAuditConfig.kt
================================================
package dev.cnpe.ventescabekotlin.config

import dev.cnpe.ventescabekotlin.security.context.UserContext
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.auditing.DateTimeProvider
import org.springframework.data.domain.AuditorAware
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import org.springframework.security.authentication.AnonymousAuthenticationToken
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken
import java.time.OffsetDateTime
import java.util.*

private val log = KotlinLogging.logger {}

@Configuration
@EnableJpaAuditing(
    auditorAwareRef = "auditorProvider",
    dateTimeProviderRef = "auditingDateTimeProvider"
)
class PersistenceAuditConfig {

    companion object {
        const val SYSTEM_AUDITOR = "VENTESCA_SYS" // System user for non-request contexts
    }

    /**
     * Provides the identifier of the current user for auditing purposes.
     * Attempts to retrieve from UserContext (request scope), falls back to SecurityContextHolder,
     * and defaults to SYSTEM_AUDITOR if no authenticated user is found.
     */
    @Bean("auditorProvider")
    fun auditorProvider(
        userContext: UserContext?
    ): AuditorAware<String> {
        return AuditorAware<String> {
            val auditor = userContext?.preferredUsername
                ?: getAuditorFromSecurityContext()
                ?: SYSTEM_AUDITOR
            log.trace { "Auditor resolved to: $auditor" }
            Optional.of(auditor)
        }
    }

    /**
     * Fallback function to get auditor from SecurityContextHolder.
     * Needed for contexts where request-scoped UserContext might not be available.
     */
    private fun getAuditorFromSecurityContext(): String? {
        return SecurityContextHolder.getContext().authentication?.let { auth ->
            if (auth.isAuthenticated && auth !is AnonymousAuthenticationToken) {
                (auth as? JwtAuthenticationToken)?.token?.getClaimAsString("preferred_username")
                    ?: auth.name
            } else null
        }
    }

    /**
     * Provides the current date and time for auditing purposes.
     * Ensures OffsetDateTime is used consistently.
     */
    @Bean("auditingDateTimeProvider")
    fun dateTimeProvider(): DateTimeProvider {
        return DateTimeProvider { Optional.of(OffsetDateTime.now()) }
    }


}

================================================
File: dev/cnpe/ventescabekotlin/config/SecurityConfig.kt
================================================
package dev.cnpe.ventescabekotlin.config

import dev.cnpe.ventescabekotlin.security.TenantAuthenticationFilter
import dev.cnpe.ventescabekotlin.security.filters.UserContextPopulationFilter
import dev.cnpe.ventescabekotlin.shared.infrastructure.web.filters.MDCLoggingFilter
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.annotation.web.invoke
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.oauth2.server.resource.web.authentication.BearerTokenAuthenticationFilter
import org.springframework.security.web.SecurityFilterChain

@Configuration
@EnableWebSecurity
class SecurityConfig(
    private val tenantAuthenticationFilter: TenantAuthenticationFilter,
    private val userContextPopulationFilter: UserContextPopulationFilter,
    private val mdcLoggingFilter: MDCLoggingFilter
) {

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            authorizeHttpRequests {
                authorize("/v3/api-docs/**", permitAll)
                authorize("/swagger-ui.html", permitAll)
                authorize("/swagger-ui/**", permitAll)
                authorize("/favicon.ico", permitAll)
                authorize(anyRequest, authenticated)
            }
            sessionManagement {
                sessionCreationPolicy = SessionCreationPolicy.STATELESS
            }
            cors { disable() }
            csrf { disable() }
            oauth2ResourceServer { jwt { } }
            addFilterAfter<BearerTokenAuthenticationFilter>(tenantAuthenticationFilter)
            addFilterAfter<TenantAuthenticationFilter>(userContextPopulationFilter)
            addFilterAfter<UserContextPopulationFilter>(mdcLoggingFilter)
        }
        return http.build()
    }
}

================================================
File: dev/cnpe/ventescabekotlin/config/jpa/BaseJpaConfig.kt
================================================
package dev.cnpe.ventescabekotlin.config.jpa

import org.springframework.orm.jpa.vendor.Database
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter

/**
 * Base configuration class providing common helper methods for JPA setup.
 */
abstract class BaseJpaConfig {

    companion object {
        private const val HIBERNATE_HBM2DDL_AUTO = "hibernate.hbm2ddl.auto"
        private const val HIBERNATE_SHOW_SQL = "hibernate.show_sql"
        private const val HIBERNATE_FORMAT_SQL = "hibernate.format_sql"
        private const val HIBERNATE_NAMING_STRATEGY = "hibernate.physical_naming_strategy"
        private const val CAMEL_CASE_TO_UNDERSCORES_STRATEGY =
            "org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy"
        private const val HBM2DDL_NONE = "none"
//        private const val POSTGRESQL_DIALECT = "org.hibernate.dialect.PostgreSQLDialect"
    }


    /**
     * Creates a basic HibernateJpaVendorAdapter configured for PostgreSQL.
     *
     * @param showSql Whether to enable logging of generated SQL statements.
     * @return A configured HibernateJpaVendorAdapter instance.
     */
    protected fun createHibernateAdapter(showSql: Boolean): HibernateJpaVendorAdapter {
        val adapter = HibernateJpaVendorAdapter()

        // using the old java bean approach/ do not change
        adapter.setDatabase(Database.POSTGRESQL)
        adapter.setShowSql(showSql)
        return adapter
    }

    /**
     * Creates a base map of common Hibernate properties.
     *
     * @param showSql Whether to enable SQL logging properties.
     * @return A mutable map containing base Hibernate properties.
     */
    protected fun getBaseHibernateProperties(showSql: Boolean): MutableMap<String, Any> {
        return mutableMapOf(
            HIBERNATE_HBM2DDL_AUTO to HBM2DDL_NONE,
            // HIBERNATE_DIALECT to POSTGRESQL_DIALECT,
            HIBERNATE_SHOW_SQL to showSql,
            HIBERNATE_FORMAT_SQL to showSql,
            HIBERNATE_NAMING_STRATEGY to CAMEL_CASE_TO_UNDERSCORES_STRATEGY
        )
    }
}

================================================
File: dev/cnpe/ventescabekotlin/config/jpa/MasterJpaConfig.kt
================================================
package dev.cnpe.ventescabekotlin.config.jpa

import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessRepository
import dev.cnpe.ventescabekotlin.currency.infrastructure.persistence.CurrencyRepository
import jakarta.persistence.EntityManagerFactory
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.orm.jpa.JpaTransactionManager
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.support.TransactionTemplate
import javax.sql.DataSource

@Configuration
@EnableJpaRepositories(
    basePackageClasses = [
        BusinessRepository::class,
        CurrencyRepository::class
    ],
    entityManagerFactoryRef = "masterEntityManagerFactory",
    transactionManagerRef = "masterTransactionManager"
)
class MasterJpaConfig : BaseJpaConfig() {

    @Value("\${app.hibernate.debug:false}")
    private val showSql: Boolean = false


    /**
     * Configures the EntityManagerFactory for the master database.
     */
    @Bean("masterEntityManagerFactory")
    fun masterEntityManagerFactory(
        @Qualifier("masterDataSource") masterDataSource: DataSource
    ): LocalContainerEntityManagerFactoryBean {

        val em = LocalContainerEntityManagerFactoryBean()
        em.dataSource = masterDataSource

        em.setPackagesToScan(
            "dev.cnpe.ventescabekotlin.business.domain",
            "dev.cnpe.ventescabekotlin.currency.domain"
        )

        em.jpaVendorAdapter = createHibernateAdapter(showSql)
        val properties = getBaseHibernateProperties(showSql)

        em.setJpaPropertyMap(properties)

        return em
    }

    /**
     * Configures the TransactionManager for the master database.
     */
    @Bean("masterTransactionManager")
    fun masterTransactionManager(
        @Qualifier("masterEntityManagerFactory") entityManagerFactory: EntityManagerFactory
    ): PlatformTransactionManager {
        return JpaTransactionManager(entityManagerFactory)
    }

    @Bean("masterTransactionTemplate")
    fun masterTransactionTemplate(
        @Qualifier("masterTransactionManager") transactionManager: PlatformTransactionManager
    ): TransactionTemplate {
        return TransactionTemplate(transactionManager)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/config/jpa/TenantJpaConfig.kt
================================================
package dev.cnpe.ventescabekotlin.config.jpa

import dev.cnpe.ventescabekotlin.brands.infrastructure.BrandRepository
import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessRepository
import dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence.ProductPriceRepository
import dev.cnpe.ventescabekotlin.catalog.infrastructure.persistence.ProductRepository
import dev.cnpe.ventescabekotlin.categories.infrastructure.CategoryRepository
import dev.cnpe.ventescabekotlin.currency.infrastructure.persistence.CurrencyRepository
import dev.cnpe.ventescabekotlin.inventory.infrastructure.persistence.InventoryItemRepository
import dev.cnpe.ventescabekotlin.suppliers.infrastructure.persistence.SupplierRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.persistence.EntityManagerFactory
import org.hibernate.context.spi.CurrentTenantIdentifierResolver
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.*
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.orm.jpa.JpaTransactionManager
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean
import org.springframework.transaction.PlatformTransactionManager
import javax.sql.DataSource

private val log = KotlinLogging.logger {}

@Configuration
@EnableJpaRepositories(
    basePackages = [
        "org.springframework.modulith.events.jpa" // for modulith event publication repo
    ],
    basePackageClasses = [
        BrandRepository::class,
        CategoryRepository::class,
        SupplierRepository::class,
        ProductRepository::class,
        ProductPriceRepository::class,
        InventoryItemRepository::class
    ],
    excludeFilters = [
        ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = [
                BusinessRepository::class,
                CurrencyRepository::class
            ]
        )
    ],
    entityManagerFactoryRef = "entityManagerFactory",
    transactionManagerRef = "transactionManager"
)
class TenantJpaConfig : BaseJpaConfig() {

    @Value("\${app.hibernate.debug:false}")
    private val showSql: Boolean = false

    companion object {
        // Constants for Hibernate multi-tenancy properties
        private const val HIBERNATE_MULTI_TENANCY = "hibernate.multiTenancy"
        private const val HIBERNATE_TENANT_RESOLVER = "hibernate.tenant_identifier_resolver"
        private const val HIBERNATE_CONNECTION_PROVIDER = "hibernate.multi_tenant_connection_provider"
        private const val MULTI_TENANCY_STRATEGY_DATABASE = "DATABASE"
    }

    /**
     * Configures the primary EntityManagerFactory for tenant databases.
     * This EMF is responsible for entities in modules like brands, categories, catalog, etc.
     */
    @Primary
    @Bean("entityManagerFactory")
    fun entityManagerFactory(
        dataSource: DataSource, // primary DS, it should be the routing one

        @Qualifier("multiTenantDbConnectionProvider")
        multiTenantConnectionProvider: MultiTenantConnectionProvider<String>,

        @Qualifier("tenantSchemaResolver")
        tenantIdentifierResolver: CurrentTenantIdentifierResolver<String>
    ): LocalContainerEntityManagerFactoryBean {
        log.info { "Configuring primary EntityManagerFactory for multi-tenancy..." }
        val em = LocalContainerEntityManagerFactoryBean()
        em.dataSource = dataSource

        em.setPackagesToScan(
            "dev.cnpe.ventescabekotlin.brands.domain",
            "dev.cnpe.ventescabekotlin.categories.domain",
            "dev.cnpe.ventescabekotlin.suppliers.domain",
            "dev.cnpe.ventescabekotlin.catalog.domain.model",
            "dev.cnpe.ventescabekotlin.inventory.domain",
            "dev.cnpe.ventescabekotlin.shared.domain",
            "org.springframework.modulith.events.jpa"
            // Add ALL packages containing entities managed by the tenant EMF
            // Ensure these DO NOT include master-only entities (like Business, Currency)
        )

        em.jpaVendorAdapter = createHibernateAdapter(showSql)

        val properties = getBaseHibernateProperties(showSql)
        properties[HIBERNATE_MULTI_TENANCY] = MULTI_TENANCY_STRATEGY_DATABASE
        properties[HIBERNATE_TENANT_RESOLVER] = tenantIdentifierResolver
        properties[HIBERNATE_CONNECTION_PROVIDER] = multiTenantConnectionProvider

        em.setJpaPropertyMap(properties)

        log.info { "Primary EntityManagerFactory configured with multi-tenancy strategy: DATABASE" }
        return em
    }

    /**
     * Configures the primary PlatformTransactionManager for tenant databases.
     */
    @Primary
    @Bean("transactionManager")
    fun transactionManager(
        entityManagerFactory: EntityManagerFactory
    ): PlatformTransactionManager {
        return JpaTransactionManager(entityManagerFactory)
    }
}

================================================
File: dev/cnpe/ventescabekotlin/currency/config/CurrencyInitializer.kt
================================================
package dev.cnpe.ventescabekotlin.currency.config

import dev.cnpe.ventescabekotlin.currency.domain.model.Currency
import dev.cnpe.ventescabekotlin.currency.infrastructure.persistence.CurrencyRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.boot.CommandLineRunner
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.core.annotation.Order
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

/**
 * Configuration class responsible for initializing necessary currency data on application startup.
 */
@Configuration
class CurrencyInitializer {

    /**
     * Creates a CommandLineRunner bean that initializes default currencies if none exist.
     * Using CommandLineRunner ensures this runs after the context is loaded.
     *
     * @param currencyRepository The repository for currency data access.
     * @return A CommandLineRunner bean.
     */
    @Bean
    @Order(10)
    fun initializeCurrenciesRunner(currencyRepository: CurrencyRepository): CommandLineRunner {
        return CommandLineRunner {
            log.info { "Checking for existing currencies..." }
            initializeDefaultCurrency(currencyRepository)
        }
    }

    @Transactional
    internal fun initializeDefaultCurrency(currencyRepository: CurrencyRepository) {
        if (currencyRepository.count() == 0L) {
            log.info { "No currencies found. Initializing default currencies..." }

            val clp = Currency(
                code = "CLP",
                name = "Chilean Peso",
                symbol = "$",
                scale = 0,
                isActive = true
            )

            val currenciesToInitialize = listOf(clp)
            currencyRepository.saveAll(currenciesToInitialize)
            log.info { "✅💲 ${currenciesToInitialize.size} default currencies initialized. {${currenciesToInitialize.joinToString { it.code }}}" }
        } else {
            log.info { "Currencies already exist in database (${currencyRepository.count()} found). Skipping initialization." }
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/currency/domain/model/Currency.kt
================================================
package dev.cnpe.ventescabekotlin.currency.domain.model

import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Table

@Entity
@Table(name = "supported_currencies")
class Currency( // Removed open - handled by @Entity

    @Column(name = "code", nullable = false, unique = true, length = 3)
    var code: String,

    @Column(name = "name", nullable = false)
    var name: String,

    @Column(name = "symbol", nullable = false)
    var symbol: String,

    @Column(name = "scale", nullable = false)
    var scale: Int,

    @Column(name = "is_active", nullable = false)
    var isActive: Boolean,

    id: Long? = null,
    version: Int = 0

) : BaseEntity(id, version)

================================================
File: dev/cnpe/ventescabekotlin/currency/exception/CurrencyNotFoundException.kt
================================================
package dev.cnpe.ventescabekotlin.currency.exception

/**
 * Exception thrown when an operation requires a currency that is not
 * supported, not active, or cannot be found in the system.
 */
class CurrencyNotFoundException(
    val currencyCode: String
) : RuntimeException("Currency not supported or not active: $currencyCode")

================================================
File: dev/cnpe/ventescabekotlin/currency/infrastructure/persistence/CurrencyRepository.kt
================================================
package dev.cnpe.ventescabekotlin.currency.infrastructure.persistence

import dev.cnpe.ventescabekotlin.currency.domain.model.Currency
import org.springframework.data.jpa.repository.JpaRepository

interface CurrencyRepository : JpaRepository<Currency, Long> {

    fun findByCodeAndIsActiveTrue(code: String): Currency?

    fun existsByCodeAndIsActiveTrue(code: String): Boolean
}

================================================
File: dev/cnpe/ventescabekotlin/currency/service/MoneyFactory.kt
================================================
package dev.cnpe.ventescabekotlin.currency.service

import dev.cnpe.ventescabekotlin.currency.domain.model.Currency
import dev.cnpe.ventescabekotlin.currency.exception.CurrencyNotFoundException
import dev.cnpe.ventescabekotlin.currency.infrastructure.persistence.CurrencyRepository
import dev.cnpe.ventescabekotlin.currency.vo.Money
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.stereotype.Component
import java.math.BigDecimal
import java.math.RoundingMode
import java.text.NumberFormat
import java.util.*


/**
 * Factory service for creating and formatting Money value objects.
 * Ensures created Money instances use supported and active currency codes
 * and applies correct scaling based on currency definition.
 */
@Component
class MoneyFactory(
    private val currencyRepository: CurrencyRepository
) {

    /**
     * Creates a Money instance for the given amount and currency code.
     * Validates that the currency code is supported and active.
     * Applies the correct scale (number of decimal places) for the currency.
     *
     * @param amount The monetary amount.
     * @param currencyCode The 3-letter ISO 4217 currency code.
     * @return A validated Money instance.
     * @throws CurrencyNotFoundException if the currency code is not supported or inactive.
     */
    fun createMoney(amount: BigDecimal, currencyCode: String): Money {
        val currency = findActiveCurrencyOrThrow(currencyCode)

        val scaledAmount = amount.setScale(currency.scale, RoundingMode.HALF_EVEN)
        return Money(scaledAmount, currency.code)
    }

    /**
     * Creates a Money instance with zero amount for the given currency code.
     * Validates the currency code.
     *
     * @param currencyCode The 3-letter ISO 4217 currency code.
     * @return A Money instance representing zero value in the specified currency.
     * @throws CurrencyNotFoundException if the currency code is not supported or inactive.
     */
    fun zero(currencyCode: String): Money {
        val currency = findActiveCurrencyOrThrow(currencyCode)
        val zeroAmount = BigDecimal.ZERO.setScale(currency.scale, RoundingMode.HALF_UP)
        return Money(zeroAmount, currency.code)
    }

    /**
     * Formats a Money object into a human-readable string using locale-specific conventions
     * and the currency's symbol and scale.
     *
     * @param money The Money object to format.
     * @param locale The locale to use for formatting (defaults to current request locale).
     * @return A formatted string representation (e.g., "$ 1,234.50", "¥1,000").
     * @throws CurrencyNotFoundException if the money's currency code is invalid (should not happen if created via factory).
     */
    fun format(money: Money, locale: Locale = LocaleContextHolder.getLocale()): String {
        val currency = findActiveCurrencyOrThrow(money.currencyCode)

        // NumberFormat for locale-aware currency formatting
        val currencyFormat = NumberFormat.getCurrencyInstance(locale)

        val currencyInstance = java.util.Currency.getInstance(money.currencyCode)
        currencyFormat.currency = currencyInstance

        currencyFormat.minimumFractionDigits = currency.scale
        currencyFormat.maximumFractionDigits = currency.scale

        return currencyFormat.format(money.amount)
    }

    /**
     * Finds an active currency by code or throws CurrencyNotFoundException
     * */
    private fun findActiveCurrencyOrThrow(currencyCode: String): Currency {
        require(currencyCode.length == 3 && currencyCode.all { it.isUpperCase() }) {
            "Invalid currency code format: '$currencyCode'. Must be 3 uppercase letters."
        }
        return currencyRepository.findByCodeAndIsActiveTrue(currencyCode)
            ?: throw CurrencyNotFoundException(currencyCode)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/currency/vo/Money.kt
================================================
package dev.cnpe.ventescabekotlin.currency.vo

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import java.math.BigDecimal

@Schema(description = "Represents a monetary value with an associated currency code.")
@Embeddable
data class Money(
    @Schema(description = "The monetary amount.", required = true, example = "199.99")
    @Column(name = "amount", nullable = false)
    val amount: BigDecimal,

    @Schema(description = "The 3-letter ISO 4217 currency code.", required = true, example = "USD")
    @Column(name = "currency_code", nullable = false, length = 3)
    val currencyCode: String
) : Comparable<Money> {

    fun isNegative(): Boolean = amount < BigDecimal.ZERO
    fun isPositive(): Boolean = amount > BigDecimal.ZERO
    fun isZero(): Boolean = amount.compareTo(BigDecimal.ZERO) == 0
    fun isNonNegative(): Boolean = amount >= BigDecimal.ZERO

    /** Adds another Money value (must have same currency). */
    operator fun plus(other: Money): Money {
        assertSameCurrency(other)
        return this.copy(amount = this.amount + other.amount)
    }

    /** Subtracts another Money value (must have same currency). */
    operator fun minus(other: Money): Money {
        assertSameCurrency(other)
        return this.copy(amount = this.amount - other.amount)
    }

    /** Multiplies the amount by a BigDecimal multiplier. */
    operator fun times(multiplier: BigDecimal): Money {
        return this.copy(amount = this.amount.multiply(multiplier))
    }

    /** Multiplies the amount by an Int multiplier. */
    operator fun times(multiplier: Int): Money {
        return this * multiplier.toBigDecimal()
    }

    /** Multiplies the amount by a Double multiplier (use with caution due to potential precision issues). */
    operator fun times(multiplier: Double): Money {
        return this * BigDecimal.valueOf(multiplier)
    }

    /** Negates the monetary amount. */
    operator fun unaryMinus(): Money {
        return this.copy(amount = this.amount.negate())
    }

    /** Compares this Money object with another based on amount (must have same currency). */
    override fun compareTo(other: Money): Int {
        assertSameCurrency(other)
        return this.amount.compareTo(other.amount)
    }

    /** Ensures the other Money object has the same currency code. Throws IllegalArgumentException if not. */
    fun assertSameCurrency(other: Money) {
        require(this.currencyCode == other.currencyCode) {
            "Currency mismatch: Cannot operate on Money values with different currencies (${this.currencyCode} vs ${other.currencyCode})"
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/inventory/application/api/InventoryInfoPort.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.application.api

import dev.cnpe.ventescabekotlin.inventory.application.api.dto.BranchInventoryDetails
import dev.cnpe.ventescabekotlin.inventory.application.api.dto.ProductInventorySummary

/**
 * Port defining operations for retrieving essential inventory information needed by other modules.
 */
interface InventoryInfoPort {

    /**
     * Retrieves an aggregated inventory summary for a product across all branches.
     * Provides total stock and representative unit/min quantity.
     *
     * @param productId The ID of the product.
     * @return ProductInventorySummary containing aggregated stock details.
     * @throws DomainException if the product is not found or has no inventory items.
     */
    fun getInventorySummary(productId: Long): ProductInventorySummary

    /**
     * Retrieves detailed inventory information for a specific product within a specific branch.
     *
     * @param productId The ID of the product.
     * @param branchId The ID of the branch.
     * @return BranchInventoryDetails containing specific stock details for that item.
     * @throws DomainException if the inventory item for the product/branch combination is not found.
     */
    fun getBranchInventoryDetails(productId: Long, branchId: Long): BranchInventoryDetails
}


================================================
File: dev/cnpe/ventescabekotlin/inventory/application/api/dto/BranchInventoryDetails.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.application.api.dto

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Detailed inventory status for a specific product in a specific branch.")
data class BranchInventoryDetails(

    @Schema(description = "Product ID", example = "123")
    val productId: Long,

    @Schema(description = "Branch ID", example = "101")
    val branchId: Long,

    @Schema(description = "Current quantity in this specific branch.", example = "12.0")
    val currentQuantity: Double,

    @Schema(description = "Minimum quantity configured for this branch.", example = "5.0")
    val minQuantity: Double,

    @Schema(description = "Unit of measure.", example = "UNIT")
    val unitOfMeasure: StockUnitType,

    @Schema(description = "Indicates if stock is low (at or below minimum) in this branch.")
    val isLowStock: Boolean,

    @Schema(description = "Indicates if stock is zero in this branch.")
    val isOutOfStock: Boolean,

    @Schema(description = "Quantity available above the minimum level in this branch.", example = "7.0")
    val availableQuantity: Double,

    @Schema(description = "Indicates if the stock level suggests a restock is needed for this branch.")
    val needsRestock: Boolean
)


================================================
File: dev/cnpe/ventescabekotlin/inventory/application/api/dto/ProductInventorySummary.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.application.api.dto

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Aggregated inventory summary for a product across all branches.")
data class ProductInventorySummary(

    @Schema(description = "Total current stock quantity across all locations.", example = "25.0")
    val totalStockQuantity: Double,

    @Schema(
        description = "Representative minimum required quantity. Aggregation rule depends on implementation (e.g., first branch's value, average, null if inconsistent). Check service implementation details.",
        example = "10.0",
        nullable = true // nullable as aggregation rule is unclear
    )
    val representativeMinimumQuantity: Double?,

    @Schema(
        description = "Unit of measure for the item (assumed consistent across branches).",
        example = "UNIT"
    )
    val unitOfMeasure: StockUnitType
)

================================================
File: dev/cnpe/ventescabekotlin/inventory/application/dto/request/UpdateStockRequest.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.application.dto.request

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockModificationReason
import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Min
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Positive

@Schema(description = "Request to update stock details for a specific product in a specific branch.")
data class UpdateStockRequest(

    @field:NotNull(message = "Stock quantity must be provided.")
    @field:Min(value = 0, message = "Stock quantity cannot be negative.")
    @Schema(
        description = "The new absolute stock quantity for the item in this branch.",
        example = "15.0",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val stockQuantity: Double,

    @field:NotNull(message = "Minimum stock level must be provided.")
    @field:Min(value = 0, message = "Minimum stock level cannot be negative.")
    @Schema(
        description = "The new minimum stock level for the item in this branch.",
        example = "5.0",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val minimumStockLevel: Double,

    @field:NotNull(message = "Unit of measure must be provided.")
    @Schema(
        description = "The unit of measure for the stock.",
        example = "UNIT",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val unitOfMeasure: StockUnitType,

    @field:NotNull(message = "Branch ID must be provided.")
    @field:Positive(message = "Branch ID must be a positive number.")
    @Schema(
        description = "The ID of the branch where the stock is being updated.",
        example = "101",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val branchId: Long,

    @Schema(description = "Reason for the stock modification (required if quantity changes).", example = "RESTOCK")
    val reason: StockModificationReason?
)

================================================
File: dev/cnpe/ventescabekotlin/inventory/application/service/InventoryInfoService.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.application.service

import dev.cnpe.ventescabekotlin.inventory.application.api.InventoryInfoPort
import dev.cnpe.ventescabekotlin.inventory.application.api.dto.BranchInventoryDetails
import dev.cnpe.ventescabekotlin.inventory.application.api.dto.ProductInventorySummary
import dev.cnpe.ventescabekotlin.inventory.infrastructure.persistence.InventoryItemRepository
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
@Transactional(readOnly = true)
class InventoryInfoService(
    private val inventoryItemRepository: InventoryItemRepository
) : InventoryInfoPort {

    /**
     * Retrieves aggregated inventory information for a product across all branches.
     * Sums the quantities. Assumes minimum quantity and unit are consistent across branches,
     * taking the values from the first retrieved item.
     */
    override fun getInventorySummary(productId: Long): ProductInventorySummary {
        log.debug { "Fetching aggregated inventory info for Product ID: $productId" }
        val items = inventoryItemRepository.findAllByProductId(productId)

        if (items.isEmpty()) {
            log.warn { "No inventory items found for Product ID: $productId during summary aggregation." }
            throw createResourceNotFoundException(
                entityType = "InventoryItem",
                id = productId
            )
        }

        val totalStock = inventoryItemRepository.calculateTotalStockForProduct(productId)

        val firstItemStock = items.first().stock
        val representativeMinQuantity = firstItemStock.minimumQuantity
        val representativeUnit = firstItemStock.unit

        val distinctUnits = items.map { it.stock.unit }.distinct()
        if (distinctUnits.size > 1) {
            log.warn {
                "Inconsistent stock units found for Product ID: $productId across branches: $distinctUnits. " +
                        "Using unit from first item found: $representativeUnit."
            }
        }

        val distinctMinQuantities = items.map { it.stock.minimumQuantity }.distinct()
        if (distinctMinQuantities.size > 1) {
            log.warn {
                "Inconsistent minimum quantities found for Product ID: $productId across branches: $distinctMinQuantities. " +
                        "Using minimum quantity from first item found: $representativeMinQuantity."
            }
        }

        log.debug { "Aggregated inventory info for Product ID: $productId - TotalStock: $totalStock, Representative MinQty: $representativeMinQuantity, Representative Unit: $representativeUnit" }
        return ProductInventorySummary(
            totalStockQuantity = totalStock,
            representativeMinimumQuantity = representativeMinQuantity,
            unitOfMeasure = representativeUnit
        )
    }


    /**
     * Retrieves detailed inventory information for a specific product within a specific branch.
     */
    override fun getBranchInventoryDetails(
        productId: Long,
        branchId: Long
    ): BranchInventoryDetails {
        log.debug { "Fetching branch inventory details for Product ID: $productId, Branch ID: $branchId" }
        val item = inventoryItemRepository.findByProductIdAndBranchId(productId, branchId)
            ?: throw DomainException(
                errorCode = GeneralErrorCode.RESOURCE_NOT_FOUND,
                details = mapOf("productId" to productId, "branchId" to branchId)
            )
        val stock = item.stock

        return BranchInventoryDetails(
            productId = item.productId,
            branchId = item.branchId,
            currentQuantity = stock.quantity,
            minQuantity = stock.minimumQuantity,
            unitOfMeasure = stock.unit,
            isLowStock = stock.isLowStock,
            isOutOfStock = stock.isOutOfStock,
            availableQuantity = stock.availableQuantity,
            needsRestock = stock.needsRestock
        )
    }
}

================================================
File: dev/cnpe/ventescabekotlin/inventory/application/service/InventoryManagementService.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.application.service

import dev.cnpe.ventescabekotlin.business.application.api.BusinessDataPort
import dev.cnpe.ventescabekotlin.catalog.event.ProductCreatedEvent
import dev.cnpe.ventescabekotlin.inventory.application.dto.request.UpdateStockRequest
import dev.cnpe.ventescabekotlin.inventory.application.dto.response.InventoryItemDetailsResponse
import dev.cnpe.ventescabekotlin.inventory.domain.entity.InventoryItem
import dev.cnpe.ventescabekotlin.inventory.domain.entity.StockModification
import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockModificationType
import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import dev.cnpe.ventescabekotlin.inventory.domain.vo.Stock
import dev.cnpe.ventescabekotlin.inventory.event.StockUpdatedEvent
import dev.cnpe.ventescabekotlin.inventory.infrastructure.persistence.InventoryItemRepository
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.ApplicationEventPublisher
import org.springframework.context.MessageSource
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.modulith.events.ApplicationModuleListener
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import kotlin.math.abs
import kotlin.math.round

private val log = KotlinLogging.logger {}

@Service
@Transactional
class InventoryManagementService(
    private val inventoryItemRepository: InventoryItemRepository,
    private val businessDataPort: BusinessDataPort,
    private val eventPublisher: ApplicationEventPublisher,
    private val messageSource: MessageSource
) {

    /**
     * Updates the stock for a specific product in a specific branch.
     *
     * @param productId The ID of the product to update.
     * @param request The details of the stock update.
     * @throws DomainException if data is invalid (e.g., reason missing, item not found).
     */
    fun updateStock(productId: Long, request: UpdateStockRequest) {
        log.debug { "Attempting stock update for Product ID: $productId in Branch ID: ${request.branchId}" }

        val item = findInventoryItemOrThrow(productId, request.branchId)
        val originalStock = item.stock

        val currentQuantity = originalStock.quantity
        var newQuantity = request.stockQuantity
        val quantityChanged = currentQuantity != newQuantity

        if (quantityChanged && request.reason == null) {
            throw DomainException(GeneralErrorCode.INVALID_DATA, details = mapOf("reason" to "REASON_NOT_PROVIDED"))
        }

        if (quantityChanged) {
            val reason = request.reason!!
            var difference = newQuantity - currentQuantity


            if (request.unitOfMeasure == StockUnitType.UNIT) {
                newQuantity = round(newQuantity)
                val roundedCurrentQuantity = round(currentQuantity)

                if (roundedCurrentQuantity != currentQuantity) {
                    difference = newQuantity - roundedCurrentQuantity
                }
            }

            if (difference != 0.0) {
                val modification = StockModification(
                    amount = abs(difference),
                    type = if (difference > 0) StockModificationType.INCREASE else StockModificationType.DECREASE,
                    reason = reason,
                    item = item,
                )
                item.addStockModification(modification)
                log.info {
                    "Added StockModification: Type=${modification.type}, Amount=${modification.amount}, " +
                            "Reason=${modification.reason} for Product ID $productId / Branch ${request.branchId}"
                }
            } else {
                log.info {
                    "Stock quantity difference is zero after rounding for Product ID $productId / Branch ${request.branchId}." +
                            " No modification recorded."
                }
            }
        }
        val newStockVO = Stock(
            quantity = newQuantity,
            minimumQuantity = request.minimumStockLevel,
            unit = request.unitOfMeasure
        )

        if (originalStock.unit != newStockVO.unit) {
            log.warn {
                "Stock unit change detected for Product ID $productId from" +
                        " ${originalStock.unit} to ${newStockVO.unit}. Updating all related items."
            }
            updateStockUnitForAllItemsOfProduct(productId, newStockVO.unit)
            item.stock = newStockVO
        } else {
            item.stock = newStockVO
        }

        inventoryItemRepository.save(item)
        log.info { "Saved updated InventoryItem for Product ID $productId / Branch ${request.branchId}. New Stock: ${item.stock}" }

        val totalStockQuantity = inventoryItemRepository.calculateTotalStockForProduct(productId)
        eventPublisher.publishEvent(StockUpdatedEvent(productId, totalStockQuantity))
        log.info { "Published StockUpdatedEvent for Product ID $productId. New Total Stock: $totalStockQuantity" }
    }

    @ApplicationModuleListener
    fun onProductCreated(event: ProductCreatedEvent) {
        log.info { "Received ProductCreatedEvent for Product ID: ${event.productId}, Unit: ${event.unitType}. Creating initial inventory items..." }

        val branchIds = try {
            businessDataPort.getBusinessBranchIds()
        } catch (e: Exception) {
            log.error(e) { "Failed to retrieve branch IDs while handling ProductCreatedEvent for Product ID ${event.productId}. Cannot create inventory items." }
            return
        }

        if (branchIds.isEmpty()) {
            log.warn { "No branches found for the business when creating inventory items for Product ID ${event.productId}. This might indicate an issue or a new business with no branches yet." }
            return
        }
        log.debug { "Found ${branchIds.size} branches. Creating InventoryItem for Product ID ${event.productId} in each." }

        val inventoryItems = branchIds.map { branchId ->
            InventoryItem.forNewProduct(
                productId = event.productId,
                branchId = branchId,
                unitType = event.unitType
            )
        }

        try {
            val savedItems = inventoryItemRepository.saveAll(inventoryItems)
            log.info { "🌿 Created ${savedItems.size} Inventory Items for Product ID ${event.productId} across ${branchIds.size} branch(es)." }
        } catch (e: Exception) {
            log.error(e) { "Failed to save initial inventory items for Product ID ${event.productId}." }
        }
    }

    // FIXME: Implement branch deletion logic listener if needed
    // @ApplicationModuleListener
    // fun onBranchDeleted(event: BranchDeletedEvent) { ... }


    // *******************************
    // 🔰 Private Helpers
    // *******************************



    private fun updateStockUnitForAllItemsOfProduct(productId: Long, newUnit: StockUnitType) {
        val itemsToUpdate = inventoryItemRepository.findAllByProductId(productId)
        var count = 0
        itemsToUpdate.forEach { item ->
            if (item.stock.unit != newUnit) {
                item.stock = item.stock.changeUnit(newUnit)
//                inventoryItemRepository.saveAll(itemsToUpdate)
                count++
            }
        }
        if (count > 0) {
            inventoryItemRepository.saveAll(itemsToUpdate)
            log.info { "Updated stock unit to [$newUnit] for $count inventory items of Product ID [$productId]" }
        } else {
            log.debug { "No stock units needed updating for Product ID [$productId] to [$newUnit]" }
        }
    }


    private fun findInventoryItemOrThrow(productId: Long, branchId: Long): InventoryItem {
        return inventoryItemRepository.findByProductIdAndBranchId(productId, branchId)
            ?: throw DomainException(
                errorCode = GeneralErrorCode.RESOURCE_NOT_FOUND,
                details = mapOf("productId" to productId, "branchId" to branchId)
            )
    }


}

================================================
File: dev/cnpe/ventescabekotlin/inventory/domain/entity/InventoryItem.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.domain.entity

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import dev.cnpe.ventescabekotlin.inventory.domain.vo.Stock
import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import jakarta.persistence.*

@Entity
@Table(
    name = "inventory_items",
    indexes = [
        Index(name = "idx_invitem_product_branch", columnList = "product_id, branch_id", unique = true),
        Index(name = "idx_invitem_product_id", columnList = "product_id"),
        Index(name = "idx_invitem_branch_id", columnList = "branch_id")
    ]
)
class InventoryItem(
    @Column(name = "branch_id", nullable = false, updatable = false)
    val branchId: Long,

    @Column(name = "product_id", nullable = false, updatable = false)
    val productId: Long,


    @Embedded
    @AttributeOverrides(
        AttributeOverride(name = "quantity", column = Column(name = "stock_quantity")),
        AttributeOverride(name = "minimumQuantity", column = Column(name = "minimum_stock_level")),
        AttributeOverride(name = "unit", column = Column(name = "unit_of_measure"))
    )
    var stock: Stock,

    @OneToMany(mappedBy = "item", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    val stockModifications: MutableSet<StockModification> = mutableSetOf(),

    id: Long? = null,
    version: Int = 0
) : BaseEntity(id, version) {

    companion object {
        /**
         * Factory method to create an InventoryItem for a newly created product in a specific branch.
         * Initializes stock with defaults based on the product's unit type.
         */
        fun forNewProduct(productId: Long, branchId: Long, unitType: StockUnitType): InventoryItem {
            require(productId > 0) { "Product ID must be positive" }
            require(branchId > 0) { "Branch ID must be positive" }

            return InventoryItem(
                branchId = branchId,
                productId = productId,
                stock = Stock.withDefaultsFor(unitType),
                stockModifications = mutableSetOf()
            )
        }
    }

    fun addStockModification(modification: StockModification) {
        requireNotNull(modification) { "Stock modification cannot be null" }
        modification.item = this
        stockModifications.add(modification)
    }
    val currentQuantity: Double
        get() = stock.quantity

}

================================================
File: dev/cnpe/ventescabekotlin/inventory/domain/entity/StockModification.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.domain.entity

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockModificationReason
import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockModificationType
import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.FetchType
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.PrePersist
import jakarta.persistence.PreUpdate
import jakarta.persistence.Table

@Entity
@Table(name = "stock_modifications")
class StockModification(


    @Column(name = "amount", nullable = false)
    var amount: Double,

    @Column(name = "type", nullable = false)
    @Enumerated(EnumType.STRING)
    var type: StockModificationType,

    @Column(name = "reason", nullable = false)
    @Enumerated(EnumType.STRING)
    var reason: StockModificationReason,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "item_id", nullable = false)
    var item: InventoryItem? = null,

    id: Long? = null,
    version: Int = 0

) : BaseEntity(id, version) {

    @PrePersist
    @PreUpdate
    private fun validateItemAssociation() {
        requireNotNull(item) { "StockModification must be associated with an InventoryItem" }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/inventory/domain/enums/StockModificationReason.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.domain.enums

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Reason for modifying the stock quantity.")
enum class StockModificationReason : DomainEnum {

    @Schema(description = "Initial stock quantity for a newly registered product.")
    INITIAL,

    @Schema(description = "Stock reduction due to product sale.")
    SALE,

    @Schema(description = "Stock increase due to customer product return.")
    RETURN,

    @Schema(description = "Stock reduction due to returning products to the supplier.")
    VENDOR_RETURN,

    @Schema(description = "Stock reduction due to lost products.")
    LOST,

    @Schema(description = "Stock reduction due to damaged or defective products.")
    DAMAGED,

    @Schema(description = "Stock increase due to product replenishment.")
    RESTOCK,

    @Schema(description = "Manual stock adjustment due to inventory errors.")
    CORRECTION,

    @Schema(description = "Stock modification for an unspecified reason.")
    OTHER
}

================================================
File: dev/cnpe/ventescabekotlin/inventory/domain/enums/StockModificationType.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.domain.enums

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Type of stock modification (increase or decrease).")
enum class StockModificationType : DomainEnum {

    @Schema(description = "Increase in available stock quantity.")
    INCREASE,

    @Schema(description = "Decrease in available stock quantity.")
    DECREASE
}

================================================
File: dev/cnpe/ventescabekotlin/inventory/domain/enums/StockUnitType.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.domain.enums

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum


import io.swagger.v3.oas.annotations.media.Schema

/**
 * Represents the available unit types for measuring and tracking stock quantities in the inventory system.
 */
@Schema(
    description = "Available unit types for measuring and tracking stock quantities",
//    enumAsRef = false
)
enum class StockUnitType : DomainEnum {

    @Schema(description = "Individual units or pieces")
    UNIT,

    @Schema(description = "Weight measurement in kilograms")
    KILOGRAM,

    @Schema(description = "Volume measurement in liters")
    LITER
    
}

================================================
File: dev/cnpe/ventescabekotlin/inventory/domain/vo/Stock.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.domain.vo

import dev.cnpe.ventescabekotlin.inventory.domain.enums.StockUnitType
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated

@Schema(description = "Represents stock quantity, minimum level, and unit of measure.")
@Embeddable
data class Stock(

    @Schema(description = "Current quantity in stock.", example = "10.0")
    @Column(name = "quantity", nullable = false)
    val quantity: Double,

    @Schema(description = "Minimum desired stock level.", example = "5.0")
    @Column(name = "minimum_quantity", nullable = false)
    val minimumQuantity: Double,

    @Schema(description = "Unit of measure for the stock.", example = "UNIT")
    @Enumerated(EnumType.STRING)
    @Column(name = "unit_of_measure", nullable = false)
    val unit: StockUnitType
) {
    init {
        validate()
    }

    companion object {
        private const val NEEDS_RESTOCK_THRESHOLD_FACTOR = 1.5

        fun withDefaults(): Stock = Stock(0.0, 0.0, StockUnitType.UNIT)
        fun withDefaultsFor(unitType: StockUnitType): Stock = Stock(0.0, 0.0, unitType)
    }

    private fun validate() {
        require(quantity >= 0) { "Stock quantity cannot be negative" }
        require(minimumQuantity >= 0) { "Minimum stock level cannot be negative" }
    }

    @get:Schema(description = "True if current quantity is at or below the minimum level.")
    val isLowStock: Boolean
        get() = quantity <= minimumQuantity

    @get:Schema(description = "True if current quantity is exactly zero.")
    val isOutOfStock: Boolean
        get() = quantity == 0.0

    @get:Schema(description = "Calculated available quantity (current - minimum, minimum 0).")
    val availableQuantity: Double
        get() = (quantity - minimumQuantity).coerceAtLeast(0.0)

    @get:Schema(description = "True if current quantity is below 1.5 times the minimum level.")
    val needsRestock: Boolean
        get() = minimumQuantity > 0 && quantity < minimumQuantity * NEEDS_RESTOCK_THRESHOLD_FACTOR


    /** Returns a new Stock instance with the added quantity. */
    fun addQuantity(amount: Double): Stock {
        require(amount >= 0) { "Cannot add negative quantity" }
        return this.copy(quantity = this.quantity + amount)
    }

    /** Returns a new Stock instance with the removed quantity. */
    fun removeQuantity(amount: Double): Stock {
        require(amount >= 0) { "Cannot remove negative quantity" }
        require(amount <= quantity) { "Insufficient stock to remove $amount (available: $quantity)" }
        return this.copy(quantity = this.quantity - amount)
    }

    /** Returns a new Stock instance with the updated minimum quantity. */
    fun updateMinimumQuantity(newMinimum: Double): Stock {
        require(newMinimum >= 0) { "Minimum quantity cannot be negative" }
        return this.copy(minimumQuantity = newMinimum)
    }

    /** Returns a new Stock instance with the changed unit of measure. */
    fun changeUnit(newUnit: StockUnitType): Stock {
        return this.copy(unit = newUnit)
    }

    /** Checks if the current stock can fulfill the requested order quantity. */
    fun canFulfillOrder(orderQuantity: Double): Boolean {
        require(orderQuantity > 0) { "Order quantity must be positive" }
        return orderQuantity <= quantity
    }

    /**
     * Calculates the current stock level as a percentage of a target quantity.
     * Returns 0.0 if targetQuantity is null or non-positive. Caps at 100.0.
     */
    fun getStockPercentage(targetQuantity: Double?): Double {
        if (targetQuantity == null || targetQuantity <= 0) {
            return 0.0
        }
        val percentage = (quantity / targetQuantity) * 100.0
        return percentage.coerceIn(0.0, 100.0)
    }
}


================================================
File: dev/cnpe/ventescabekotlin/inventory/event/StockUpdatedEvent.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.event

data class StockUpdatedEvent(
    val productId: Long,
    val totalStockQuantity: Double
)


================================================
File: dev/cnpe/ventescabekotlin/inventory/infrastructure/persistence/InventoryItemRepository.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.infrastructure.persistence

import dev.cnpe.ventescabekotlin.inventory.domain.entity.InventoryItem
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query

interface InventoryItemRepository : JpaRepository<InventoryItem, Long> {


    fun findByProductIdAndBranchId(productId: Long, branchId: Long): InventoryItem?

    fun findAllByProductId(productId: Long): List<InventoryItem>

    fun findAllByBranchId(branchId: Long): List<InventoryItem>

    @Query(
        """
        select coalesce(sum(i.stock.quantity), 0.0)
        from InventoryItem i
        where i.productId = :productId
        """
    )
    fun calculateTotalStockForProduct(productId: Long): Double


}

================================================
File: dev/cnpe/ventescabekotlin/inventory/infrastructure/web/InventoryController.kt
================================================
package dev.cnpe.ventescabekotlin.inventory.infrastructure.web

import dev.cnpe.ventescabekotlin.inventory.application.api.InventoryInfoPort
import dev.cnpe.ventescabekotlin.inventory.application.api.dto.BranchInventoryDetails
import dev.cnpe.ventescabekotlin.inventory.application.dto.request.UpdateStockRequest
import dev.cnpe.ventescabekotlin.inventory.application.service.InventoryManagementService
import dev.cnpe.ventescabekotlin.shared.application.dto.ApiResult
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/inventory")
@Tag(name = "Inventory", description = "Manage product stock levels per branch.")
class InventoryController(
    private val inventoryManagementService: InventoryManagementService,
    private val inventoryInfoPort: InventoryInfoPort
) {


    @GetMapping("/{productId}/branch/{branchId}")
    @Operation(
        summary = "Get inventory details for a product in a specific branch",
        description = "Retrieves current stock quantity, minimum levels, and status for a product within a single specified branch."
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200", description = "Inventory details retrieved successfully.",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = BranchInventoryDetails::class)
                )]
            ),
            ApiResponse(
                responseCode = "404", description = "Inventory item not found for the given product and branch.",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
            //TODO  Add 401, 403
        ]
    )
    fun getInventoryDetailsForProductInBranch(
        @Parameter(description = "ID of the product") @PathVariable productId: Long,
        @Parameter(description = "ID of the branch") @PathVariable branchId: Long
    ): BranchInventoryDetails {
        return inventoryInfoPort.getBranchInventoryDetails(productId, branchId)
    }

    @PutMapping("/{productId}/stock")
    @Operation(
        summary = "Update stock for a product in a specific branch",
        description = "Sets the absolute stock quantity and minimum level for a product in the branch specified within the request body. Records the reason for the change."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "204", description = "Stock updated successfully."),
            ApiResponse(
                responseCode = "400", description = "Invalid input data (e.g., missing fields, negative values).",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "404", description = "Inventory item not found for the given product and branch.",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
            // TODO: Add 401, 403
        ]
    )
    @ResponseStatus(HttpStatus.NO_CONTENT)
    fun updateStock(
        @Parameter(description = "ID of the product") @PathVariable productId: Long,
        @Valid @RequestBody request: UpdateStockRequest
    ) {
        inventoryManagementService.updateStock(productId, request)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/security/TenantAuthenticationFilter.kt
================================================
package dev.cnpe.ventescabekotlin.security

import dev.cnpe.ventescabekotlin.business.application.api.BusinessDataPort
import dev.cnpe.ventescabekotlin.tenant.TenantContext
import dev.cnpe.ventescabekotlin.tenant.exception.TenantNotFoundException
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.servlet.FilterChain
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter

private val log = KotlinLogging.logger {}

@Component
class TenantAuthenticationFilter(
    private val businessDataPort: BusinessDataPort
) : OncePerRequestFilter() {

    companion object {
        private val EXCLUDED_PATHS = listOf(
            "/admin/",
            "/dev/",
            "/v3/api-docs/",
            "/swagger-ui"
        )
    }

    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        var tenantIdSet: String? = null

        try {
            val authentication = SecurityContextHolder.getContext().authentication

            if (authentication != null && authentication.isAuthenticated && authentication is JwtAuthenticationToken) {
                val idpUserId = authentication.token.subject

                if (idpUserId.isNullOrBlank()) {
                    log.warn { "Authenticated user token is missing 'sub' claim. Cannot resolve tenant." }
                    throw TenantNotFoundException(identifierTried = "sub_claim_missing")
                } else {
                    log.debug { "Attempting to resolve tenant for user IdP ID: $idpUserId for path ${request.servletPath}" }
                    val tenantId = businessDataPort.getTenantIdForUser(idpUserId)

                    if (tenantId != null) {
                        log.info { "🟢 Tenant resolved for user IdP ID '$idpUserId'. Setting tenant context to: [$tenantId]" }
                        TenantContext.setCurrentTenant(tenantId)
                        tenantIdSet = tenantId
                    } else {
                        log.warn { "🔴 No business tenant found for user IdP ID: [$idpUserId] for path ${request.servletPath}. Access denied." }
                        throw TenantNotFoundException(identifierTried = idpUserId)
                    }
                }

            } else {
                log.trace { "No authenticated JWT user found, skipping tenant resolution." }
            }
            filterChain.doFilter(request, response)
        } finally {
            if (tenantIdSet != null) {
                log.debug { "🟠 Clearing tenant context (was: $tenantIdSet)" }
                TenantContext.clear()
            }
        }
    }

    override fun shouldNotFilter(request: HttpServletRequest): Boolean {

        val path = request.servletPath
        return EXCLUDED_PATHS.any { path.startsWith(it) }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/security/adapters/KeycloakIdentityProviderAdapter.kt
================================================
package dev.cnpe.ventescabekotlin.security.adapters

import dev.cnpe.ventescabekotlin.security.config.KeycloakAdminProperties
import dev.cnpe.ventescabekotlin.security.exception.IdpAccessException
import dev.cnpe.ventescabekotlin.security.exception.IdpRoleAssignmentException
import dev.cnpe.ventescabekotlin.security.exception.IdpUserCreationException
import dev.cnpe.ventescabekotlin.security.exception.IdpUserNotFoundException
import dev.cnpe.ventescabekotlin.security.ports.IdentityProviderPort
import dev.cnpe.ventescabekotlin.security.ports.dto.NewUserData
import dev.cnpe.ventescabekotlin.security.ports.dto.UserIdentity
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.ws.rs.core.Response
import org.keycloak.admin.client.Keycloak
import org.keycloak.admin.client.KeycloakBuilder
import org.keycloak.admin.client.resource.RealmResource
import org.keycloak.admin.client.resource.UsersResource
import org.keycloak.representations.idm.CredentialRepresentation
import org.keycloak.representations.idm.UserRepresentation
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

private val log = KotlinLogging.logger {}

private const val TARGET_REALM = "ventesca"

@Component
@Profile("keycloak")
class KeycloakIdentityProviderAdapter(
    private val properties: KeycloakAdminProperties
) : IdentityProviderPort {

    private val keycloakAdminClient: Keycloak by lazy { buildKeycloakAdminClient() }

    private fun buildKeycloakAdminClient(): Keycloak {
        log.info { "Building Keycloak Admin Client for server: ${properties.serverUrl}, realm: ${properties.realm}, clientId: ${properties.clientId}" }

        return KeycloakBuilder.builder()
            .serverUrl(properties.serverUrl)
            .realm(properties.realm)
            .grantType(properties.grantType)
            .clientId(properties.clientId)
            .clientSecret(properties.clientSecret)
            .username(properties.username)
            .password(properties.password)
            .build()
    }

    private fun getTargetRealm(): RealmResource {
        return keycloakAdminClient.realm(TARGET_REALM)
    }

    private fun usersResource(): UsersResource = getTargetRealm().users()

    override fun createUser(
        userData: NewUserData,
        roles: Set<String>,
        attributes: Map<String, String>
    ): UserIdentity {
        log.debug { "Attempting to create user in Keycloak: ${userData.email}" }

        val userRep = UserRepresentation().apply {
            username = userData.username ?: userData.email
            email = userData.email
            firstName = userData.firstName
            lastName = userData.lastName
            isEnabled = true
            isEmailVerified = false // TODO CHECK
            this.attributes = attributes.mapValues { listOf(it.value) }

            userData.initialPassword?.let { pwd ->
                val credential = CredentialRepresentation().apply {
                    type = CredentialRepresentation.PASSWORD
                    value = pwd
                    isTemporary = true
                }
                credentials = listOf(credential)
            }
        }

        try {
            val response: Response = usersResource().create(userRep)

            when (response.status) {
                Response.Status.CREATED.statusCode -> {
                    val location = response.location
                    val userId = location.path.substringAfterLast("/")
                    log.info { "Successfully created user in Keycloak: ${userData.email}, ID: $userId" }

                    if (roles.isNotEmpty()) {
                        try {
                            assignRolesToUserInternal(userId, roles)
                        } catch (roleEx: Exception) {
                            log.error(roleEx) { "User $userId created, but failed to assign roles: $roles" }
                            throw IdpRoleAssignmentException("Failed to assign roles after user creation", roleEx)
                        }
                    }

                    //fetch created user to return full UserIdentity
                    val createdUserRep = usersResource().get(userId)?.toRepresentation()
                    return UserIdentity(
                        id = userId,
                        email = createdUserRep?.email ?: userData.email,
                        username = createdUserRep?.username,
                        firstName = createdUserRep?.firstName,
                        lastName = createdUserRep?.lastName
                    )
                }

                Response.Status.CONFLICT.statusCode -> {
                    log.warn { "User creation conflict for ${userData.email}. User likely already exists." }
                    throw IdpUserCreationException(
                        userData.email,
                        "User creation conflict (email/username likely exists)."
                    )
                }

                else -> {
                    val errorMsg = response.readEntity(String::class.java) ?: "Unknown Keycloak error"
                    log.error { "Keycloak user creation failed for ${userData.email}. Status: ${response.status}, Reason: $errorMsg" }
                    throw IdpUserCreationException(userData.email, "Keycloak API error: ${response.status} - $errorMsg")
                }
            }
        } catch (e: Exception) {
            log.error(e) { "Exception during Keycloak user creation for ${userData.email}" }
            throw IdpAccessException("Failed to create user due to communication error: ${e.message}", e)
        }
    }

    override fun findUserByEmail(email: String): UserIdentity? {
        log.debug { "Searching for user in Keycloak by email: $email" }

        try {
            val userReps: List<UserRepresentation> = usersResource().searchByEmail(email, true)
            return userReps.firstOrNull()?.let {
                log.info { "Found user by email $email. ID: ${it.id}" }
                UserIdentity(
                    id = it.id,
                    email = it.email,
                    username = it.username,
                    firstName = it.firstName,
                    lastName = it.lastName
                )
            } ?: run {
                log.info { "No user found with email: $email" }
                null
            }
        } catch (e: Exception) {
            log.error(e) { "Exception during Keycloak user search for email $email" }
            throw IdpAccessException("Failed to search user by email due to communication error: ${e.message}", e)
        }
    }

    override fun assignRolesToUser(userId: String, roles: Set<String>) {
        log.debug { "Assigning roles $roles to Keycloak user ID: $userId" }
        if (roles.isEmpty()) {
            log.warn { "No roles provided to assign to user $userId." }
            return
        }
        assignRolesToUserInternal(userId, roles)
    }

    override fun findUserById(userId: String): UserIdentity? {
        log.debug { "Finding user in Keycloak by ID: $userId" }
        return try {
            usersResource().get(userId)?.toRepresentation()?.let {
                UserIdentity(
                    id = it.id,
                    email = it.email,
                    username = it.username,
                    firstName = it.firstName,
                    lastName = it.lastName
                )
            }
        } catch (nf: jakarta.ws.rs.NotFoundException) {
            log.info { "User not found in Keycloak with ID: $userId" }
            null
        } catch (e: Exception) {
            log.error(e) { "Exception finding Keycloak user $userId" }
            throw IdpAccessException("Failed to find user $userId: ${e.message}", e)
        }
    }

    override fun updateUserAttributes(
        userId: String,
        attributes: Map<String, String>
    ) {
        log.debug { "Updating attributes for Keycloak user ID: $userId with $attributes" }
        try {
            val userResource = usersResource().get(userId) ?: throw IdpUserNotFoundException(userId)
            val userRep = userResource.toRepresentation()

            val keycloakAttributes = attributes.mapValues { listOf(it.value) }

            val newAttributes = (userRep.attributes ?: emptyMap()).toMutableMap()
            newAttributes.putAll(keycloakAttributes)
            userRep.attributes = newAttributes

            userResource.update(userRep)
            log.info { "Successfully updated attributes for user $userId" }

        } catch (nf: jakarta.ws.rs.NotFoundException) {
            log.error(nf) { "User $userId not found during attribute update." }
            throw IdpUserNotFoundException(userId)
        } catch (e: Exception) {
            log.error(e) { "Exception updating attributes for user $userId" }
            throw IdpAccessException("Failed update attributes for $userId: ${e.message}", e)
        }
    }

    override fun deleteUser(userId: String) {
        log.warn { "Attempting to delete Keycloak user ID: $userId" }
        try {
            val response = usersResource().delete(userId)
            if (response.statusInfo.family == Response.Status.Family.SUCCESSFUL) {
                log.info { "Successfully deleted Keycloak user ID: $userId" }
            } else if (response.status == Response.Status.NOT_FOUND.statusCode) {
                log.error { "User $userId not found during deletion attempt." }
                throw IdpUserNotFoundException(userId)
            } else {
                val errorMsg = response.readEntity(String::class.java) ?: "Unknown Keycloak error"
                log.error { "Keycloak user deletion failed for $userId. Status: ${response.status}, Reason: $errorMsg" }
                throw IdpAccessException("Keycloak API error during delete: ${response.status} - $errorMsg")
            }
        } catch (nf: jakarta.ws.rs.NotFoundException) {
            log.error(nf) { "User $userId not found during deletion." }
            throw IdpUserNotFoundException(userId)
        } catch (e: Exception) {
            log.error(e) { "Exception during Keycloak user deletion for $userId" }
            throw IdpAccessException("Failed to delete user $userId: ${e.message}", e)
        }
    }

    override fun getUserAttributes(userId: String): Map<String, List<String>> {
        log.debug { "Getting attributes for Keycloak user ID: $userId" }
        try {
            return usersResource().get(userId)?.toRepresentation()?.attributes ?: emptyMap()
        } catch (nf: jakarta.ws.rs.NotFoundException) {
            log.error(nf) { "User $userId not found when getting attributes." }
            throw IdpUserNotFoundException(userId)
        } catch (e: Exception) {
            log.error(e) { "Exception getting attributes for user $userId" }
            throw IdpAccessException("Failed get attributes for $userId: ${e.message}", e)
        }
    }


    // *******************************
    // 🔰 Private Helpers
    // *******************************

    private fun assignRolesToUserInternal(userId: String, roles: Set<String>) {

        try {
            val userResource = usersResource().get(userId) ?: throw IdpUserNotFoundException(userId)

            val availableRoles = getTargetRealm().roles().list()?.associateBy { it.name } ?: emptyMap()
            val rolesToAssign = roles
                .mapNotNull { roleName ->
                    availableRoles[roleName] ?: run {
                        log.warn { "Role '$roleName' not found in realm '$TARGET_REALM'. Skipping assignment." }
                        null
                    }
                }
                .toList()

            if (rolesToAssign.isNotEmpty()) {
                log.info { "Adding realm roles ${rolesToAssign.map { it.name }} to user $userId" }
                userResource.roles().realmLevel().add(rolesToAssign)
                // TODO: if need to REPLACE roles, first get existing, remove, then add.
            } else {
                log.warn { "None of the requested roles $roles exist in realm $TARGET_REALM for user $userId." }
            }
        } catch (nf: jakarta.ws.rs.NotFoundException) {
            log.error(nf) { "User $userId not found in Keycloak during role assignment." }
            throw IdpUserNotFoundException(userId)
        } catch (e: Exception) {
            log.error(e) { "Exception during Keycloak role assignment for user $userId" }
            throw IdpAccessException("Failed to assign roles to user $userId: ${e.message}", e)
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/security/config/KeycloakAdminProperties.kt
================================================
package dev.cnpe.ventescabekotlin.security.config

import jakarta.validation.constraints.NotBlank
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.validation.annotation.Validated

@ConfigurationProperties(prefix = "keycloak.admin")
@Validated
data class KeycloakAdminProperties(

    @field:NotBlank
    val serverUrl: String, // http://localhost:8180

    @field:NotBlank
    val realm: String,

    @field:NotBlank
    val clientId: String,

    val clientSecret: String? = null,
    val username: String? = null,
    val password: String? = null,

    val grantType: String = "client_credentials"

) {
    init {
        when (grantType) {
            "client_credentials" -> {
                require(!clientSecret.isNullOrBlank()) { "keycloak.admin.client-secret must be set for client_credentials grant" }
            }
            "password" -> {
                require(!username.isNullOrBlank()) { "keycloak.admin.username must be set for password grant" }
                require(!password.isNullOrBlank()) { "keycloak.admin.password must be set for password grant" }
            }
            else -> {
                // other grant types later
            }
        }
    }
}


================================================
File: dev/cnpe/ventescabekotlin/security/context/RequestUserContext.kt
================================================
package dev.cnpe.ventescabekotlin.security.context

import org.springframework.stereotype.Component
import org.springframework.web.context.annotation.RequestScope

@Component
@RequestScope
class RequestUserContext(
    override var userId: String? = null,
    override var email: String? = null,
    override var preferredUsername: String? = null,
    override var roles: Set<String> = emptySet(),
    override var tenantId: String? = null
) : UserContext {
}

================================================
File: dev/cnpe/ventescabekotlin/security/context/UserContext.kt
================================================
package dev.cnpe.ventescabekotlin.security.context

/**
 * Interface defining the contract for accessing information about the
 * user associated with the current request context.
 */
interface UserContext {

    val userId: String?
    val email: String?
    val preferredUsername: String?
    val roles: Set<String>
    val tenantId: String?

}

================================================
File: dev/cnpe/ventescabekotlin/security/exception/IdpAccessException.kt
================================================
package dev.cnpe.ventescabekotlin.security.exception

open class IdpAccessException(
    message: String,
    cause: Throwable? = null
) : RuntimeException(message, cause) {
}

================================================
File: dev/cnpe/ventescabekotlin/security/exception/IdpRoleAssignmentException.kt
================================================
package dev.cnpe.ventescabekotlin.security.exception

class IdpRoleAssignmentException(
    message: String,
    cause: Throwable? = null
) : IdpAccessException("Failed to assign roles to user", cause) {
}

================================================
File: dev/cnpe/ventescabekotlin/security/exception/IdpUserCreationException.kt
================================================
package dev.cnpe.ventescabekotlin.security.exception

class IdpUserCreationException(
    val emailAttempted: String?,
    message: String,
    cause: Throwable? = null
) : IdpAccessException("Failed to create user ${emailAttempted ?: "N/A"}: $message", cause) {
}

================================================
File: dev/cnpe/ventescabekotlin/security/exception/IdpUserNotFoundException.kt
================================================
package dev.cnpe.ventescabekotlin.security.exception

class IdpUserNotFoundException(
    val identifier: String
) : IdpAccessException("User not found in IdP using identifier: $identifier")

================================================
File: dev/cnpe/ventescabekotlin/security/filters/UserContextPopulationFilter.kt
================================================
package dev.cnpe.ventescabekotlin.security.filters

import dev.cnpe.ventescabekotlin.security.context.RequestUserContext
import dev.cnpe.ventescabekotlin.tenant.TenantContext
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.servlet.FilterChain
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.core.Ordered
import org.springframework.core.annotation.Order
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter

private val log = KotlinLogging.logger {}

@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 10)
class UserContextPopulationFilter(
    private val userContext: RequestUserContext
) : OncePerRequestFilter() {

    companion object {
        private const val CLAIM_EMAIL = "email"
        private const val CLAIM_PREFERRED_USERNAME = "preferred_username"
        private const val CLAIM_REALM_ACCESS = "realm_access"
        private const val CLAIM_ROLES = "roles"
        private const val ROLE_PREFIX = "ROLE_"
        private val IGNORED_ROLES = setOf("offline_access", "uma_authorization")
    }

    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {

        try {
            val authentication = SecurityContextHolder.getContext().authentication

            if (authentication != null && authentication.isAuthenticated && authentication is JwtAuthenticationToken) {
                val token = authentication.token
                log.debug { "JWT Authentication found. Populating user context." }

                userContext.userId = token.subject
                userContext.email = token.getClaimAsString(CLAIM_EMAIL)
                userContext.preferredUsername = token.getClaimAsString(CLAIM_PREFERRED_USERNAME)
                userContext.roles = extractRoles(authentication.authorities)
                userContext.tenantId = TenantContext.getCurrentTenant()
            } else {
                log.trace { "No authenticated JWT found, UserContext remains empty." }
            }
        } catch (e: Exception) {
            log.error(e) { "Failed to populate UserContext" }
        }
        filterChain.doFilter(request, response)
    }

    private fun extractRoles(authorities: Collection<GrantedAuthority>): Set<String> {
        return authorities
            .map { it.authority }
            .map { if (it.startsWith(ROLE_PREFIX)) it.substring(ROLE_PREFIX.length) else it }
            .toSet()
    }

    // TODO: Define paths this filter should NOT apply to (similar to TenantAuthenticationFilter)
    // override fun shouldNotFilter(request: HttpServletRequest): Boolean { ... }
}

================================================
File: dev/cnpe/ventescabekotlin/security/ports/IdentityProviderPort.kt
================================================
package dev.cnpe.ventescabekotlin.security.ports

import dev.cnpe.ventescabekotlin.security.exception.IdpAccessException
import dev.cnpe.ventescabekotlin.security.exception.IdpUserCreationException
import dev.cnpe.ventescabekotlin.security.exception.IdpUserNotFoundException
import dev.cnpe.ventescabekotlin.security.ports.dto.NewUserData
import dev.cnpe.ventescabekotlin.security.ports.dto.UserIdentity

/**
 * Port defining interactions with the external Identity Provider (IdP)
 * for user creation and role management required by application services.
 * Implementations will adapt to specific IdPs like Keycloak or Supabase.
 */
interface IdentityProviderPort {


    /**
     * Creates a new user in the IdP.
     * Assigns specified application roles and potentially links them to metadata.
     *
     * @param userData Details of the user to create (email, names, optional password).
     * @param roles Set of application role *names* (e.g., "BUSINESS_ADMIN") to assign.
     * @param attributes Optional map of custom attributes/metadata to store with the user (e.g., "tenant_id").
     * @return UserIdentity containing the unique ID assigned by the IdP and other core details.
     * @throws IdpUserCreationException if user creation fails (e.g., duplicate email).
     * @throws IdpAccessException for general communication errors with the IdP.
     */
    @Throws(IdpUserCreationException::class, IdpAccessException::class)
    fun createUser(
        userData: NewUserData,
        roles: Set<String>,
        attributes: Map<String, String> = emptyMap()
    ): UserIdentity

    /**
     * Finds a user in the IdP by their email address.
     * Useful for checking if a user already exists before attempting creation.
     *
     * @param email The email address to search for.
     * @return UserIdentity if a user with that email is found, null otherwise.
     * @throws IdpAccessException for general communication errors with the IdP.
     */
    @Throws(IdpAccessException::class)
    fun findUserByEmail(email: String): UserIdentity?

    /**
     * Assigns a set of application roles to an existing user in the IdP.
     * Implementations should handle whether this replaces or adds to existing roles.
     *
     * @param userId The unique ID of the user in the IdP (e.g., 'sub' claim).
     * @param roles The set of application role *names* to assign.
     * @throws IdpUserNotFoundException if the user ID doesn't exist in the IdP.
     * @throws IdpAccessException for general communication errors or role assignment failures.
     */
    @Throws(IdpUserNotFoundException::class, IdpAccessException::class)
    fun assignRolesToUser(userId: String, roles: Set<String>)

    /** Finds a user by their unique IdP ID. */
    @Throws(IdpAccessException::class)
    fun findUserById(userId: String): UserIdentity?

    /** Updates attributes for an existing user (e.g., name, custom attributes). */
    @Throws(IdpUserNotFoundException::class, IdpAccessException::class)
    fun updateUserAttributes(userId: String, attributes: Map<String, String>) // Attributes to update/add

    /** Deletes a user from the IdP. Use with caution! */
    @Throws(IdpUserNotFoundException::class, IdpAccessException::class)
    fun deleteUser(userId: String)

    /** Gets the custom attributes for a user (needed to check tenant_id). */
    @Throws(IdpUserNotFoundException::class, IdpAccessException::class)
    fun getUserAttributes(userId: String): Map<String, List<String>> // Keycloak stores attributes as List<String>

}

================================================
File: dev/cnpe/ventescabekotlin/security/ports/dto/NewUserData.kt
================================================
package dev.cnpe.ventescabekotlin.security.ports.dto

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Data required to create a new user in the Identity Provider.")
data class NewUserData(

    @Schema(
        description = "User's primary email address (must be unique in IdP).",
        example = "new.admin@business.com",
        required = true
    )
    val email: String,

    @Schema(description = "User's first name.", example = "Jane")
    val firstName: String?,

    @Schema(description = "User's last name.", example = "Doe")
    val lastName: String?,

    @Schema(
        description = "Optional initial password. If null, IdP might require user setup.",
        example = "Str0ngP@ssw0rd!"
    )
    val initialPassword: String? = null,

    @Schema(
        description = "Optional username. If null, IdP might require user setup.",
        example = "jane.doe"
    )
    val username: String? = null

)


================================================
File: dev/cnpe/ventescabekotlin/security/ports/dto/UserIdentity.kt
================================================
package dev.cnpe.ventescabekotlin.security.ports.dto

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents core identity information retrieved from the Identity Provider.")
data class UserIdentity(
    @Schema(
        description = "The unique identifier assigned by the IdP (e.g., UUID).",
        example = "f81d4fae-7dec-11d0-a765-00a0c91e6bf6",
        required = true
    )
    val id: String, // IdP's unique ID ('sub' claim), non-nullable

    @Schema(description = "User's primary email address.", example = "jane.doe@business.com", required = true)
    val email: String,

    @Schema(description = "Username used for login (might be same as email).", example = "jdoe")
    val username: String?,

    @Schema(description = "User's first name.", example = "Jane")
    val firstName: String?,

    @Schema(description = "User's last name.", example = "Doe")
    val lastName: String?
)


================================================
File: dev/cnpe/ventescabekotlin/shared/application/dto/ApiResult.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.dto

import com.fasterxml.jackson.annotation.JsonInclude
import io.swagger.v3.oas.annotations.media.Schema

/**
 * Standard API response wrapper. Can represent either a successful result with data
 * or an error result with error details.
 *
 * @param T The type of data included in a successful response.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@Schema(description = "Standard API response wrapper for success or error outcomes.")
class ApiResult<T> private constructor(

    @Schema(description = "Indicates if the request was successful.", required = true, example = "false")
    val success: Boolean,

    @Schema(
        description = "The response data payload if the request was successful (absent on error).",
        required = false
    )
    @JsonInclude(JsonInclude.Include.NON_NULL)
    val data: T?,

    @Schema(description = "The error details if the request failed (absent on success).", required = false)
    @JsonInclude(JsonInclude.Include.NON_NULL)
    val error: ErrorResponse?

) {
    companion object {

        /**
         * Creates a successful ApiResult instance.
         * @param data The data payload for the successful response.
         */
        fun <T> success(data: T): ApiResult<T> {
            return ApiResult(success = true, data = data, error = null)
        }

        /**
         * Creates an error ApiResult instance using a pre-built ErrorResponse.
         * @param error The detailed ErrorResponse object.
         */
        fun <T> error(error: ErrorResponse): ApiResult<T> {
            return ApiResult(success = false, data = null, error = error)
        }
    }

}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/dto/EnumInfoResponse.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.dto

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents information about a specific enum type, including its possible values.")
data class EnumInfoResponse(
    @Schema(description = "The simple name of the enum type.", example = "BusinessStatus")
    val enumName: String,

    @Schema(description = "List of possible values for this enum type, with localized text.")
    val values: List<EnumValueInfo>
)

================================================
File: dev/cnpe/ventescabekotlin/shared/application/dto/EnumValueInfo.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.dto

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents information about a specific enum constant, including localized text.")
data class EnumValueInfo(
    @Schema(description = "The canonical, language-independent name of the enum constant.", example = "ACTIVE")
    val value: String,

    @Schema(description = "The localized, user-friendly display name for the enum constant.", example = "Active")
    val name: String,

    @Schema(description = "The localized description for the enum constant (optional).", example = "Fully operational.")
    val description: String?
)

================================================
File: dev/cnpe/ventescabekotlin/shared/application/dto/ErrorResponse.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.dto

import com.fasterxml.jackson.annotation.JsonInclude
import dev.cnpe.ventescabekotlin.shared.application.exception.OperationNotAllowedReason
import io.swagger.v3.oas.annotations.media.Schema
import java.time.Instant

@JsonInclude(JsonInclude.Include.NON_NULL)
@Schema(description = "Standardized error response structure.")
data class ErrorResponse(

    @Schema(description = "The request path that resulted in the error.", example = "/brands/123", required = false)
    val path: String?,

    @Schema(description = "The HTTP status code.", example = "404", required = true)
    val status: Int,

    @Schema(description = "Application-specific error code.", example = "RESOURCE_NOT_FOUND", required = true)
    val code: String,

    @Schema(
        description = "A human-readable explanation specific to this occurrence of the problem.",
        example = "Brand not found for ID: 123",
        required = false
    )
    val message: String?,

    @Schema(description = "Timestamp indicating when the error occurred.", required = true)
    val timestamp: Instant,


//    @Schema(
//        description = """
//            A specific reason code providing more context for the error.
//            The actual type depends on the context of the error.
//            """,
//        required = false,
//        implementation = OperationNotAllowedReason::class
//        // If implementation doesn't work, I would have to manually add every class involved. Not good:
////                oneOf = [
////            CategoryOperationNotAllowedReason::class, // Reference specific enum schemas
////            // ProductOperationNotAllowedReason::class // Add other reason enums here
////        ]
//    )
//    val reason: String? = null,

    @Schema(
        description = "An optional map containing additional error details (e.g., validation errors).",
        required = false
    )
    val details: Map<String, Any>? = null
)


================================================
File: dev/cnpe/ventescabekotlin/shared/application/dto/PageResponse.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.dto

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.data.domain.Page

@Schema(description = "Generic paginated response wrapper.")
data class PageResponse<T>(

    @get:Schema(description = "The actual data content for the current page.")
    val content: List<T>,

    @get:Schema(description = "Metadata about the pagination.", required = true)
    val pagination: PaginationMetadata
) {
    companion object {
        /**
         * Factory method to create a PageResponse from a Spring Data Page object.
         */
        fun <T> from(page: Page<T>): PageResponse<T> {
            return PageResponse(
                content = page.content,
                pagination = PaginationMetadata(
                    pageNumber = page.number,
                    pageSize = page.size,
                    totalElements = page.totalElements,
                    totalPages = page.totalPages,
                    first = page.isFirst,
                    last = page.isLast
                )
            )
        }
    }

    @Schema(description = "Details about the pagination state.")
    data class PaginationMetadata(
        @Schema(description = "Current page number (0-indexed).", example = "0")
        val pageNumber: Int,
        @Schema(description = "Number of items per page.", example = "20")
        val pageSize: Int,
        @Schema(description = "Total number of items across all pages.", example = "150")
        val totalElements: Long,
        @Schema(description = "Total number of pages.", example = "8")
        val totalPages: Int,
        @Schema(description = "Indicates if this is the first page.")
        val first: Boolean,
        @Schema(description = "Indicates if this is the last page.")
        val last: Boolean
    )
}


================================================
File: dev/cnpe/ventescabekotlin/shared/application/dto/ResourceAuditData.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.dto

import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import io.swagger.v3.oas.annotations.media.Schema
import java.time.OffsetDateTime

@Schema(description = "Audit information for a resource.")
data class ResourceAuditData(

    @Schema(description = "User who created the resource.")
    val createdBy: String,

    @Schema(description = "User who last modified the resource.")
    val lastModifiedBy: String?,

    @Schema(description = "Timestamp of creation.", format = "date-time")
    val createdAt: OffsetDateTime,

    @Schema(description = "Timestamp of last modification.", format = "date-time")
    val lastModifiedAt: OffsetDateTime

) {
    companion object {

        fun fromBaseEntity(entity: BaseEntity): ResourceAuditData {
            return ResourceAuditData(
                createdBy = entity.createdBy,
                lastModifiedBy = entity.lastModifiedBy,
                createdAt = entity.createdAt,
                lastModifiedAt = entity.lastModifiedAt
            )
        }
    }
}



================================================
File: dev/cnpe/ventescabekotlin/shared/application/exception/DomainException.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.exception

/**
 * Base class for checked exceptions related to domain/business logic violations.
 * These typically map to 4xx HTTP status codes when handled globally.
 *
 * @property errorCode The specific ErrorCode enum constant identifying the error type.
 * @property details Optional map containing structured details about the error (e.g., field name, value).
 * @property parameters Optional parameters used for formatting the user-facing error message.
 * @param message Optional detail message for logging (often derived from errorCode + params).
 * @param cause Optional underlying cause of this exception.
 */
open class DomainException(
    val errorCode: ErrorCode,
    val details: Map<String, Any>? = null,
    vararg val parameters: String,
    message: String? = null,
    cause: Throwable? = null
) : RuntimeException(message ?: "${errorCode.name}(${parameters.joinToString()})", cause) {

}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/exception/DomainExceptionUtils.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.*

/**
 * Creates a standard DomainException for resource not found errors.
 *
 * @param entityType User-friendly name of the entity type (e.g., "Brand", "Category").
 * @param id The ID of the resource that was not found.
 * @return DomainException instance with RESOURCE_NOT_FOUND code and details.
 */
fun createResourceNotFoundException(entityType: String, id: Any): DomainException {
    return DomainException(
        errorCode = RESOURCE_NOT_FOUND,
        details = mapOf(
            "entityType" to entityType,
            "${entityType.lowercase()}Id" to id
        ),
        parameters = arrayOf(entityType, id.toString())
    )
}


/**
 * Creates a standard DomainException for duplicated resource errors.
 *
 * @param field The name of the field that has a duplicate value.
 * @param value The value that caused the duplication conflict.
 * @return DomainException instance with DUPLICATED_RESOURCE code and details.
 */
fun createDuplicatedResourceException(field: String, value: Any): DomainException {
    val valueString = value.toString()
    return DomainException(
        errorCode = DUPLICATED_RESOURCE,
        details = mapOf(
            "field" to field,
            "value" to value
        ),
        parameters = arrayOf(field, valueString)
    )
}

/**
 * Creates a standard DomainException for operation not allowed errors with a specific reason.
 *
 * @param reason The specific reason enum constant (implementing OperationNotAllowedReason).
 * @param entityId Optional ID of the entity involved.
 * @param additionalDetails Optional map for context-specific details beyond the reason.
 * @return DomainException instance with OPERATION_NOT_ALLOWED code and details.
 */
fun createOperationNotAllowedException(
    reason: OperationNotAllowedReason,
    entityId: Any? = null,
    additionalDetails: Map<String, Any>? = null,
    vararg parameters: String,
): DomainException {
    val detailsMap = mutableMapOf<String, Any>("reason" to reason.name)
    entityId?.let { detailsMap["entityId"] = it }
    additionalDetails?.let { detailsMap.putAll(it) }

    return DomainException(
        errorCode = OPERATION_NOT_ALLOWED,
        details = detailsMap.toMap(),
        parameters = parameters
    )
}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/exception/ErrorCode.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.exception

import org.springframework.http.HttpStatus

/**
 * Interface defining the contract for application error codes.
 *
 */
interface ErrorCode {

    /**
     * The HTTP status associated with this error code.
     */
    val status: HttpStatus

    /**
     * The unique name/identifier of the error code (typically the enum constant name)
     */
    val name: String

}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/exception/GeneralErrorCode.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.exception

import org.springframework.http.HttpStatus
import org.springframework.http.HttpStatus.*

enum class GeneralErrorCode(override val status: HttpStatus = INTERNAL_SERVER_ERROR) : ErrorCode {

    GENERAL,
    CONSTRAINT_VIOLATION(BAD_REQUEST),
    DATA_TYPE_MISMATCH(BAD_REQUEST),
    RESOURCE_NOT_FOUND(NOT_FOUND),
    DUPLICATED_RESOURCE(CONFLICT),
    OPERATION_NOT_ALLOWED(METHOD_NOT_ALLOWED),
    INVALID_DATA(BAD_REQUEST),
    INVALID_STATE(BAD_REQUEST),
    AUTHENTICATION_ERROR(UNAUTHORIZED),
    INSUFFICIENT_CONTEXT(INTERNAL_SERVER_ERROR)
}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/exception/OperationNotAllowedReason.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.exception

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Marker interface for specific reasons why an operation might not be allowed.")
interface OperationNotAllowedReason {
    val name: String
}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/service/CodeGeneratorService.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.service

import dev.cnpe.ventescabekotlin.shared.domain.vo.GeneratedCode
import org.springframework.stereotype.Service

@Service
class CodeGeneratorService {

    companion object {
        const val CODE_LENGTH = 3
    }

    fun generateCode(name: String): String {

        require(name.isNotBlank()) { "Name cannot be blank." }

        val words = name.split(Regex("\\s+|&|\\+|-")).filter { it.isNotEmpty() }

        val codeBuilder = StringBuilder(
            words.joinToString("") { it.first().uppercase() }
        )

        if (codeBuilder.length < CODE_LENGTH && words.isNotEmpty()) {
            val firstWord = words[0]
            var i = 1
            while (codeBuilder.length < CODE_LENGTH && i < firstWord.length) {
                codeBuilder.append(firstWord[i].uppercaseChar())
                i++
            }
        }

        while (codeBuilder.length < CODE_LENGTH) {
            codeBuilder.append("X")
        }

        return codeBuilder.toString().take(CODE_LENGTH)
    }


}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/service/EnumTranslationService.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.service

import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum
import dev.cnpe.ventescabekotlin.shared.domain.enums.messageKeyPrefix
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.MessageSource
import org.springframework.context.NoSuchMessageException
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.stereotype.Service
import java.util.*

private val log = KotlinLogging.logger {}

@Service
class EnumTranslationService(
    private val messageSource: MessageSource
) {

    companion object {
        private const val NAME_SUFFIX = ".name"
        private const val DESCRIPTION_SUFFIX = ".description"
    }

    /**
     * Gets the localized readable name for a domain enum constant.
     * Uses the current request's locale.
     * Falls back to a cleaned-up version of the enum constant name if translation is missing.
     */
    fun getReadableName(enumConstant: DomainEnum, locale: Locale = LocaleContextHolder.getLocale()): String {
        val key = enumConstant.messageKeyPrefix() + NAME_SUFFIX
        val defaultMessage = enumConstant.name.toReadableDefault()

        return try {
            messageSource.getMessage(key, null, defaultMessage, locale)!!
        } catch (e: NoSuchMessageException) {
            log.trace { "Missing message key [$key] for locale [$locale]. Using default '$defaultMessage'." }
            defaultMessage
        } catch (e: Exception) {
            log.error(e) { "Error resolving message for key [$key]" }
            defaultMessage
        }
    }

    /**
     * Gets the localized description for a domain enum constant.
     * Uses the current request's locale.
     * Returns null if the translation is missing.
     */
    fun getDescription(enumConstant: DomainEnum, locale: Locale = LocaleContextHolder.getLocale()): String? {
        val key = enumConstant.messageKeyPrefix() + DESCRIPTION_SUFFIX
        return try {
            messageSource.getMessage(key, null, null, locale)
        } catch (e: NoSuchMessageException) {
            log.trace { "Missing message key [$key] for locale [$locale]. Returning null description." }
            null
        } catch (e: Exception) {
            log.error(e) { "Error resolving message for key [$key]" }
            null
        }
    }

    private fun String.toReadableDefault(): String {
        return this.replace('_', ' ').lowercase()
            .replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/shared/application/validation/NotBlankIfPresent.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.validation

import jakarta.validation.Constraint
import jakarta.validation.Payload
import kotlin.reflect.KClass

@Target(
    AnnotationTarget.FIELD,
    AnnotationTarget.VALUE_PARAMETER,
    AnnotationTarget.PROPERTY_GETTER
)
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = [NotBlankIfPresentValidator::class])
annotation class NotBlankIfPresent(
    val message: String = "If present, must not be blank.",
    val groups: Array<KClass<*>> = [],
    val payload: Array<KClass<out Payload>> = []
)

================================================
File: dev/cnpe/ventescabekotlin/shared/application/validation/NotBlankIfPresentValidator.kt
================================================
package dev.cnpe.ventescabekotlin.shared.application.validation

import jakarta.validation.ConstraintValidator
import jakarta.validation.ConstraintValidatorContext

class NotBlankIfPresentValidator : ConstraintValidator<NotBlankIfPresent, String?> {
    override fun isValid(value: String?, context: ConstraintValidatorContext?): Boolean {
        return value == null || value.isNotBlank()
    }

}

================================================
File: dev/cnpe/ventescabekotlin/shared/domain/enums/DomainEnum.kt
================================================
package dev.cnpe.ventescabekotlin.shared.domain.enums

interface DomainEnum {

    val name: String


}

/**
 * Extension function to generate the standard MessageSource key prefix for any DomainEnum.
 * Example: BusinessStatus.ACTIVE -> "enum.BusinessStatus.ACTIVE"
 */
fun DomainEnum.messageKeyPrefix(): String {
    val className = this::class.simpleName ?: this.javaClass.simpleName
    return "enum.$className.${this.name}"
}


================================================
File: dev/cnpe/ventescabekotlin/shared/domain/model/BaseEntity.kt
================================================
package dev.cnpe.ventescabekotlin.shared.domain.model

import jakarta.persistence.*
import org.hibernate.proxy.HibernateProxy
import org.springframework.data.annotation.CreatedBy
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedBy
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.OffsetDateTime

@MappedSuperclass
@EntityListeners(AuditingEntityListener::class)
abstract class BaseEntity(
    @Id
    @SequenceGenerator(
        name = "primary_sequence",
        sequenceName = "primary_sequence",
        allocationSize = 1,
        initialValue = 10000
    )
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        generator = "primary_sequence"
    )
    @Column(name = "id")
    open var id: Long? = null,

    @Version
    @Column(name = "version", nullable = false)
    open var version: Int = 0

) {
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    lateinit var createdAt: OffsetDateTime
        protected set

    @LastModifiedDate
    @Column(name = "last_modified_at", nullable = false)
    lateinit var lastModifiedAt: OffsetDateTime
        protected set

    @CreatedBy
    @Column(name = "created_by", nullable = false, updatable = false)
    lateinit var createdBy: String
        protected set

    @LastModifiedBy
    @Column(name = "last_modified_by")
    var lastModifiedBy: String? = null
        protected set

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null) return false

        if (this::class.java != other::class.java) {
            val otherActualClass =
                if (other is HibernateProxy) other.hibernateLazyInitializer.persistentClass else other.javaClass
            if (this.javaClass != otherActualClass) return false
        }

        if (other !is BaseEntity) return false

        return this.id != null && this.id == other.id
    }

    override fun hashCode(): Int {
        return if (id != null) {
            id.hashCode()
        } else {
            System.identityHashCode(this)
        }
    }

    override fun toString(): String {
        return "${this.javaClass.simpleName}(id=$id)"
    }
}

================================================
File: dev/cnpe/ventescabekotlin/shared/domain/vo/Address.kt
================================================
package dev.cnpe.ventescabekotlin.shared.domain.vo

import dev.cnpe.ventescabekotlin.shared.application.validation.NotBlankIfPresent
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import org.hibernate.validator.constraints.Length

@Schema(description = "Represents a physical address.")
@Embeddable
data class Address(

    @Schema(
        description = "Street name and number.",
        example = "123 Main St",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:NotBlankIfPresent
    @field:Length(min = 2, max = 100)
    @Column(name = "street")
    val street: String?,

    @Schema(description = "City name.", example = "Anytown", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
    @field:NotBlankIfPresent
    @field:Length(min = 2, max = 50)
    @Column(name = "city")
    val city: String?,

    @Schema(description = "Country name or code.", example = "USA", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
    @field:NotBlankIfPresent
    @field:Length(min = 2, max = 50)
    @Column(name = "country")
    val country: String?,

    @Schema(description = "Postal or ZIP code.", example = "90210", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
    @field:NotBlankIfPresent
    @field:Length(min = 3, max = 20)
    @Column(name = "postal_code")
    val postalCode: String?
) {
    companion object {
        fun empty(): Address = Address(null, null, null, null)

        fun buildAddress(street: String?, city: String?, zipCode: String?, country: String?): Address? {
            return if (!street.isNullOrBlank() && !city.isNullOrBlank()) {
                Address(street = street, city = city, postalCode = zipCode, country = country)
            } else null
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/shared/domain/vo/ContactInfo.kt
================================================
package dev.cnpe.ventescabekotlin.shared.domain.vo

import dev.cnpe.ventescabekotlin.shared.application.validation.NotBlankIfPresent
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import jakarta.validation.constraints.Email
import org.hibernate.validator.constraints.Length
import org.hibernate.validator.constraints.URL

@Schema(description = "Represents contact information.")
@Embeddable
data class ContactInfo(

    @Schema(
        description = "Primary phone number.",
        example = "+1-555-123-4567",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:NotBlankIfPresent
    @field:Length(min = 7, max = 20)
    @Column(name = "phone_number")
    val phoneNumber: String?,

    @Schema(
        description = "Primary email address.",
        example = "contact@example.com",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:NotBlankIfPresent
    @field:Email
    @Column(name = "email")
    val email: String?,

    @Schema(
        description = "Website URL.",
        example = "https://www.example.com",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:NotBlankIfPresent
    @field:URL
    @field:Length(min = 5, max = 100)
    @Column(name = "website")
    val website: String?
) {
    companion object {
        fun empty(): ContactInfo = ContactInfo(null, null, null)
    }

}

================================================
File: dev/cnpe/ventescabekotlin/shared/domain/vo/GeneratedCode.kt
================================================
package dev.cnpe.ventescabekotlin.shared.domain.vo

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable

@Schema(description = "Represents a system-generated code.")
@Embeddable
data class GeneratedCode(

    @Schema(
        description = "The value of the generated code.",
        example = "CAT-ELEC",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    @Column(name = "code", columnDefinition = "VARCHAR", nullable = false)
    val codeValue: String

)

================================================
File: dev/cnpe/ventescabekotlin/shared/domain/vo/Image.kt
================================================
package dev.cnpe.ventescabekotlin.shared.domain.vo

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import jakarta.validation.constraints.NotBlank
import org.hibernate.validator.constraints.URL

@Schema(description = "An image associated with a resource, identified by its URL.")
@Embeddable
data class Image(
    @Schema(
        description = "The URL of the image.",
        requiredMode = Schema.RequiredMode.REQUIRED,
        example = "https://example.com/images/product.jpg"
    )
    @Column(name = "image_url", length = 500, nullable = false)
    @field:NotBlank
    @field:URL
    val url: String
)


================================================
File: dev/cnpe/ventescabekotlin/shared/domain/vo/PersonalInfo.kt
================================================
package dev.cnpe.ventescabekotlin.shared.domain.vo

import dev.cnpe.ventescabekotlin.shared.application.validation.NotBlankIfPresent
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import jakarta.validation.constraints.NotBlank
import org.hibernate.validator.constraints.Length

@Schema(description = "Represents personal identification information.")
@Embeddable
data class PersonalInfo(

    @field:Schema(
        description = "First or given name.",
        example = "Jane",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    @field:Column(name = "first_name", nullable = false)
    @field:NotBlank
    @field:Length(min = 1, max = 50)
    val firstName: String,

    @field:Schema(
        description = "Last or family name.",
        example = "Doe",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:Column(name = "last_name")
    @field:NotBlankIfPresent
    @field:Length(min = 1, max = 50)
    val lastName: String?,

    @field:Schema(
        description = "Personal identification number (e.g., national ID, employee ID).",
        example = "ID987654",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    @field:Column(name = "personal_id")
    @field:NotBlankIfPresent
    @field:Length(min = 2, max = 50)
    val personalId: String?
){
    companion object {
        fun empty(): PersonalInfo = PersonalInfo("", null, null)
    }
}

================================================
File: dev/cnpe/ventescabekotlin/shared/infrastructure/web/EnumInfoController.kt
================================================
package dev.cnpe.ventescabekotlin.shared.infrastructure.web

import dev.cnpe.ventescabekotlin.business.domain.enums.BusinessStatus
import dev.cnpe.ventescabekotlin.shared.application.dto.EnumInfoResponse
import dev.cnpe.ventescabekotlin.shared.application.dto.EnumValueInfo
import dev.cnpe.ventescabekotlin.shared.application.service.EnumTranslationService
import dev.cnpe.ventescabekotlin.shared.domain.enums.DomainEnum
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/enums")
@Tag(name = "Enumerations", description = "Provides definitions and localized text for application enums.")
class EnumInfoController(
    private val enumTranslationService: EnumTranslationService
) {

    // Need to MANUALLY register each enum to expose
    private val enumRegistry: Map<String, Class<out DomainEnum>> = mapOf(
        "business-status" to BusinessStatus::class.java
    ).mapKeys { it.key.lowercase() }


    @GetMapping("/{enumName}")
    @Operation(summary = "Get details for a specific enum type")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Enum details found",
                content = [Content(schema = Schema(implementation = EnumInfoResponse::class))]
            ),
            ApiResponse(responseCode = "404", description = "Enum type not found or not exposed")
        ]
    )
    fun getEnumInfo(
        @Parameter(
            description = "The kebab-case name of the enum type (e.g., 'business-status', 'payment-method')",
            required = true
        )
        @PathVariable(name = "enumName") enumName: String
    ): ResponseEntity<EnumInfoResponse> {

        val enumClass = enumRegistry[enumName.lowercase()]
            ?: return ResponseEntity.notFound().build()

        if (!DomainEnum::class.java.isAssignableFrom(enumClass)) {
            log.error { "Enum class ${enumClass.simpleName} found in registry but does not implement DomainEnum." }
            return ResponseEntity.status(500).build()
        }
        val locale = LocaleContextHolder.getLocale()
        log.debug { "Fetching enum info for ${enumClass.simpleName} with locale $locale" }

        val enumValues = enumClass.enumConstants as Array<DomainEnum>

        val valueInfoList = enumValues.map { enumConstant ->
            EnumValueInfo(
                value = enumConstant.name,
                name = enumTranslationService.getReadableName(enumConstant, locale),
                description = enumTranslationService.getDescription(enumConstant, locale)
            )
        }

        val response = EnumInfoResponse(
            enumName = enumClass.simpleName,
            values = valueInfoList
        )

        return ResponseEntity.ok(response)
    }

    @GetMapping
    @Operation(summary = "List all exposed enum types")
    @ApiResponse(
        responseCode = "200",
        description = "List of available enum names",
        content = [Content(
            mediaType = "application/json",
            schema = Schema(implementation = String::class, type = "array"),
        )]
    )
    fun listExposedEnums(): Set<String> {
        return enumRegistry.keys
    }

}

================================================
File: dev/cnpe/ventescabekotlin/shared/infrastructure/web/advice/ExceptionHandlerUtils.kt
================================================
package dev.cnpe.ventescabekotlin.shared.infrastructure.web.advice

import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpStatus
import org.springframework.web.method.HandlerMethod
import java.util.stream.Collectors

private val log = KotlinLogging.logger { }

/**
 * Logs client-side errors (4xx) with structured context.
 */
internal fun logClientError(
    exception: Exception,
    request: HttpServletRequest,
    handlerMethod: HandlerMethod?,
    status: HttpStatus,
    errorCode: String,
    details: Map<String, Any>? = null
) {
    val controllerName = handlerMethod?.beanType?.simpleName ?: "UnknownController"
    val methodName = handlerMethod?.method?.name ?: "unknownMethod"
    val requestDetails = formatRequestDetails(request)
    val userContext = getUserContext()
    val detailString = formatDetails(details)

    log.warn {
        """
        |🟠 API Warning [${status.value()} ${status.reasonPhrase}]:
        |   Error Code: $errorCode
        |   Controller: $controllerName.$methodName
        |   Request   : $requestDetails
        |   User      : $userContext
        |   Exception : ${exception::class.simpleName} - ${exception.message ?: "No specific message."}
        |   Details   : $detailString
        """.trimMargin()
    }
}

/**
 * Logs server-side errors (5xx) with structured context and stack trace excerpt.
 */
internal fun logServerError(
    exception: Exception,
    request: HttpServletRequest,
    handlerMethod: HandlerMethod?,
    status: HttpStatus,
    errorCode: String
) {
    val controllerName = handlerMethod?.beanType?.simpleName ?: "UnknownController"
    val methodName = handlerMethod?.method?.name ?: "unknownMethod"
    val requestDetails = formatRequestDetails(request)
    val userContext = getUserContext()

    log.error(exception) {
        """
        |🔴 API Error [${status.value()} ${status.reasonPhrase}]:
        |   Error Code: $errorCode
        |   Controller: $controllerName.$methodName
        |   Request   : $requestDetails
        |   User      : $userContext
        |   Exception : ${exception::class.simpleName} - ${exception.message ?: "Internal server error."}
        """.trimMargin()
    }
}

private fun formatRequestDetails(request: HttpServletRequest): String {
    val params = request.parameterMap?.entries?.stream()
        ?.map { "${it.key}: ${it.value.joinToString()}" }
        ?.collect(Collectors.joining(", ")) ?: ""

    val queryString = if (params.isNotEmpty()) "?$params" else ""

    return "${request.method} ${request.requestURI}$queryString (Client: ${getClientIp(request)}"
}

private fun getClientIp(request: HttpServletRequest): String {
    return request.getHeader("X-Forwarded-For")?.split(",")?.firstOrNull()?.trim()
        ?: request.remoteAddr
}

private fun getUserContext(): String {
    // I'm not sure about this, since I don't know how UserContextUtils will look like in the future when we implement it. Maybe it will look similar to this file?

//    val email = UserContextUtils.getCurrentUserEmail()
//    val userId = UserContextUtils.getCurrentUserId() // Assuming this might return null if not authenticated
//
//    return when {
//        email != null && userId != null -> "$email (ID: $userId)"
//        email != null -> email
//        userId != null -> "User ID: $userId"
//        else -> "Anonymous / Unauthenticated"
//    }

    return "😢 Not implemented"
}

private fun formatDetails(details: Map<String, Any>?): String {
    if (details.isNullOrEmpty()) {
        return "None"
    }
    return details.entries.joinToString(separator = "\n|     - ", prefix = "\n|     - ") {
        "${it.key}: ${it.value}"
    }
}




================================================
File: dev/cnpe/ventescabekotlin/shared/infrastructure/web/advice/GlobalExceptionHandler.kt
================================================
package dev.cnpe.ventescabekotlin.shared.infrastructure.web.advice

import com.fasterxml.jackson.databind.exc.InvalidFormatException
import dev.cnpe.ventescabekotlin.shared.application.dto.ApiResult
import dev.cnpe.ventescabekotlin.shared.application.dto.ErrorResponse
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.ErrorCode
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.*
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.servlet.http.HttpServletRequest
import jakarta.validation.ConstraintViolationException
import org.springframework.context.MessageSource
import org.springframework.context.NoSuchMessageException
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.validation.FieldError
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.MissingServletRequestParameterException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.method.HandlerMethod
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import java.time.Instant

private val log = KotlinLogging.logger { }

@RestControllerAdvice
class GlobalExceptionHandler(
    private val messageSource: MessageSource
) {

    companion object {
        private const val DEFAULT_ERROR_PREFIX = "error."
        private const val DEFAULT_ERROR_MESSAGE = "Internal Server Error"
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationExceptions(
        ex: MethodArgumentNotValidException,
        request: HttpServletRequest,
        handlerMethod: HandlerMethod?
    ): ResponseEntity<ApiResult<Any>> {
        val errorCode = CONSTRAINT_VIOLATION
        val status = errorCode.status

        val fieldErrors = ex.bindingResult.fieldErrors.associate { fieldError ->
            fieldError.field to getFieldErrorDefaultMessage(fieldError)
        }

        val details = mapOf(
            "fieldErrors" to fieldErrors,
            "totalErrors" to fieldErrors.size
        )
        logClientError(ex, request, handlerMethod, status, errorCode.name, details)

        return buildErrorResponse(request, errorCode, details)
    }

    // Handles validation annotations directly on parameters (e.g., @RequestParam @Size...)
    // Can overlap with MethodArgumentNotValidException but catches slightly different cases
    @ExceptionHandler(ConstraintViolationException::class)
    fun handleConstraintViolationException(
        ex: ConstraintViolationException,
        request: HttpServletRequest,
        handlerMethod: HandlerMethod?
    ): ResponseEntity<ApiResult<Any>> {
        val errorCode = CONSTRAINT_VIOLATION
        val status = errorCode.status

        val violations = ex.constraintViolations.associate { violation ->
            val propertyPath = violation.propertyPath.toString()
            val field = propertyPath.substringAfterLast(".", propertyPath)
            field to violation.message
        }
        val details = mapOf(
            "fieldErrors" to violations,
            "totalErrors" to violations.size
        )

        logClientError(ex, request, handlerMethod, status, errorCode.name, details)
        return buildErrorResponse(request, errorCode, details)
    }

    @ExceptionHandler(MissingServletRequestParameterException::class)
    fun handleMissingParams(
        ex: MissingServletRequestParameterException,
        request: HttpServletRequest,
        handlerMethod: HandlerMethod?
    ): ResponseEntity<ApiResult<Any>> {
        val errorCode = CONSTRAINT_VIOLATION
        val status = errorCode.status
        val fieldErrors = mapOf(ex.parameterName to "Parameter is required")
        val details = mapOf(
            "fieldErrors" to fieldErrors,
            "totalErrors" to 1
        )
        logClientError(ex, request, handlerMethod, status, errorCode.name, details)
        return buildErrorResponse(request, errorCode, details, ex.parameterName)
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException::class)
    fun handleMethodArgumentTypeMismatch(
        ex: MethodArgumentTypeMismatchException,
        request: HttpServletRequest,
        handlerMethod: HandlerMethod?
    ): ResponseEntity<ApiResult<Any>> {
        val errorCode = DATA_TYPE_MISMATCH
        val status = errorCode.status
        val paramName = ex.name
        val requiredType = ex.requiredType?.simpleName ?: "unknown"
        val invalidValue = ex.value?.toString() ?: "null"

        val details = mutableMapOf<String, Any>(
            "parameterName" to paramName,
            "requiredType" to requiredType,
            "invalidValue" to invalidValue
        )

        addEnumDetailsIfNeeded(details, ex.requiredType)

        logClientError(ex, request, handlerMethod, status, errorCode.name, details)
        return buildErrorResponse(request, errorCode, details, invalidValue, paramName, requiredType)
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleHttpMessageNotReadable(
        ex: HttpMessageNotReadableException,
        request: HttpServletRequest,
        handlerMethod: HandlerMethod?
    ): ResponseEntity<ApiResult<Any>> {
        val status = HttpStatus.BAD_REQUEST

        if (ex.cause is InvalidFormatException) {
            val ife = ex.cause as InvalidFormatException
            val errorCode = DATA_TYPE_MISMATCH
            val fieldPath = ife.path.joinToString(".") { it.fieldName ?: "[index ${it.index}]" }
            val targetType = ife.targetType?.simpleName ?: "unknown"
            val invalidValue = ife.value?.toString() ?: "null"

            val details = mutableMapOf<String, Any>(
                "fieldPath" to fieldPath,
                "requiredType" to targetType,
                "invalidValue" to invalidValue
            )
            addEnumDetailsIfNeeded(details, ife.targetType)

            logClientError(ex, request, handlerMethod, status, errorCode.name, details)
            return buildErrorResponse(request, errorCode, details, invalidValue, fieldPath, targetType)
        } else {
            val errorCode = INVALID_DATA
            logClientError(ex, request, handlerMethod, status, errorCode.name)
            return buildErrorResponse(request, errorCode, null, "Request body is malformed or unreadable")
        }
    }

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(
        ex: DomainException,
        request: HttpServletRequest,
        handlerMethod: HandlerMethod?
    ): ResponseEntity<ApiResult<Any>> {
        val errorCode = ex.errorCode
        val status = errorCode.status
        val details = ex.details

        if (status.is5xxServerError) {
            logServerError(ex, request, handlerMethod, status, errorCode.name)
        } else {
            logClientError(ex, request, handlerMethod, status, errorCode.name, details)
        }

        return buildErrorResponse(request, errorCode, details, *ex.parameters)
    }

    @ExceptionHandler(Exception::class)
    fun handleAnyOtherException(
        ex: Exception,
        request: HttpServletRequest,
        handlerMethod: HandlerMethod?
    ): ResponseEntity<ApiResult<Any>> {
        val errorCode = GENERAL
        val status = errorCode.status

        logServerError(ex, request, handlerMethod, status, errorCode.name)

        return buildErrorResponse(request, errorCode, null)
    }


    /**
     * Adds enum value details to the details map if the target type is an enum.
     */
    private fun addEnumDetailsIfNeeded(details: MutableMap<String, Any>, targetType: Class<*>?) {
        targetType?.takeIf { it.isEnum }?.let { enumClass ->
            details["allowedValues"] = enumClass.enumConstants.map { it.toString() }
        }
    }

    /**
     * Builds the standardized ResponseEntity containing the ApiResult with ErrorResponse.
     */
    private fun buildErrorResponse(
        request: HttpServletRequest,
        errorCode: ErrorCode,
        details: Map<String, Any>?,
        vararg messageParameters: String
    ): ResponseEntity<ApiResult<Any>> {


        val resolvedMessage = resolveMessage(errorCode, *messageParameters)
        val errorResponse = ErrorResponse(
            path = request.requestURI,
            status = errorCode.status.value(),
            code = errorCode.name,
            message = resolvedMessage,
            timestamp = Instant.now(),
            details = details
        )

        val apiResult = ApiResult.error<Any>(errorResponse)
        return ResponseEntity(apiResult, errorCode.status)
    }

    /**
     * Resolves the user-facing error message using MessageSource.
     */
    private fun resolveMessage(errorCode: ErrorCode, vararg parameters: String): String? {
        val messageKey = DEFAULT_ERROR_PREFIX + errorCode.name //error.RESOURCE_NOT_FOUND
        return try {
            messageSource.getMessage(messageKey, parameters.ifEmpty { null }, LocaleContextHolder.getLocale())
        } catch (e: NoSuchMessageException) {
            log.warn { "Missing message key for error code ${errorCode.name} in message source. Key: '$messageKey'" }

            when (errorCode) {
                RESOURCE_NOT_FOUND -> "Resource not found."
                CONSTRAINT_VIOLATION -> "Validation failed."
                DATA_TYPE_MISMATCH -> "Data type mismatch."
                DUPLICATED_RESOURCE -> "Duplicated resource."
                OPERATION_NOT_ALLOWED -> "Operation not allowed."
                INVALID_DATA -> "Invalid data."
                INVALID_STATE -> "Invalid state."
                else -> DEFAULT_ERROR_MESSAGE
            }
        } catch (e: Exception) {
            log.error(e) { "Error resolving message for error code ${errorCode.name}." }
            DEFAULT_ERROR_MESSAGE
        }
    }

    /**
     * Resolves the default message for a FieldError using MessageSource, falling back to the error's default message.
     */
    private fun getFieldErrorDefaultMessage(error: FieldError): String {
        return try {
            messageSource.getMessage(error, LocaleContextHolder.getLocale())
        } catch (e: NoSuchMessageException) {
            //fallback to the msg defined in the validation annotation
            error.defaultMessage ?: "Invalid value."
        } catch (e: Exception) {
            log.error(e) { "Error resolving field error message for field '${error.field}'." }
            error.defaultMessage ?: "Invalid value."
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/shared/infrastructure/web/filters/MDCLoggingFilter.kt
================================================
package dev.cnpe.ventescabekotlin.shared.infrastructure.web.filters

import dev.cnpe.ventescabekotlin.security.context.UserContext
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.servlet.FilterChain
import jakarta.servlet.ServletException
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.slf4j.MDC
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter
import java.io.IOException
import java.util.*

private val log = KotlinLogging.logger {}

@Component
class MDCLoggingFilter(
    private val userContext: UserContext
) : OncePerRequestFilter() {

    companion object {
        private const val REQUEST_ID = "requestId"
        private const val USER_ID = "userId"
        private const val TENANT_ID = "tenantId"
        private const val REQUEST_URI = "requestUri"
        private const val REQUEST_METHOD = "requestMethod"
        private const val MAX_UA_LENGTH = 60
    }

    @Throws(ServletException::class, IOException::class)
    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        val requestId = UUID.randomUUID().toString().substring(0, 8)
        val startTime = System.currentTimeMillis()

        try {
            MDC.put(REQUEST_ID, requestId)
            MDC.put(REQUEST_URI, request.requestURI)
            MDC.put(REQUEST_METHOD, request.method)

            response.setHeader("X-Request-Id", requestId)

            userContext.userId?.let { MDC.put(USER_ID, it) }
            userContext.tenantId?.let { MDC.put(TENANT_ID, it) }

            if (log.isDebugEnabled()) {
                log.debug {
                    """
                    |📥 Request Started:
                    |   URI     : ${request.method} ${request.requestURI}
                    |   Trace ID: $requestId
                    |   Client  : ${getClientInfo(request)}
                    """.trimMargin()
                }
            }

            filterChain.doFilter(request, response)

        } finally {
            val duration = System.currentTimeMillis() - startTime
            val status = response.status
            val emoji = getStatusEmoji(status)

            log.info {
                """
                |${emoji} Request Completed:
                |   URI     : ${request.method} ${request.requestURI}
                |   Status  : $status
                |   Time    : ${duration}ms
                |   Trace ID: $requestId
                """.trimMargin()
            }
            MDC.clear()
        }
    }

    private fun getStatusEmoji(status: Int): String = when {
        status < 300 -> "✅" // 2xx Success
        status < 400 -> "↪️" // 3xx Redirect
        status < 500 -> "⚠️" // 4xx Client Error
        else -> "🔥" // 5xx Server Error
    }

    private fun getClientInfo(request: HttpServletRequest): String {
        val userAgent = request.getHeader("User-Agent")
        val clientIp = getClientIp(request)
        return "$clientIp (UA: ${abbreviateUserAgent(userAgent)})"
    }

    private fun getClientIp(request: HttpServletRequest): String {
        return request.getHeader("X-Forwarded-For")?.split(",")?.firstOrNull()?.trim()
            ?: request.remoteAddr
    }

    private fun abbreviateUserAgent(userAgent: String?): String {
        return userAgent?.take(MAX_UA_LENGTH)?.let { if (userAgent.length > MAX_UA_LENGTH) "$it..." else it }
            ?: "Unknown"
    }
}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/api/SupplierInfoPort.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.api

/**
 * Port defining operations for retrieving basic Supplier information needed by other modules.
 */
interface SupplierInfoPort {

    /**
     * Retrieves the unique identifier of the default supplier configured for the tenant.
     *
     * @return The ID of the default supplier.
     * @throws DomainException (e.g., RESOURCE_NOT_FOUND) if no default supplier is configured or found.
     */
    fun getDefaultSupplierId(): Long


    /**
     * Retrieves the name of the supplier based on the given supplier ID.
     *
     * @param id The unique identifier of the supplier whose name is to be retrieved.
     * @return The name of the supplier corresponding to the provided ID.
     * @throws DomainException (e.g., RESOURCE_NOT_FOUND) if no supplier is found with the given ID.
     */
    fun getSupplierNameById(id: Long): String


}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/dto/request/CreateSupplierRequest.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import org.hibernate.validator.constraints.Length

@Schema(description = "Request payload for creating a new supplier.")
data class CreateSupplierRequest(

    @field:NotBlank
    @field:Length(min = 2, max = 50)
    @Schema(
        description = "The primary name of the supplier.",
        example = "Acme Corporation",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val name: String
)

================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/dto/request/UpdateSupplierRequest.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.dto.request

import dev.cnpe.ventescabekotlin.shared.application.validation.NotBlankIfPresent
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import org.hibernate.validator.constraints.Length
import org.hibernate.validator.constraints.URL

@Schema(description = "Request payload for updating supplier details. All fields are optional (provide only fields to be updated).")
data class UpdateSupplierRequest(

    @field:NotBlankIfPresent
    @field:Length(min = 2, max = 50)
    @Schema(
        description = "Updated legal business name.",
        example = "Acme Corp Ltd.",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val name: String?,

    @field:NotBlankIfPresent
    @Length(min = 1, max = 50)
    @Schema(
        description = "Updated first name of the representative.",
        example = "John",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val representativeFirstName: String?,

    @field:NotBlankIfPresent
    @Length(min = 1, max = 50)
    @Schema(
        description = "Updated last name of the representative.",
        example = "Doe",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val representativeLastName: String?,

    @field:NotBlankIfPresent
    @Length(min = 2, max = 50)
    @Schema(
        description = "Updated personal identification number of the representative.",
        example = "ID123456",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val representativePersonalId: String?,

    @field:NotBlankIfPresent
    @Length(min = 7, max = 20)
    @Schema(
        description = "Updated primary phone number.",
        example = "+1-555-123-4567",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val phoneNumber: String?,

    @field:NotBlankIfPresent
    @Email
    @Schema(
        description = "Updated primary email address.",
        example = "contact@acmecorp.com",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val email: String?,

    @field:NotBlankIfPresent
    @field:URL
    @Length(min = 5, max = 100)
    @Schema(
        description = "Updated company website URL.",
        example = "https://www.acmecorp.com",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val website: String?,

    @field:NotBlankIfPresent
    @Length(min = 2, max = 100)
    @Schema(
        description = "Updated street address.",
        example = "123 Main St",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val addressStreet: String?,

    @field:NotBlankIfPresent
    @Length(min = 2, max = 50)
    @Schema(description = "Updated city.", example = "Anytown", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
    val addressCity: String?,

    @field:NotBlankIfPresent
    @Length(min = 2, max = 50)
    @Schema(description = "Updated country.", example = "USA", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
    val addressCountry: String?,

    @field:NotBlankIfPresent
    @Length(min = 3, max = 20)
    @Schema(description = "Updated postal code.", example = "90210", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
    val addressPostalCode: String?
)


================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/dto/request/UpdateSupplierStatusRequest.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import org.jetbrains.annotations.NotNull

@Schema(description = "Request payload to activate or deactivate a supplier.")
data class UpdateSupplierStatusRequest(

    @field:NotNull
    @Schema(
        description = "Set to true to activate the supplier, false to deactivate.",
        example = "true",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isActive: Boolean

)


================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/dto/response/SupplierDetailedResponse.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.dto.response

import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import dev.cnpe.ventescabekotlin.shared.domain.vo.Address
import dev.cnpe.ventescabekotlin.shared.domain.vo.ContactInfo
import dev.cnpe.ventescabekotlin.shared.domain.vo.PersonalInfo
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Complete detailed information about a supplier.")
data class SupplierDetailedResponse(

    @Schema(
        description = "Unique identifier of the supplier.",
        example = "55",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val id: Long,

    @Schema(
        description = "The legal business name of the supplier.",
        example = "Global Tech Supplies",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val name: String,

    @Schema(
        description = "Details of the supplier representative.",
        requiredMode = Schema.RequiredMode.NOT_REQUIRED
    )
    val representative: PersonalInfo,

    @Schema(
        description = "Contact details for the supplier.",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val contactInfo: ContactInfo,

    @Schema(
        description = "Primary address of the supplier.",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val address: Address,

    @Schema(
        description = "Indicates if the supplier is currently active.",
        example = "true",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isActive: Boolean,

    @Schema(description = "Audit information.", requiredMode = Schema.RequiredMode.REQUIRED)
    val auditData: ResourceAuditData
)


================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/dto/response/SupplierSummaryResponse.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import java.time.OffsetDateTime

@Schema(description = "Basic summary information for a supplier, suitable for lists.")
data class SupplierSummaryResponse(

    @Schema(
        description = "Unique identifier of the supplier.",
        example = "55",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val id: Long,

    @Schema(
        description = "The legal business name of the supplier.",
        example = "Global Tech Supplies",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val name: String,

    @Schema(
        description = "Indicates if the supplier is currently active.",
        example = "true",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isActive: Boolean,

    @Schema(
        description = "Indicates if this is the default supplier.",
        example = "false",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val isDefault: Boolean,

    @Schema(
        description = "Timestamp when the supplier was created.",
        format = "date-time",
        requiredMode = Schema.RequiredMode.REQUIRED
    )
    val createdAt: OffsetDateTime
)


================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/events/SupplierDeleteAttemptedEvent.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.events

data class SupplierDeleteAttemptedEvent(
    val supplierId: Long
)


================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/exception/SupplierOperationNotAllowedReason.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.OperationNotAllowedReason
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Reasons why a supplier operation is not allowed")
enum class SupplierOperationNotAllowedReason : OperationNotAllowedReason {
    @Schema(description = "Cannot operate on the default supplier.")
    IS_DEFAULT_SUPPLIER,

    @Schema(description = "Cannot deactivate the default supplier.")
    CANNOT_DEACTIVATE_DEFAULT_SUPPLIER,

    @Schema(description = "Cannot delete supplier because it has associated products.")
    SUPPLIER_HAS_PRODUCTS
}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/mapper/SupplierMapper.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.mapper

import dev.cnpe.ventescabekotlin.shared.application.dto.ResourceAuditData
import dev.cnpe.ventescabekotlin.suppliers.application.dto.response.SupplierDetailedResponse
import dev.cnpe.ventescabekotlin.suppliers.application.dto.response.SupplierSummaryResponse
import dev.cnpe.ventescabekotlin.suppliers.domain.Supplier
import org.springframework.stereotype.Component

@Component
class SupplierMapper {

    /**
     * Transforms a Supplier entity into a SupplierSummaryResponse, providing a summary view of the supplier.
     *
     * @param supplier the Supplier entity containing detailed supplier information
     * @return a SupplierSummaryResponse with basic summary details of the supplier
     */
    fun toSummary(supplier: Supplier): SupplierSummaryResponse {
        return SupplierSummaryResponse(
            id = supplier.id!!,
            name = supplier.name,
            isActive = supplier.isActive,
            isDefault = supplier.isDefault,
            createdAt = supplier.createdAt
        )
    }

    /**
     * Converts a Supplier entity into a detailed response representation.
     *
     * @param supplier the Supplier entity containing detailed supplier information
     * @return a SupplierDetailedResponse object with complete details about the supplier
     */
    fun toDetailed(supplier: Supplier): SupplierDetailedResponse {
        return SupplierDetailedResponse(
            id = supplier.id!!,
            name = supplier.name,
            representative = supplier.representativeInfo,
            contactInfo = supplier.contactInfo,
            address = supplier.address,
            isActive = supplier.isActive,
            auditData = ResourceAuditData.fromBaseEntity(supplier)
        )
    }

}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/service/SupplierInfoAdapter.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.service

import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.GeneralErrorCode.RESOURCE_NOT_FOUND
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import dev.cnpe.ventescabekotlin.suppliers.application.api.SupplierInfoPort
import dev.cnpe.ventescabekotlin.suppliers.infrastructure.persistence.SupplierRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.data.repository.findByIdOrNull
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
@Transactional(readOnly = true)
class SupplierInfoAdapter(
    private val supplierRepository: SupplierRepository
) : SupplierInfoPort {

    override fun getDefaultSupplierId(): Long {
        log.debug { "Attempting to find default supplier ID" }
        val defaultSupplier = supplierRepository.getSupplierByDefaultIsTrue()
            ?: run {
                log.warn { "Default supplier not found in the database." }
                throw DomainException(RESOURCE_NOT_FOUND, details = mapOf("defaultSupplier" to "true"))
            }

        log.info { "Found default supplier ID: ${defaultSupplier.id!!}" }
        return defaultSupplier.id!!
    }

    override fun getSupplierNameById(id: Long): String {
        log.debug { "Fetching supplier name for ID: $id" }
        val supplier = supplierRepository.findByIdOrNull(id)
            ?: run {
                log.warn { "Supplier not found for ID: $id" }
                throw createResourceNotFoundException("Supplier", id)
            }

        log.trace { "Found supplier name '${supplier.name}' for ID: $id" }
        return supplier.name
    }
}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/application/service/SupplierService.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.application.service

import dev.cnpe.ventescabekotlin.business.event.BusinessActivatedEvent
import dev.cnpe.ventescabekotlin.catalog.api.ProductInfoPort
import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.shared.application.exception.createDuplicatedResourceException
import dev.cnpe.ventescabekotlin.shared.application.exception.createOperationNotAllowedException
import dev.cnpe.ventescabekotlin.shared.application.exception.createResourceNotFoundException
import dev.cnpe.ventescabekotlin.suppliers.application.dto.request.CreateSupplierRequest
import dev.cnpe.ventescabekotlin.suppliers.application.dto.request.UpdateSupplierRequest
import dev.cnpe.ventescabekotlin.suppliers.application.dto.request.UpdateSupplierStatusRequest
import dev.cnpe.ventescabekotlin.suppliers.application.dto.response.SupplierDetailedResponse
import dev.cnpe.ventescabekotlin.suppliers.application.dto.response.SupplierSummaryResponse
import dev.cnpe.ventescabekotlin.suppliers.application.events.SupplierDeleteAttemptedEvent
import dev.cnpe.ventescabekotlin.suppliers.application.exception.SupplierOperationNotAllowedReason.*
import dev.cnpe.ventescabekotlin.suppliers.application.mapper.SupplierMapper
import dev.cnpe.ventescabekotlin.suppliers.domain.Supplier
import dev.cnpe.ventescabekotlin.suppliers.domain.factory.SupplierFactory
import dev.cnpe.ventescabekotlin.suppliers.infrastructure.persistence.SupplierRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.context.ApplicationEventPublisher
import org.springframework.context.MessageSource
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.data.repository.findByIdOrNull
import org.springframework.modulith.events.ApplicationModuleListener
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
@Transactional
class SupplierService(
    private val supplierRepository: SupplierRepository,
    private val supplierMapper: SupplierMapper,
    private val supplierFactory: SupplierFactory,
    private val eventPublisher: ApplicationEventPublisher,
    private val productInfoPort: ProductInfoPort,
    private val messageSource: MessageSource
) {

    /**
     * Registers a new supplier in the system.
     *
     * @param request The supplier creation details
     * @return A summary of the created supplier
     * @throws DomainException if a supplier with the same name already exists
     */
    fun registerSupplier(request: CreateSupplierRequest): SupplierSummaryResponse {
        log.debug { "Registering supplier with name: ${request.name}" }
        validateSupplierName(request.name)

        val newSupplier = supplierFactory.create(request.name)
        val savedSupplier = supplierRepository.save(newSupplier)

        log.info { "Supplier registered: ${savedSupplier.name} (ID: ${savedSupplier.id})" }
        return supplierMapper.toSummary(savedSupplier)
    }

    /**
     * Retrieves detailed information about a specific supplier.
     *
     * @param id The supplier's unique identifier
     * @return Detailed information about the supplier
     * @throws DomainException if the supplier is not found
     */
    @Transactional(readOnly = true)
    fun getSupplierDetails(id: Long): SupplierDetailedResponse {
        log.debug { "Fetching supplier details for ID: $id" }
        val supplier = findSupplierByIdOrThrow(id)
        return supplierMapper.toDetailed(supplier)
    }

    /**
     * Retrieves a list of all suppliers in the system.
     *
     * @return List of supplier summaries
     */
    @Transactional(readOnly = true)
    fun getAllSuppliers(): List<SupplierSummaryResponse> {
        log.debug { "Fetching all suppliers" }
        return supplierRepository.findAll().map { supplierMapper.toSummary(it) }
    }

    /**
     * Deletes a supplier from the system.
     *
     * @param id The supplier's unique identifier
     * @throws DomainException if the supplier is not found or if attempting to delete the default supplier or has associated products.
     */
    fun deleteSupplier(id: Long) {
        log.debug { "Attempting to delete supplier ID: $id" }
        val supplier = findSupplierByIdOrThrow(id)

        if (supplier.isDefault) {
            log.warn { "Attempted to delete default supplier ID: $id. Operation forbidden." }
            throw createOperationNotAllowedException(reason = IS_DEFAULT_SUPPLIER, entityId = supplier.id!!)
        }

        val productCount = productInfoPort.countProductsBySupplierId(id)
        if (productCount > 0) {
            log.warn { "Attempted to delete supplier ID: $id which has $productCount associated product(s). Operation forbidden." }
            throw createOperationNotAllowedException(
                reason = SUPPLIER_HAS_PRODUCTS,
                entityId = supplier.id!!,
                additionalDetails = mapOf("productCount" to productCount),
                parameters = arrayOf(productCount.toString())
            )
        }


        log.warn { "Deleting supplier: ${supplier.name} (ID: ${supplier.id})" }
        eventPublisher.publishEvent(SupplierDeleteAttemptedEvent(supplier.id!!))
        supplierRepository.delete(supplier)
        log.info { "Deleted supplier: ${supplier.name} (ID: ${supplier.id})" }
    }

    /**
     * Updates supplier information.
     *
     * @param id The supplier's unique identifier
     * @param request The update details
     * @return Updated supplier information
     * @throws DomainException if the supplier is not found
     * @throws DomainException if the new name conflicts with an existing supplier
     */
    fun updateSupplier(id: Long, request: UpdateSupplierRequest): SupplierDetailedResponse {
        log.debug { "Updating supplier with ID: $id with data: $request" }
        val supplier = findSupplierByIdOrThrow(id)

        updateSupplierFromRequest(supplier, request)

        val updatedSupplier = supplierRepository.save(supplier)
        log.info { "Supplier updated: ${updatedSupplier.name} (ID: ${updatedSupplier.id})" }
        return supplierMapper.toDetailed(updatedSupplier)
    }

    /**
     * Updates the active status of a supplier.
     *
     * @param id The supplier's unique identifier
     * @param request The status update details
     * @throws DomainException if the supplier is not found
     * @throws DomainException if attempting to deactivate the default supplier
     */
    fun updateSupplierStatus(id: Long, request: UpdateSupplierStatusRequest) {
        log.debug { "Updating status for supplier ID: $id to isActive=${request.isActive}" }
        val supplier = findSupplierByIdOrThrow(id)

        if (supplier.isDefault && !request.isActive) {
            throw createOperationNotAllowedException(CANNOT_DEACTIVATE_DEFAULT_SUPPLIER, supplier.id!!)
        }
        if (supplier.isActive != request.isActive) {
            supplier.isActive = request.isActive
            supplierRepository.save(supplier)
            log.info { "Supplier ID: $id status updated to isActive=${supplier.isActive}" }
        } else {
            log.info { "Supplier ID: $id status already isActive=${request.isActive}. No change." }
        }
    }

    /**
     * Handles business activation events by creating a default supplier if none exists.
     *
     * @param event The business activation event
     */
    @ApplicationModuleListener
    fun onBusinessActivated(event: BusinessActivatedEvent) {
        log.debug { "Received BusinessActivatedEvent for supplier check: ${event.businessName}" }
        if (supplierRepository.existsDefaultSupplier()) {
            log.info { "Default supplier already exists." }
            return
        }

        val locale = LocaleContextHolder.getLocale()

        val suffix = messageSource.getMessage(
            "default.supplier.suffix.self",
            null,
            "(Self-Supply)",
            locale
        )

        val defaultSupplierName = "${event.businessName} $suffix"
        log.info { "Creating default self-supplier: $defaultSupplierName" }

        val defaultSupplier = supplierFactory.create(defaultSupplierName).apply {
            isDefault = true
            isActive = true
        }
        val saved = supplierRepository.save(defaultSupplier)
        log.info { "🚚 Created default supplier: ${saved.name} (ID: ${saved.id})" }
    }


    // *******************************
    // 🔰 Private Helpers
    // *******************************

    private fun findSupplierByIdOrThrow(id: Long): Supplier {
        return supplierRepository.findByIdOrNull(id)
            ?: throw createResourceNotFoundException("Supplier", id)
    }

    private fun validateSupplierName(name: String) {
        if (supplierRepository.existsByName(name)) {
            throw createDuplicatedResourceException("name", name)
        }
    }

    private fun updateSupplierFromRequest(supplier: Supplier, request: UpdateSupplierRequest) {
        request.name?.let { newName ->
            if (supplier.name != newName && supplierRepository.existsByName(newName)) {
                throw createDuplicatedResourceException("name", newName)
            }
            supplier.name = newName
        }

        val currentPersonalInfo = supplier.representativeInfo
        val updatedPersonalInfo = currentPersonalInfo.copy(
            firstName = request.representativeFirstName ?: currentPersonalInfo.firstName,
            lastName = request.representativeLastName ?: currentPersonalInfo.lastName,
            personalId = request.representativePersonalId ?: currentPersonalInfo.personalId
        )
        if (updatedPersonalInfo != currentPersonalInfo) {
            supplier.representativeInfo = updatedPersonalInfo
        }

        val currentContactInfo = supplier.contactInfo
        val updatedContactInfo = currentContactInfo.copy(
            phoneNumber = request.phoneNumber ?: currentContactInfo.phoneNumber,
            email = request.email ?: currentContactInfo.email,
            website = request.website ?: currentContactInfo.website
        )
        if (updatedContactInfo != currentContactInfo) {
            supplier.contactInfo = updatedContactInfo
        }

        val currentAddress = supplier.address
        val updatedAddress = currentAddress.copy(
            street = request.addressStreet ?: currentAddress.street,
            city = request.addressCity ?: currentAddress.city,
            country = request.addressCountry ?: currentAddress.country,
            postalCode = request.addressPostalCode ?: currentAddress.postalCode
        )
        if (updatedAddress != currentAddress) {
            supplier.address = updatedAddress
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/domain/Supplier.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.domain

import dev.cnpe.ventescabekotlin.shared.domain.model.BaseEntity
import dev.cnpe.ventescabekotlin.shared.domain.vo.Address
import dev.cnpe.ventescabekotlin.shared.domain.vo.ContactInfo
import dev.cnpe.ventescabekotlin.shared.domain.vo.PersonalInfo
import jakarta.persistence.*

@Entity
@Table(name = "suppliers")
class Supplier(

    @Column(name = "business_name", nullable = false)
    var name: String, // This is the name of the supplier's business, not to be confused with the business module

    @Embedded
    @AttributeOverrides(
        AttributeOverride(name = "firstName", column = Column(name = "representative_name")),
        AttributeOverride(name = "lastName", column = Column(name = "representative_last_name")),
        AttributeOverride(name = "personalId", column = Column(name = "representative_personal_id"))
    )
    var representativeInfo: PersonalInfo = PersonalInfo.empty(),

    @Embedded
    var contactInfo: ContactInfo = ContactInfo.empty(),

    @Embedded
    var address: Address = Address.empty(),

    @Column(name = "is_active", nullable = false)
    var isActive: Boolean = true,

    @Column(name = "is_default", nullable = false)
    var isDefault: Boolean = false,

    id: Long? = null,
    version: Int = 0
) : BaseEntity(id, version)

================================================
File: dev/cnpe/ventescabekotlin/suppliers/domain/factory/SupplierFactory.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.domain.factory

import dev.cnpe.ventescabekotlin.suppliers.domain.Supplier
import org.springframework.stereotype.Component

@Component
class SupplierFactory(

) {

    /**
     * Creates a basic, active Supplier instance with empty contact/personal/address info.
     * The business name is sanitized (capitalized, trimmed).
     *
     * @param name The legal business name of the supplier.
     * @return A new Supplier instance.
     */
    fun create(name: String): Supplier {
        require(name.isNotBlank()) { "Supplier business name cannot be blank" }

        val sanitizedName = name.trim().replaceFirstChar { it.uppercase() }
        return Supplier(
            name = sanitizedName,
        )
    }

}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/infrastructure/persistence/SupplierRepository.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.infrastructure.persistence

import dev.cnpe.ventescabekotlin.suppliers.domain.Supplier
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query

interface SupplierRepository : JpaRepository<Supplier, Long> {

    fun existsByName(name: String): Boolean

    @Query(
        """
            select count(s) > 0 
            from Supplier s
            where s.isDefault = true
        """
    )
    fun existsDefaultSupplier(): Boolean

    fun getSupplierByDefaultIsTrue(): Supplier?
}

================================================
File: dev/cnpe/ventescabekotlin/suppliers/infrastructure/web/SupplierController.kt
================================================
package dev.cnpe.ventescabekotlin.suppliers.infrastructure.web

import dev.cnpe.ventescabekotlin.shared.application.dto.ApiResult
import dev.cnpe.ventescabekotlin.suppliers.application.dto.request.CreateSupplierRequest
import dev.cnpe.ventescabekotlin.suppliers.application.dto.request.UpdateSupplierRequest
import dev.cnpe.ventescabekotlin.suppliers.application.dto.request.UpdateSupplierStatusRequest
import dev.cnpe.ventescabekotlin.suppliers.application.dto.response.SupplierDetailedResponse
import dev.cnpe.ventescabekotlin.suppliers.application.dto.response.SupplierSummaryResponse
import dev.cnpe.ventescabekotlin.suppliers.application.service.SupplierService
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.ArraySchema
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.net.URI

@RestController
@RequestMapping("/suppliers")
@Tag(name = "Suppliers", description = "Manage suppliers for the business.")
class SupplierController(
    private val supplierService: SupplierService
) {

    @PostMapping
    @Operation(summary = "Register a new supplier")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201", description = "Supplier created successfully",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = SupplierSummaryResponse::class)
                )]
            ),
            ApiResponse(
                responseCode = "400", description = "Invalid input data",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "409", description = "Duplicate supplier name",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
        ]
    )
    fun registerSupplier(@Valid @RequestBody request: CreateSupplierRequest): ResponseEntity<SupplierSummaryResponse> {
        val created = supplierService.registerSupplier(request)
        return ResponseEntity.created(URI.create("/suppliers/${created.id}")).body(created)
    }

    @GetMapping
    @Operation(summary = "Get all supplier summaries")
    @ApiResponse(
        responseCode = "200", description = "List of supplier summaries retrieved",
        content = [Content(
            mediaType = "application/json",
            array = ArraySchema(schema = Schema(implementation = SupplierSummaryResponse::class))
        )]
    )
    fun getAllSuppliers(): List<SupplierSummaryResponse> {
        return supplierService.getAllSuppliers()
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get supplier details by ID")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200", description = "Supplier found",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = SupplierDetailedResponse::class)
                )]
            ),
            ApiResponse(
                responseCode = "404", description = "Supplier not found",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
        ]
    )
    fun getSupplierDetails(@PathVariable id: Long): SupplierDetailedResponse {
        return supplierService.getSupplierDetails(id)
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update supplier details")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200", description = "Supplier updated successfully",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = SupplierDetailedResponse::class)
                )]
            ),
            ApiResponse(
                responseCode = "400", description = "Invalid input data",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "404", description = "Supplier not found",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "409", description = "Duplicate supplier name",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
        ]
    )
    fun updateSupplier(
        @PathVariable id: Long,
        @Valid @RequestBody request: UpdateSupplierRequest
    ): SupplierDetailedResponse {
        return supplierService.updateSupplier(id, request)
    }

    @PutMapping("/{id}/status")
    @Operation(summary = "Update supplier status (activate/deactivate)")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "204", description = "Supplier status updated successfully"),
            ApiResponse(
                responseCode = "400", description = "Invalid request body",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "404", description = "Supplier not found",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "405", description = "Operation Not Allowed (e.g., deactivating default)",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
        ]
    )
    fun updateSupplierStatus(
        @PathVariable id: Long,
        @Valid @RequestBody request: UpdateSupplierStatusRequest
    ) {
        supplierService.updateSupplierStatus(id, request)
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete a supplier")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "204", description = "Supplier deleted successfully"),
            ApiResponse(
                responseCode = "404", description = "Supplier not found",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            ),
            ApiResponse(
                responseCode = "405", description = "Operation Not Allowed (e.g., deleting default)",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = ApiResult::class))]
            )
        ]
    )
    fun deleteSupplier(@PathVariable id: Long) {
        supplierService.deleteSupplier(id)
    }
}

================================================
File: dev/cnpe/ventescabekotlin/tenant/README.md
================================================
# Multi-Tenancy Implementation (Database per Tenant)

This document explains the multi-tenancy architecture implemented in the Ventesca backend, following the **Database per Tenant** strategy using Spring Boot, JPA/Hibernate, and Kotlin.

## Overview

Each "business" registered in Ventesca is treated as a separate tenant and gets its own dedicated PostgreSQL database instance (e.g., `ventesca_tenantA_db`, `ventesca_tenantB_db`). This provides strong data isolation between tenants. A central "master" database stores shared information, including tenant metadata (business details, tenant IDs) and potentially cross-tenant data (like supported currencies).

## Core Components

1.  **Master Database (`ventesca_master_db`)**
    *   Stores shared data and tenant metadata.
    *   Key Tables: `businesses`, `business_users`, `supported_currencies`.
    *   Managed by `MasterJpaConfig` and `masterDataSource`.

2.  **Tenant Databases (`ventesca_{tenantId}_db`)**
    *   Each tenant has a separate database with the same schema structure.
    *   Holds tenant-specific data: `brands`, `categories`, `products`, `suppliers`, `inventory_items`, etc.
    *   Schema managed by Liquibase using `tenant-changelog-master.xml`.
    *   Managed by `TenantJpaConfig` and the routing datasource mechanism.

3.  **Tenant Identifier (`tenant/vo/TenantIdentifier.kt`)**
    *   A type-safe Kotlin `value class` wrapping the unique `String` ID generated for each tenant (e.g., `businessname_a1b2c3d4`).
    *   Stored in the `businesses` table in the master DB.
    *   Generated by `TenantIdentifier.generateFrom(businessName)`.

4.  **Tenant Context (`tenant/TenantContext.kt`)**
    *   A singleton `object` holding the current tenant's ID (`String?`) in an `InheritableThreadLocal`.
    *   This makes the current tenant ID accessible throughout the execution of a single request thread (and any child threads it spawns).
    *   Methods: `setCurrentTenant(id: String?)`, `getCurrentTenant(): String?`, `clear()`.
    *   It's crucial to `clear()` the context at the end of each request/operation (handled by `TenantAuthenticationFilter`).

5.  **Tenant Data Source Management (`tenant/TenantDataSource.kt`)**
    *   A Spring `@Component` responsible for creating and caching `DataSource` (HikariCP connection pool) instances for each tenant database *on demand*.
    *   Uses `TenantDataSourceProperties` (bound to `app.datasource.tenant.*` properties) for configuration (URL template, credentials, pool settings).
    *   Provides `getDataSource(tenantId)`, `addTenant(tenantId)`, `removeTenant(tenantId)`.

6.  **DataSource Configuration (`tenant/config/DataSourceConfig.kt`)**
    *   Defines the primary Spring `@Bean`s for `DataSource`.
    *   `masterDataSource`: A `DataSource` bean pointing directly to the master database, configured via `MasterDataSourceProperties` (`app.datasource.master.*`).
    *   `tenantRoutingDataSource`: The `@Primary` `DataSource` bean injected into most of the application. This is an instance of `DynamicTenantAwareRoutingSource`.

7.  **Routing DataSource (`tenant/DynamicTenantAwareRoutingSource.kt`)**
    *   Extends Spring's `AbstractRoutingDataSource`.
    *   Its `determineTargetDataSource()` method is called whenever a connection is requested from it.
    *   It checks `TenantContext.getCurrentTenant()`:
        *   If a tenant ID is set, it calls `TenantDataSource.getDataSource(tenantId)` to get the connection pool for that specific tenant's database.
        *   If no tenant ID is set (e.g., during startup, background tasks, or accessing master data), it returns the connection pool for the configured `defaultTargetDataSource` (which is set to the `masterDataSource` bean in `DataSourceConfig`).

8.  **Hibernate Integration:**
    *   **Tenant ID Resolver (`tenant/TenantSchemaResolver.kt`)**:
        *   Implements Hibernate's `CurrentTenantIdentifierResolver<String>`.
        *   Its `resolveCurrentTenantIdentifier()` method calls `TenantContext.getCurrentTenant()` and returns the ID (or `"default"`) to Hibernate, telling it which tenant's context is active.
    *   **Connection Provider (`tenant/MultiTenantDbConnectionProvider.kt`)**:
        *   Implements Hibernate's `MultiTenantConnectionProvider<String>`.
        *   When Hibernate needs a connection for a specific tenant ID (provided by the resolver), the `getConnection(tenantIdentifier)` method is called.
        *   This implementation uses the injected `TenantDataSource` service to get the `DataSource` for the *specific* `tenantIdentifier` and returns a connection from that pool.
        *   The `getAnyConnection()` method returns a connection from the injected `masterDataSource` pool.

9.  **JPA Configuration (`config/jpa/`):**
    *   **`BaseJpaConfig.kt`:** Common helpers for creating Hibernate adapters and properties.
    *   **`MasterJpaConfig.kt`:** Configures the `EntityManagerFactory` (`masterEntityManagerFactory`) and `TransactionManager` (`masterTransactionManager`) specifically for the master database. Scans only for master entities (`Business`, `Currency`) and repositories.
    *   **`TenantJpaConfig.kt`:** Configures the `@Primary` `EntityManagerFactory` (`entityManagerFactory`) and `TransactionManager` (`transactionManager`) used by default for tenant data.
        *   Uses the `tenantRoutingDataSource`.
        *   Configured with the `TenantSchemaResolver` and `MultiTenantDbConnectionProvider`.
        *   Sets Hibernate's multi-tenancy strategy to `DATABASE`.
        *   Scans for tenant-specific entities (Brand, Category, Product, etc.) and repositories, *excluding* master entities/repositories.

10. **Request Flow & Context Setting (`security/TenantAuthenticationFilter.kt`)**
    *   This Spring Security filter runs *after* user authentication (`BearerTokenAuthenticationFilter`).
    *   It extracts the authenticated user's identifier (e.g., email from JWT).
    *   It queries the `BusinessDataPort` (which uses the master DataSource implicitly via the routing source defaulting to master when no tenant is set) to find the `tenantId` associated with the user.
    *   If a `tenantId` is found, it calls `TenantContext.setCurrentTenant(tenantId)`.
    *   If no `tenantId` is found for an authenticated user, it throws `TenantNotFoundException` (resulting in a 403 Forbidden response).
    *   A `finally` block ensures `TenantContext.clear()` is called after the rest of the filter chain executes.

11. **Schema Management (`tenant/TenantManagementService.kt` - *To Be Migrated*)**
    *   Handles creating new tenant databases (`CREATE DATABASE ...`).
    *   Handles running Liquibase migrations (`tenant-changelog-master.xml`) against specific tenant databases after creation or during updates.
    *   Depends on `TenantDataSource` and the `masterDataSource`.

## Key Decisions & Reminders

*   **Strategy:** Database per Tenant.
*   **Tenant ID:** Type-safe `value class TenantIdentifier(val value: String)`. Generated based on business name + UUID suffix.
*   **Context Propagation:** `InheritableThreadLocal` in `TenantContext`, set by `TenantAuthenticationFilter`, cleared in `finally` block.
*   **DataSource Routing:** Handled by `DynamicTenantAwareRoutingSource` delegating to `TenantDataSource` for tenant pools and using a configured default (master pool) when no tenant context is set.
*   **Hibernate Integration:** Uses standard Hibernate multi-tenancy interfaces (`CurrentTenantIdentifierResolver`, `MultiTenantConnectionProvider`) linked to `TenantContext` and `TenantDataSource`.
*   **Configuration:** Separate JPA configurations (`MasterJpaConfig`, `TenantJpaConfig`) manage distinct persistence units. `@ConfigurationProperties` used for cleaner property binding.
*   **Error Handling:** Tenant resolution failures result in `TenantNotFoundException` (403). Tenant creation failures result in `TenantCreationException` (500). Both are handled by `GlobalExceptionHandler`.
*   **Testing:** Integration tests need to manage test tenant creation, run tenant migrations, and set `TenantContext` appropriately. (Using Testcontainers with programmatic DB/schema setup is recommended).

---

================================================
File: dev/cnpe/ventescabekotlin/tenant/DynamicTenantAwareRoutingSource.kt
================================================
package dev.cnpe.ventescabekotlin.tenant

import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource
import javax.sql.DataSource

private val log = KotlinLogging.logger {}

class DynamicTenantAwareRoutingSource(
    private val tenantDataSource: TenantDataSource
) : AbstractRoutingDataSource() {

    companion object {
        const val DEFAULT_TENANT_KEY = "default"
    }


    /**
     * Determines the lookup key for the current DataSource based on TenantContext.
     * Returns the tenant ID string or a default key if no tenant is set.
     * This key is used by AbstractRoutingDataSource's internal map *if* determineTargetDataSource is NOT overridden.
     * Since we override determineTargetDataSource, this method's return value is less critical
     * but still good practice to implement correctly.
     */
    override fun determineCurrentLookupKey(): Any? {
        val tenantId = TenantContext.getCurrentTenant()
        val lookupKey = tenantId ?: DEFAULT_TENANT_KEY
        log.trace { "Determined current lookup key: $lookupKey" }
        return lookupKey
    }

    /**
     * Directly determines and returns the target DataSource based on TenantContext.
     * This overrides the default lookup mechanism of AbstractRoutingDataSource
     * and allows for dynamic creation/retrieval via TenantDataSource.
     */
    override fun determineTargetDataSource(): DataSource {
        val tenantId = TenantContext.getCurrentTenant()

        return if (tenantId != null) {
            log.debug { "Routing to DataSource for tenant: $tenantId" }
            tenantDataSource.getDataSource(tenantId)
        } else {
            log.debug { "No tenant context found, routing to default DataSource." }
            resolvedDefaultDataSource ?: throw IllegalStateException("Default target DataSource is not configured")
        }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/tenant/MultiTenantDbConnectionProvider.kt
================================================
package dev.cnpe.ventescabekotlin.tenant

import io.github.oshai.kotlinlogging.KotlinLogging
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.stereotype.Component
import java.sql.Connection
import java.sql.SQLException
import javax.sql.DataSource

private val log = KotlinLogging.logger {}

/**
 * Provides Hibernate with the correct JDBC Connection based on the resolved tenant identifier.
 * Uses TenantDataSource to retrieve the specific DataSource for a tenant
 * and the master DataSource for generic connections.
 */
@Component
class MultiTenantDbConnectionProvider(
    private val tenantDataSource: TenantDataSource,
    @Qualifier("masterDataSource") private val masterDataSource: DataSource
) : MultiTenantConnectionProvider<String> {

    /**
     * Provides a connection from the master/default pool when Hibernate needs
     * a connection without a specific tenant context.
     */
    override fun getAnyConnection(): Connection? {
        log.debug { "Getting connection from default master pool." }
        return masterDataSource.connection
    }

    /**
     * Releases a connection obtained via getAnyConnection().
     */
    @Throws(SQLException::class)
    override fun releaseAnyConnection(connection: Connection) {
        try {
            connection.close()
            log.trace { "Released 'any' connection." }
        } catch (e: SQLException) {
            log.error(e) { "Error closing 'any' connection." }
            throw e
        }
    }

    /**
     * Provides a connection specific to the given tenant identifier.
     * Retrieves the tenant-specific DataSource from TenantDataSource.
     */
    @Throws(SQLException::class)
    override fun getConnection(tenantIdentifier: String): Connection {
        log.debug { "Getting JDBC connection for tenant identifier: $tenantIdentifier" }
        val specificDataSource = tenantDataSource.getDataSource(tenantIdentifier)
        val connection = specificDataSource.connection
        log.trace { "Obtained connection for tenant '$tenantIdentifier': $connection" }
        return connection
        // Note: We are NOT setting TenantContext here. Hibernate calls this *after*
        // TenantSchemaResolver has determined the identifier.
    }

    /**
     * Releases a connection obtained via getConnection(tenantIdentifier).
     */
    @Throws(SQLException::class)
    override fun releaseConnection(tenantIdentifier: String, connection: Connection) {
        log.trace { "Releasing connection for tenant: $tenantIdentifier" }
        try {
            connection.close()
            log.trace { "Released connection for tenant '$tenantIdentifier'." }
        } catch (e: SQLException) {
            log.error(e) { "Error closing connection for tenant '$tenantIdentifier'." }
            throw e
        }
    }

    /**
     * Indicates whether the provider supports aggressive release of connections.
     * Returning false is generally safer unless specifically needed.
     */
    override fun supportsAggressiveRelease(): Boolean {
        return false
    }

    override fun isUnwrappableAs(p0: Class<*>): Boolean {
        return false
    }

    override fun <T : Any?> unwrap(unwrapType: Class<T>): T {
        throw UnsupportedOperationException("TenantConnectionProvider does not support unwrap()")
    }
}

================================================
File: dev/cnpe/ventescabekotlin/tenant/TenantContext.kt
================================================
package dev.cnpe.ventescabekotlin.tenant

import io.github.oshai.kotlinlogging.KotlinLogging

private val log = KotlinLogging.logger { }

/**
 * Holds the identifier for the current tenant within the current thread.
 * Uses an InheritableThreadLocal so child threads can access the tenant context.
 */
object TenantContext {

    private val CURRENT_TENANT = InheritableThreadLocal<String?>()


    /**
     * Returns the tenant identifier for the current thread, or null if none is set.
     */
    fun getCurrentTenant(): String? {
        return CURRENT_TENANT.get()
    }

    /**
     * Sets the tenant identifier for the current thread.
     * Setting null effectively clears it, but using clear() is more explicit.
     *
     * @param tenant The tenant identifier string, or null to clear.
     */
    fun setCurrentTenant(tenant: String?) {
        if (tenant != null) {
            log.trace { "Setting tenant context to : $tenant" }
            CURRENT_TENANT.set(tenant)
        } else {
            clear()
        }
    }

    /**
     * Clears the tenant identifier for the current thread.
     * Should be called at the end of a request or operation.
     */
    fun clear() {
        log.trace { "Clearing tenant context (was: ${CURRENT_TENANT.get()})" }
        CURRENT_TENANT.remove()
    }
}

================================================
File: dev/cnpe/ventescabekotlin/tenant/TenantDataSource.kt
================================================
package dev.cnpe.ventescabekotlin.tenant

import com.zaxxer.hikari.HikariDataSource
import dev.cnpe.ventescabekotlin.tenant.config.TenantDataSourceProperties
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Component
import java.util.concurrent.ConcurrentHashMap
import javax.sql.DataSource

private val log = KotlinLogging.logger { }

@Component
class TenantDataSource(
    private val properties: TenantDataSourceProperties
) {
    private val dataSources: MutableMap<String, DataSource> = ConcurrentHashMap()

    /**
     * Retrieves the DataSource for the given tenantId.
     * Creates and caches the DataSource if it doesn't exist.
     *
     * @param tenantId The identifier of the tenant.
     * @return The DataSource for the tenant.
     * @throws IllegalArgumentException if tenantId is blank.
     */
    fun getDataSource(tenantId: String): DataSource {
        require(tenantId.isNotBlank()) { "Tenant ID cannot be blank" }

        return dataSources.computeIfAbsent(tenantId) { key ->
            log.info { "Creating new DataSource for tenant: $key" }
            createDataSource(key)
        }
    }

    /**
     * Explicitly adds a tenant DataSource to the cache. Typically called during tenant creation.
     * Ensures the DataSource is ready before it might be needed.
     *
     * @param tenantId The identifier of the tenant to add.
     */
    fun addTenant(tenantId: String) {
        require(tenantId.isNotBlank()) { "Tenant ID cannot be blank" }
        dataSources.computeIfAbsent(tenantId) { key ->
            log.info { "Preemptively creating DataSource for added tenant: $key" }
            createDataSource(key)
        }
    }

    /**
     * Removes a tenant's DataSource from the cache and closes it.
     * Should be called when a tenant is deactivated or deleted.
     *
     * @param tenantId The identifier of the tenant to remove.
     */
    fun removeTenant(tenantId: String) {
        val dataSource = dataSources.remove(tenantId)
        if (dataSource != null) {
            log.info { "Removing and closing DataSource for tenant: $tenantId" }
            (dataSource as? HikariDataSource)?.close()
        } else {
            log.warn { "Attempted to remove DataSource for non-cached tenant: $tenantId" }
        }
    }

    /**
     * Creates a new HikariDataSource instance for a specific tenant.
     */
    private fun createDataSource(tenantId: String): DataSource {
        val resolvedUrl = properties.urlTemplate.replace("{tenant}", tenantId)
        log.debug { "Resolved JDBC URL for tenant '$tenantId': $resolvedUrl" }

        val ds = HikariDataSource()
        ds.jdbcUrl = resolvedUrl
        ds.username = properties.username
        ds.password = properties.password
        ds.poolName = "${properties.hikari.poolNamePrefix}$tenantId"
        ds.maximumPoolSize = properties.hikari.maximumPoolSize

        return ds
    }
}

================================================
File: dev/cnpe/ventescabekotlin/tenant/TenantSchemaResolver.kt
================================================
package dev.cnpe.ventescabekotlin.tenant

import io.github.oshai.kotlinlogging.KotlinLogging
import org.hibernate.context.spi.CurrentTenantIdentifierResolver
import org.springframework.stereotype.Component

private val log = KotlinLogging.logger {}

/**
 * Resolves the current tenant identifier for Hibernate multi-tenancy.
 * Retrieves the tenant ID from the TenantContext ThreadLocal.
 */
@Component
class TenantSchemaResolver : CurrentTenantIdentifierResolver<String> {

    companion object {
        // The constant used when no tenant context is found (e.g., during startup or background tasks)
        // This MUST match the key used for the default datasource in DataSourceConfig
        const val DEFAULT_TENANT_ID = "default"
    }

    /**
     * Returns the current tenant identifier from TenantContext, or a default value.
     */
    override fun resolveCurrentTenantIdentifier(): String? {
        val tenantId = TenantContext.getCurrentTenant() ?: DEFAULT_TENANT_ID
        log.trace { "Resolved current tenant identifier: $tenantId" }
        return tenantId
    }

    /**
     * Indicates whether Hibernate should validate that the resolved tenant identifier
     * matches the identifier associated with any existing session. Returning true is safer.
     */
    override fun validateExistingCurrentSessions(): Boolean {
        return true
    }

}

================================================
File: dev/cnpe/ventescabekotlin/tenant/config/DataSourceConfig.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.config

import com.zaxxer.hikari.HikariDataSource
import dev.cnpe.ventescabekotlin.tenant.DynamicTenantAwareRoutingSource
import dev.cnpe.ventescabekotlin.tenant.TenantDataSource
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import javax.sql.DataSource

private val log = KotlinLogging.logger {}

@Configuration

class DataSourceConfig {


    /**
     * Creates the primary DataSource bean for the Master database.
     * Reads connection details directly from @Value annotations.
     */
    @Bean("masterDataSource")
    fun masterDataSource(properties: MasterDataSourceProperties): DataSource {
        log.info { "Creating Master DataSource bean (Pool: ${properties.hikari.poolName})..." }
        return HikariDataSource().apply {
            jdbcUrl = properties.url
            username = properties.username
            password = properties.password
            poolName = properties.hikari.poolName
            maximumPoolSize = properties.hikari.maximumPoolSize
            driverClassName = "org.postgresql.Driver" // Should we externalize this?
        }
    }

    /**
     * Creates the routing DataSource bean that directs connections
     * to the appropriate tenant DataSource based on TenantContext.
     * This will be the primary DataSource used by the application's EntityManagerFactory.
     */
    @Primary
    @Bean("tenantRoutingDataSource")
    fun tenantRoutingDataSource(
        @Qualifier("masterDataSource") masterDataSource: DataSource,
        tenantDataSource: TenantDataSource
    ): DataSource {
        log.info { "Creating Tenant Routing DataSource bean..." }

        val routingSource = DynamicTenantAwareRoutingSource(tenantDataSource)
        routingSource.setDefaultTargetDataSource(masterDataSource)

        val initialDataSources = HashMap<Any, Any>()
        initialDataSources["default"] = masterDataSource
        routingSource.setTargetDataSources(initialDataSources)

        routingSource.afterPropertiesSet()

        log.info { "Tenant Routing DataSource created. Default target: masterDataSource" }
        return routingSource
    }

}

================================================
File: dev/cnpe/ventescabekotlin/tenant/config/MasterDataSourceProperties.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.config

import jakarta.validation.constraints.NotBlank
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.NestedConfigurationProperty
import org.springframework.validation.annotation.Validated

@ConfigurationProperties(prefix = "app.datasource.master")
@Validated
data class MasterDataSourceProperties(

    @field:NotBlank
    val url: String,

    @field:NotBlank
    val username: String,

    @field:NotBlank
    val password: String,

    @NestedConfigurationProperty
    val hikari: HikariMasterProperties = HikariMasterProperties()

)

data class HikariMasterProperties(
    val maximumPoolSize: Int = 5,
    val poolName: String = "master-pool"
)

================================================
File: dev/cnpe/ventescabekotlin/tenant/config/TenantDataSourceProperties.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.config

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Positive
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.NestedConfigurationProperty
import org.springframework.validation.annotation.Validated

/**
 * Configuration properties for tenant data-sources.
 * Maps properties starting with 'tenant.datasource'/
 */
@ConfigurationProperties(prefix = "app.datasource.tenant")
@Validated
data class TenantDataSourceProperties(

    @field:NotBlank
    val urlTemplate: String, // jdbc:postgresql://{host}:{port}/ventesca_{tenant}_db

    @field:NotBlank
    val username: String,

    @field:NotBlank
    val password: String,

    @NestedConfigurationProperty
    val hikari: HikariTenantProperties = HikariTenantProperties()

)

data class HikariTenantProperties(
    @field:NotNull @field:Positive
    val maximumPoolSize: Int = 10,

    @field:NotBlank
    val poolNamePrefix: String = "tenant-pool-"
)


================================================
File: dev/cnpe/ventescabekotlin/tenant/config/TenantSchemaInitializer.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.config

import dev.cnpe.ventescabekotlin.tenant.service.TenantManagementService
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.boot.CommandLineRunner
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.core.annotation.Order
import org.springframework.stereotype.Component
import kotlin.system.measureTimeMillis

private val log = KotlinLogging.logger {}

/**
 * Optional CommandLineRunner that triggers schema updates for all existing tenants
 * on application startup if the property 'app.tenant.schema.auto-update-on-startup' is set to true.
 */
@Component
@Order(1)
@ConditionalOnProperty(
    name = ["app.tenant.schema.auto-update-on-startup"],
    havingValue = "true",
    matchIfMissing = false // do not run if property missing
)
class TenantSchemaInitializer(
    private val tenantManagementService: TenantManagementService
) : CommandLineRunner {

    override fun run(vararg args: String?) {
        log.info { "✨ Schema auto-update enabled. Starting tenant schema updates..." }
        val duration = measureTimeMillis {
            try {
                tenantManagementService.updateAllTenantsSchema()
            } catch (e: Exception) {
                log.error(e) { "Error during automatic tenant schema update! Application will continue starting, but tenant schemas might be inconsistent." }
            }
        }
        val formattedDuration = if (duration >= 1000) {
            String.format("%.2f seconds", duration / 1000.0)
        } else {
            "$duration ms"
        }
        log.info { "✨ Finished tenant schema updates in $formattedDuration" }
    }
}

================================================
File: dev/cnpe/ventescabekotlin/tenant/dto/TenantOperationResult.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.dto

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Result of a tenant operation.")
data class TenantOperationResult(
    @Schema(
        description = "Human readable sentence that represents the result of the operation.",
        example = "Schema update process finished"
    )
    val message: String,

    @Schema(description = "Duration of the operation in milliseconds.")
    val durationMillis: Long
)


================================================
File: dev/cnpe/ventescabekotlin/tenant/exception/TenantCreationException.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.tenant.exception.TenantErrorCode.TENANT_SETUP_FAILED

/**
 * Exception thrown during the tenant creation/setup process (DB creation, migration).
 * Typically results in a 500 Internal Server Error.
 */
class TenantCreationException(
    val tenantIdAttempted: String? = null,
    message: String,
    cause: Throwable? = null
) : DomainException(
    errorCode = TENANT_SETUP_FAILED,
    details = tenantIdAttempted?.let { mapOf("tenantId" to it) },
    parameters = arrayOf(tenantIdAttempted ?: "N/A"),
    message = message,
    cause = cause
)

================================================
File: dev/cnpe/ventescabekotlin/tenant/exception/TenantErrorCode.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.ErrorCode
import org.springframework.http.HttpStatus
import org.springframework.http.HttpStatus.*

enum class TenantErrorCode(override val status: HttpStatus = INTERNAL_SERVER_ERROR) : ErrorCode {

    TENANT_RESOLUTION_FAILED(FORBIDDEN), // User authenticated but no tenant found/accessible (403)
    TENANT_SETUP_FAILED(INTERNAL_SERVER_ERROR)
}


================================================
File: dev/cnpe/ventescabekotlin/tenant/exception/TenantNotFoundException.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.exception

import dev.cnpe.ventescabekotlin.shared.application.exception.DomainException
import dev.cnpe.ventescabekotlin.tenant.exception.TenantErrorCode.TENANT_RESOLUTION_FAILED

/**
 * Exception thrown when the tenant for the current context (e.g., authenticated user)
 * cannot be found or resolved. Typically results in a 403 Forbidden.
 */
class TenantNotFoundException(
    val identifierTried: Any? = null, // user email or token claim
    message: String = "Tenant could not be resolved for the current context.", // default msg
    cause: Throwable? = null
) : DomainException(
    errorCode = TENANT_RESOLUTION_FAILED,
    details = identifierTried?.let { mapOf("identifier" to it) },
    parameters = arrayOf(identifierTried?.toString() ?: "unknown"),
    message = message,
    cause = cause
)

================================================
File: dev/cnpe/ventescabekotlin/tenant/infrastructure/web/TenantAdminController.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.infrastructure.web

import dev.cnpe.ventescabekotlin.tenant.dto.TenantOperationResult
import dev.cnpe.ventescabekotlin.tenant.service.TenantManagementService
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.time.Duration
import kotlin.system.measureTimeMillis

private val log = KotlinLogging.logger {}

//TODO: MAKE ASYNC SOME DAY

@RestController
@RequestMapping("/admin/tenants")
@Tag(name = "Tenant Administration", description = "Endpoints for managing tenants (Requires SUPERADMIN role).")
// TODO: Add Spring Security @PreAuthorize("hasRole('SUPERADMIN')") once roles are set up
class TenantAdminController(
    private val tenantManagementService: TenantManagementService
) {

    @PostMapping("/_actions/run-all-schema-updates")
    @Operation(
        summary = "Trigger schema migrations for all tenants",
        description = """
            Manually triggers the execution of Liquibase schema updates against ALL existing tenant databases.
            This is intended for controlled production deployments during maintenance windows.
            WARNING: This operation can take a significant amount of time depending on the number of tenants.
            The request will block until all updates are attempted. Check server logs for detailed progress and errors.
            Requires SUPERADMIN role.
            """
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Schema update process completed (check logs for details).",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = TenantOperationResult::class)
                )]
            ),
            ApiResponse(responseCode = "401", description = "Unauthorized."),
            ApiResponse(responseCode = "403", description = "Forbidden (User does not have SUPERADMIN role)."),
            ApiResponse(responseCode = "500", description = "Internal error during the update process.")
        ]
    )
    fun runAllTenantSchemaUpdates(): ResponseEntity<TenantOperationResult> {
        log.warn { "🔸 Received request to run schema updates for ALL tenants. This may take time..." }
        var resultMessage = "Schema update process finished."
        var status = HttpStatus.OK
        var durationMillis: Long = 0

        try {
            durationMillis = measureTimeMillis {
                tenantManagementService.updateAllTenantsSchema()
            }
            log.info { "Finished processing run-all-schema-updates request in ${Duration.ofMillis(durationMillis)}." }
        } catch (e: Exception) {
            log.error(e) { "Critical error during run-all-schema-updates endpoint execution!" }
            resultMessage = "Error occurred during schema update process initiation. Check server logs."
            status = HttpStatus.INTERNAL_SERVER_ERROR
        }

        val result = TenantOperationResult(resultMessage, durationMillis)
        return ResponseEntity(result, status)
    }

    @PostMapping("/{tenantId}/_actions/run-schema-update")
    @Operation(
        summary = "Trigger schema migration for a single tenant",
        description = "Updates schema for a single tenant. Requires SUPERADMIN role. Check server logs for detailed progress and errors."
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Schema update process completed (check logs for details).",
                content = [Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = TenantOperationResult::class)
                )]
            ),
            ApiResponse(responseCode = "401", description = "Unauthorized."),
            ApiResponse(responseCode = "403", description = "Forbidden (User does not have SUPERADMIN role)."),
            ApiResponse(responseCode = "500", description = "Internal error during the update process.")
        ]
    )
    fun runSchemaUpdatesForSingleTenant(
        @PathVariable(name = "tenantId") tenantId: String
    )
            : ResponseEntity<TenantOperationResult> {
        var resultMessage = "Schema update process finished."
        var status = HttpStatus.OK
        var durationMillis: Long = 0

        try {
            durationMillis = measureTimeMillis {
                tenantManagementService.updateTenantSchema(tenantId)
            }
            log.info { "Finished updating schema for tenant $tenantId in ${Duration.ofMillis(durationMillis)}." }
        } catch (e: Exception) {
            log.error { "Critical error during run-schema-updates endpoint execution for tenant $tenantId!" }
            resultMessage = "Error occurred during schema update process initiation. Check server logs."
            status = HttpStatus.INTERNAL_SERVER_ERROR
        }
        val result = TenantOperationResult(resultMessage, durationMillis)
        return ResponseEntity(result, status)
    }

    @GetMapping("/_actions/list-tenants")
    @Operation(summary = "List all registered tenants", description = "Lists all registered tenants (requires SUPERADMIN role).")
    @ApiResponse(
        responseCode = "200",
        description = "List of tenant IDs retrieved successfully.",
        content = [Content(
            mediaType = "application/json",
            schema = Schema(implementation = String::class, type = "array"),
//            array = ArraySchema(schema = Schema(type = "string", example = "mybusiness_a1b2c3"))
        )]
    )
    fun listAllRegisteredTenants(): Set<String> {
        return tenantManagementService.getTenantIds()
    }

}

================================================
File: dev/cnpe/ventescabekotlin/tenant/service/TenantManagementService.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.service

import dev.cnpe.ventescabekotlin.business.infrastructure.persistence.BusinessRepository
import dev.cnpe.ventescabekotlin.tenant.TenantDataSource
import dev.cnpe.ventescabekotlin.tenant.exception.TenantCreationException
import dev.cnpe.ventescabekotlin.tenant.vo.TenantIdentifier
import io.github.oshai.kotlinlogging.KotlinLogging
import liquibase.Liquibase
import liquibase.database.DatabaseFactory
import liquibase.database.jvm.JdbcConnection
import liquibase.resource.ClassLoaderResourceAccessor
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.jdbc.datasource.DataSourceUtils
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Propagation
import org.springframework.transaction.annotation.Transactional
import java.sql.Connection
import java.sql.SQLException
import javax.sql.DataSource

private val log = KotlinLogging.logger {}

@Service
class TenantManagementService(
    @Qualifier("masterDataSource") private val masterDataSource: DataSource,
    private val tenantDataSource: TenantDataSource,
    private val businessRepository: BusinessRepository
) {

    companion object {
        private const val TENANT_CHANGELOG_PATH = "db/changelog/tenant-changelog-master.xml"
        private const val TENANT_DB_NAME_PREFIX = "ventesca_"
        private const val TENANT_DB_NAME_SUFFIX = "_db"
    }

    /**
     * Creates a new tenant: generates ID, creates database, runs migrations, adds datasource pool.
     * IMPORTANT: Database creation happens outside main transaction.
     *
     * @param businessName Name used to generate the tenant identifier.
     * @return The generated TenantIdentifier.
     * @throws TenantCreationException if any step fails.
     */
    @Transactional(propagation = Propagation.NEVER)
    fun createTenant(businessName: String): TenantIdentifier {
        val tenantId = TenantIdentifier.generateFrom(businessName)
        val dbName = generateDatabaseName(tenantId)
        log.info { "Attempting to create tenant: ID=${tenantId.value}, DB=$dbName" }

        try {
            // 1. Create the physical database (No Spring Transaction)
            createTenantDatabase(dbName)

            // 2. Add DataSource pool to cache BEFORE running migrations
            // This allows Liquibase to get a connection via the TenantDataSource
            tenantDataSource.addTenant(tenantId.value)

            runLiquibaseUpdate(tenantId.value)

            log.info { "✅ Successfully created and initialized tenant: ${tenantId.value}" }
            return tenantId
        } catch (e: Exception) {
            log.error(e) { "❌ Tenant creation failed for ID: ${tenantId.value}. Initiating cleanup." }
            cleanupFailedTenantCreation(tenantId.value, dbName)
            throw TenantCreationException(
                tenantIdAttempted = tenantId.value,
                message = "Failed to create tenant '${tenantId.value}': ${e.message}",
                cause = e
            )
        }
    }

    /**
     * Creates the physical database using raw JDBC on the master DataSource.
     * WARNING: Requires appropriate DB user privileges. Runs outside Spring transactions.
     */
    private fun createTenantDatabase(dbName: String) {
        log.debug { "Executing CREATE DATABASE $dbName" }
        try {
            masterDataSource.connection.use { conn ->
                conn.createStatement().use { stmt ->
                    stmt.execute("CREATE DATABASE \"$dbName\"")
                }
            }
            log.info { "Database '$dbName' created successfully." }
        } catch (e: SQLException) {
            // Check if error is because DB already exists
            // PSQLState for "duplicate_database" is "42P04"
            if (e.sqlState == "42P04") {
                log.warn { "Database '$dbName' already exists. Assuming schema setup is next step." }
            } else {
                log.error(e) { "SQL Exception during CREATE DATABASE $dbName (SQLState: ${e.sqlState})" }
                throw TenantCreationException(
                    message = "Failed to execute CREATE DATABASE statement for '$dbName'",
                    cause = e
                )
            }
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during CREATE DATABASE $dbName" }
            throw TenantCreationException(message = "Failed creating database '$dbName'", cause = e)
        }
    }

    /**
     * Runs Liquibase schema migrations for the specified tenant ID.
     */
    @Throws(TenantCreationException::class)
    private fun runLiquibaseUpdate(tenantId: String) {
        log.info { "Running Liquibase migrations for tenant: $tenantId" }
        var connection: Connection? = null
        try {
            connection = DataSourceUtils.getConnection(tenantDataSource.getDataSource(tenantId))
            val jdbcConnection = JdbcConnection(connection)
            val database =
                DatabaseFactory.getInstance().findCorrectDatabaseImplementation(jdbcConnection)

            val liquibase = Liquibase(TENANT_CHANGELOG_PATH, ClassLoaderResourceAccessor(), database)
            liquibase.update()

            log.info { "Liquibase migrations completed successfully for tenant: $tenantId" }
        } catch (e: Exception) {
            log.error(e) { "Liquibase migration failed for tenant: $tenantId" }
            throw TenantCreationException(
                tenantIdAttempted = tenantId,
                message = "Liquibase migration failed for tenant '$tenantId': ${e.message}",
                cause = e
            )
        } finally {
            if (connection != null) {
                DataSourceUtils.releaseConnection(connection, tenantDataSource.getDataSource(tenantId))
                log.trace { "Released Liquibase connection for tenant: $tenantId" }
            }
        }
    }

    /**
     * Attempts to clean up resources if tenant creation fails.
     * Removes the DataSource pool and optionally tries to drop the database.
     */
    private fun cleanupFailedTenantCreation(tenantId: String, dbName: String) {
        log.warn { "Attempting cleanup for failed tenant creation: ID=$tenantId, DB=$dbName" }
        try {
            tenantDataSource.removeTenant(tenantId)
        } catch (e: Exception) {
            log.error(e) { "Cleanup failed: Error removing DataSource for tenant $tenantId" }
        }

        // This might fail if connections are still open or due to permissions.
        // Maybe should make DB drop a separate manual/admin operation?????
        try {
            log.warn { "Attempting to DROP DATABASE $dbName as part of cleanup." }
            masterDataSource.connection.use { conn ->
                conn.createStatement().use { stmt ->
                    stmt.execute("DROP DATABASE IF EXISTS \"$dbName\"")
                }
            }
            log.info { "Database '$dbName' dropped during cleanup." }
        } catch (e: Exception) {
            log.error(e) { "Cleanup failed: Could not drop database $dbName. Manual cleanup may be required." }
        }
    }

    /**
     * Removes the tenant's DataSource pool from the cache. Does NOT drop the database.
     */
    fun removeTenantDataSource(tenantId: String) {
        tenantDataSource.removeTenant(tenantId)
    }

    /**
     * Runs Liquibase schema update on an existing tenant's database.
     */
    // Can run without Spring transaction as Liquibase manages its own
    @Transactional(propagation = Propagation.NEVER)
    fun updateTenantSchema(tenantId: String) {
        try {
            runLiquibaseUpdate(tenantId)
        } catch (e: TenantCreationException) {
            throw TenantCreationException(
                tenantIdAttempted = tenantId,
                message = "Failed to update tenant schema for '$tenantId': ${e.message}",
                cause = e.cause ?: e
            )
        }
    }

    /**
     * Retrieves all distinct tenant IDs stored in the master database's businesses table.
     * Requires BusinessRepository to be migrated and injected.
     */
    // Specify master transaction manager, read-only
    @Transactional(readOnly = true, transactionManager = "masterTransactionManager")
    fun getTenantIds(): Set<String> {
        log.debug { "Querying master database for all distinct tenant IDs..." }
        return businessRepository.findAllDistinctTenantIds()
    }

    /**
     * Runs Liquibase schema updates on all known tenants retrieved from the master database.
     */
    fun updateAllTenantsSchema() {
        val tenantIds = getTenantIds()
        if (tenantIds.isEmpty()) {
            log.info { "No tenant IDs found in master database. Skipping schema updates." }
            return
        }

        log.info { "Starting schema updates for ${tenantIds.size} tenants..." }
        var successCount = 0
        var failureCount = 0
        tenantIds.forEach { tenantId ->
            try {
                updateTenantSchema(tenantId)
                log.info { "✅ Successfully updated schema for tenant [$tenantId]" }
                successCount++
            } catch (e: Exception) {
                log.error(e) { "❌ Failed to update schema for tenant [$tenantId]" }
                failureCount++
            }
        }
        log.info { "Finished tenant schema updates. Success: $successCount, Failures: $failureCount" }
    }

    private fun generateDatabaseName(tenantId: TenantIdentifier): String {
        val safeTenantValue = tenantId.value.lowercase().replace(Regex("[^a-z0-9_]"), "") // ensure valid name for db
        return "$TENANT_DB_NAME_PREFIX${safeTenantValue}$TENANT_DB_NAME_SUFFIX"
    }
}

================================================
File: dev/cnpe/ventescabekotlin/tenant/vo/TenantIdentifier.kt
================================================
package dev.cnpe.ventescabekotlin.tenant.vo

import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import java.util.*

/**
 * Represents a type-safe identifier for a tenant.
 *
 * @property value The underlying string representation of the tenant ID.
 */
@Embeddable
data class TenantIdentifier(
    @Column(name = "tenant_id", nullable = false, updatable = false, unique = true)
    val value: String
) {
    init {
        require(value.isNotBlank()) { "TenantIdentifier value cannot be blank" }
    }

    companion object {
        private const val PREFIX_MAX_LENGTH = 10
        private const val SUFFIX_LENGTH = 8


        /**
         * Generates a new TenantIdentifier based on a business name.
         * Creates a cleaned prefix from the name and appends a random suffix.
         * Example: "My Awesome Corp" -> "myawesomec_a1b2c3d4"
         *
         * @param businessName The name to base the identifier on.
         * @return A newly generated TenantIdentifier.
         */
        fun generateFrom(businessName: String): TenantIdentifier {
            require(businessName.isNotBlank()) { "Business name cannot be blank for generating Tenant ID" }

            val suffix = UUID.randomUUID().toString().replace("-", "").take(SUFFIX_LENGTH)
            val cleanedPrefix = businessName.lowercase()
                .replace(Regex("[^a-z0-9]"), "")
                .take(PREFIX_MAX_LENGTH)

            val finalPrefix = cleanedPrefix.ifEmpty { "tenant" }

            val generatedValue = "${finalPrefix}_$suffix"
            return TenantIdentifier(generatedValue)
        }
    }
}


